(self.webpackChunktradingview = self.webpackChunktradingview || []).push([
    [25821], {
        933621: (e, t, n) => {
            var a = n(354948).t;
            e.exports = {
                keywords: ["not", "or", "and", "if", "else", "for", "to", "by", "break", "continue", "var", "int", "float", "bool", "color", "string", "line", "label", "table", "box", "varip", "export", "import", "as", "simple", "series", "switch", "while", "in", "linefill", "array", "matrix"],
                operators: {
                    title: a("Language Operators"),
                    prefix: "op_",
                    docs: {
                        "?:": {
                            name: "?:",
                            desc: [a("Ternary conditional operator.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 ? expr2 : expr3"],
                            returns: [a("expr2 if expr1 is evaluated to true, expr3 otherwise. Zero value (0 and also NaN, +Infinity, -Infinity) is considered to be false, any other value is true.", {
                                context: "pine_docs_returns"
                            })],
                            remarks: [a("Use {@var na} for 'else' branch if you do not need it.", {
                                context: "pine_docs_remarks"
                            }), a("You can combine two or more {@op ?:} operators to achieve the equivalent of a 'switch'-like statement (see examples above).", {
                                context: "pine_docs_remarks"
                            }), a("You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("?:")', "// Draw circles at the bars where open crosses close", "s2 = ta.cross(open, close) ? math.avg(open,close) : na", "plot(s2, style=plot.style_circles, linewidth=2, color=color.red)", "", "// Combination of ?: operators for 'switch'-like logic", "c = timeframe.isintraday ? color.red : timeframe.isdaily ? color.green : timeframe.isweekly ? color.blue : color.gray", "plot(hl2, color=c)"],
                            seeAlso: ["{@var na}"]
                        },
                        "+": {
                            desc: [a("Addition or unary plus. Applicable to numerical expressions or strings.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 + expr2", "+ expr"],
                            returns: [a("Binary `+` for strings returns concatenation of expr1 and expr2", {
                                context: "pine_docs_returns"
                            }), a("For numbers returns integer or float value, or series of values:", {
                                context: "pine_docs_returns"
                            }), a("Binary `+` returns expr1 plus expr2.", {
                                context: "pine_docs_returns"
                            }), a("Unary `+` returns expr (does nothing added just for the symmetry with the unary - operator).", {
                                context: "pine_docs_returns"
                            })],
                            remarks: [a("You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise.", {
                                context: "pine_docs_remarks"
                            })]
                        },
                        "-": {
                            desc: [a("Subtraction or unary minus. Applicable to numerical expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 - expr2", "- expr"],
                            returns: [a("Returns integer or float value, or series of values:", {
                                context: "pine_docs_returns"
                            }), a("Binary `-` returns expr1 minus expr2.", {
                                context: "pine_docs_returns"
                            }), a("Unary `-` returns the negation of expr.", {
                                context: "pine_docs_returns"
                            })],
                            remarks: [a("You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise.", {
                                context: "pine_docs_remarks"
                            })]
                        },
                        "[]": {
                            name: "[]",
                            desc: [a("Series subscript. Provides access to previous values of series expr1. expr2 is the number of bars back, and must be numerical. Floats will be rounded down.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1[expr2]"],
                            returns: [a("A series of values.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("[]")', '// [] can be used to "save" variable value between bars', "a = 0.0 // declare `a`", "a := a[1] // immediately set current value to the same as previous. `na` in the beginning of history", "if high == low // if some condition - change `a` value to another", "    a := low", "plot(a)"],
                            seeAlso: ["{@fun math.floor}"]
                        },
                        "==": {
                            desc: [a("Equal to. Applicable to expressions of any type.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 == expr2"],
                            returns: [a("Boolean value, or series of boolean values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        "!=": {
                            desc: [a("Not equal to. Applicable to expressions of any type.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 != expr2"],
                            returns: [a("Boolean value, or series of boolean values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        ">": {
                            desc: [a("Greater than. Applicable to numerical expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 > expr2"],
                            returns: [a("Boolean value, or series of boolean values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        "<": {
                            desc: [a("Less than. Applicable to numerical expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 < expr2"],
                            returns: [a("Boolean value, or series of boolean values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        ">=": {
                            desc: [a("Greater than or equal to. Applicable to numerical expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 >= expr2"],
                            returns: [a("Boolean value, or series of boolean values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        "<=": {
                            desc: [a("Less than or equal to. Applicable to numerical expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 <= expr2"],
                            returns: [a("Boolean value, or series of boolean values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        "*": {
                            desc: [a("Multiplication. Applicable to numerical expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 * expr2"],
                            returns: [a("Integer or float value, or series of values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        "/": {
                            desc: [a("Division. Applicable to numerical expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 / expr2"],
                            returns: [a("Integer or float value, or series of values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        "%": {
                            desc: [a("Modulo (integer remainder). Applicable to numerical expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 % expr2"],
                            remarks: [a("In Pine Script™, when the integer remainder is calculated, the quotient is truncated, i.e. rounded towards the lowest absolute value. The resulting value will have the same sign as the dividend.", {
                                context: "pine_docs_remarks"
                            }), a("Example: -1 % 9 = -1 - 9 * truncate(-1/9) = -1 - 9 * truncate(-0.111) = -1 - 9 * 0 = -1.", {
                                context: "pine_docs_remarks"
                            })],
                            returns: [a("Integer or float value, or series of values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        "+=": {
                            desc: [a("Addition assignment. Applicable to numerical expressions or strings.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 += expr2"],
                            remarks: [a("You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("+=")', "// Equals to expr1 = expr1 + expr2.", "a = 2", "b = 3", "a += b", "// Result: a = 5.", "plot(a)"],
                            returns: [a("For strings returns concatenation of expr1 and expr2. For numbers returns integer or float value, or series of values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        "-=": {
                            desc: [a("Subtraction assignment. Applicable to numerical expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 -= expr2"],
                            examples: ["//@version=5", 'indicator("-=")', "// Equals to expr1 = expr1 - expr2.", "a = 2", "b = 3", "a -= b", "// Result: a = -1.", "plot(a)"],
                            returns: [a("Integer or float value, or series of values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        "*=": {
                            desc: [a("Multiplication assignment. Applicable to numerical expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 *= expr2"],
                            examples: ["//@version=5", 'indicator("*=")', "// Equals to expr1 = expr1 * expr2.", "a = 2", "b = 3", "a *= b", "// Result: a = 6.", "plot(a)"],
                            returns: [a("Integer or float value, or series of values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        "/=": {
                            desc: [a("Division assignment. Applicable to numerical expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 /= expr2"],
                            examples: ["//@version=5", 'indicator("/=")', "// Equals to expr1 = expr1 / expr2.", "a = 3", "b = 3", "a /= b", "// Result: a = 1.", "plot(a)"],
                            returns: [a("Integer or float value, or series of values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        "%=": {
                            desc: [a("Modulo assignment. Applicable to numerical expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 %= expr2"],
                            examples: ["//@version=5", 'indicator("%=")', "// Equals to expr1 = expr1 % expr2.", "a = 3", "b = 3", "a %= b", "// Result: a = 0.", "plot(a)"],
                            returns: [a("Integer or float value, or series of values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        "=>": {
                            desc: [a("The '=>' operator is used in user-defined function declarations and in {@op switch} statements.", {
                                context: "pine_docs_desc"
                            }), a("The function declaration syntax is:", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["&lt;identifier&gt;([&lt;parameter_name&gt;[=&lt;default_value&gt;]], ...) =><br>&ensp;&emsp;&lt;local_block&gt;<br>&ensp;&emsp;&lt;function_result&gt;"],
                            detailedDesc: [{
                                desc: [a("A &lt;local_block&gt; is zero or more Pine Script™ statements.", {
                                    context: "pine_docs_desc"
                                }), a("The &lt;function_result&gt; is a variable, an expression, or a tuple.", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("=>")', "// single-line function", "f1(x, y) => x + y", "// multi-line function", "f2(x, y) => ", "\tsum = x + y", "\tsumChange = ta.change(sum, 10)", "\t// Function automatically returns the last expression used in it", "plot(f1(30, 8) + f2(1, 3))"]
                            }],
                            remarks: [a("You can learn more about user-defined functions in the User Manual's pages on {html_markup_1}Declaring functions{html_markup_2} and {html_markup_3}Libraries{html_markup_4}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/User-defined_functions.html">',
                                html_markup_2: "</a>",
                                html_markup_3: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Libraries.html">',
                                html_markup_4: "</a>"
                            })]
                        },
                        or: {
                            desc: [a("Logical OR. Applicable to boolean expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 or expr2"],
                            returns: [a("Boolean value, or series of boolean values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        and: {
                            desc: [a("Logical AND. Applicable to boolean expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["expr1 and expr2"],
                            returns: [a("Boolean value, or series of boolean values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        not: {
                            desc: [a("Logical negation (NOT). Applicable to boolean expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["not expr1"],
                            returns: [a("Boolean value, or series of boolean values.", {
                                context: "pine_docs_returns"
                            })]
                        },
                        if: {
                            desc: [a("If statement defines what block of statements must be executed when conditions of the expression are satisfied.", {
                                context: "pine_docs_desc"
                            }), a("To have access to and use the if statement, one should specify the version >= 2 of Pine Script™ language in the very first line of code, for example: {dont_translate_1}", {
                                context: "pine_docs_desc"
                            }).format({
                                dont_translate_1: "//@version=5"
                            }), a("The 4th version of Pine Script™ Language allows you to use “else if” syntax.", {
                                context: "pine_docs_desc"
                            }), a("General code form:", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["var_declarationX = if condition<br>&ensp;&emsp;var_decl_then0<br>&ensp;&emsp;var_decl_then1<br>&ensp;&emsp;…<br>&ensp;&emsp;var_decl_thenN<br>else if [optional block]<br>&ensp;&emsp;var_decl_else0<br>&ensp;&emsp;var_decl_else1<br>&ensp;&emsp;…<br>&ensp;&emsp;var_decl_elseN<br>else<br>&ensp;&emsp;var_decl_else0<br>&ensp;&emsp;var_decl_else1<br>&ensp;&emsp;…<br>&ensp;&emsp;var_decl_elseN<br>&ensp;&emsp;return_expression_else"],
                            detailedDesc: [{
                                desc: [a("where", {
                                    context: "pine_docs_desc"
                                }), a("{b_on}var_declarationX{b_off} — this variable gets the value of the if statement", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}condition{b_off} — if the condition is true, the logic from the block 'then' (var_decl_then0, var_decl_then1, etc.) is used.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("If the condition is false, the logic from the block 'else' (var_decl_else0, var_decl_else1, etc.) is used.", {
                                    context: "pine_docs_desc"
                                }), a("{b_on}return_expression_then{b_off}, {b_on}return_expression_else{b_off} — the last expression from the block then or from the block else will return the final value of the statement. If declaration of the variable is in the end, its value will be the result.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("The type of returning value of the if statement depends on return_expression_then and return_expression_else type (their types must match: it is not possible to return an integer value from then, while you have a string value in else block).", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("if")', "// This code compiles", "x = if close > open", "    close", "else", "    open", "", "// This code doesn’t compile", "// y = if close > open", "//     close", "// else", '//     "open"', "plot(x)"]
                            }, {
                                desc: [a("It is possible to omit the `else` block. In this case if the condition is false, an “empty” value (na, false, or “”) will be assigned to the var_declarationX variable:", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("if")', "x = if close > open", "    close", "// If current close > current open, then x = close.", "// Otherwise the x = na.", "plot(x)"]
                            }, {
                                desc: [a("It is possible to use either multiple “else if” blocks or none at all. The blocks “then”, “else if”, “else” are shifted by four spaces:", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("if")', "x = if open > close", "    5", "else if high > low", "    close", "else", "    open", "plot(x)"]
                            }, {
                                desc: [a("It is possible to ignore the resulting value of an `if` statement (“var_declarationX=“ can be omitted). It may be useful if you need the side effect of the expression, for example in strategy trading:", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'strategy("if")', "if (ta.crossover(high, low))", '    strategy.entry("BBandLE", strategy.long, stop=low, oca_name="BollingerBands", oca_type=strategy.oca.cancel, comment="BBandLE")', "else", '    strategy.cancel(id="BBandLE")']
                            }, {
                                desc: [a("If statements can include each other:", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("if")', "float x = na", "if close > open", "    if close > close[1]", "        x := close", "    else", "        x := close[1]", "else", "    x := open", "plot(x)"]
                            }]
                        },
                        switch: {
                            desc: [a("The switch operator transfers control to one of the several statements, depending on the values of a condition and expressions.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["[variable_declaration = ] switch expression<br>&ensp;&emsp;value1 => local_block<br>&ensp;&emsp;value2 => local_block<br>&ensp;&emsp;…<br>&ensp;&emsp;=> default_local_block<br><br>[variable_declaration = ] switch<br>&ensp;&emsp;boolean_expression1 => local_block<br>&ensp;&emsp;boolean_expression2 => local_block<br>&ensp;&emsp;…<br>&ensp;&emsp;=> default_local_block"],
                            detailedDesc: [{
                                desc: [a("Switch with an expression:", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("Switch using an expression")', "", 'string i_maType = input.string("EMA", "MA type", options = ["EMA", "SMA", "RMA", "WMA"])', "", "float ma = switch i_maType", '\t"EMA" => ta.ema(close, 10)', '\t"SMA" => ta.sma(close, 10)', '\t"RMA" => ta.rma(close, 10)', "\t// Default used when the three first cases do not match.", "\t=> ta.wma(close, 10)", "", "plot(ma)"]
                            }, {
                                desc: [a("Switch without an expression:", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'strategy("Switch without an expression", overlay = true)', "", "bool longCondition  = ta.crossover( ta.sma(close, 14), ta.sma(close, 28))", "bool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))", "", "switch", '\tlongCondition  => strategy.entry("Long ID", strategy.long)', '\tshortCondition => strategy.entry("Short ID", strategy.short)']
                            }],
                            returns: [a("The value of the last expression in the local block of statements that is executed.", {
                                context: "pine_docs_returns"
                            })],
                            remarks: a("Only one of the `local_block` instances or the `default_local_block` can be executed. The `default_local_block` is introduced with the `=>` token alone and is only executed when none of the preceding blocks are executed. If the result of the `switch` statement is assigned to a variable and a `default_local_block` is not specified, the statement returns `na` if no `local_block` is executed. When assigning the result of the `switch` statement to a variable, all `local_block` instances must return the same type of value.", {
                                context: "pine_docs_remarks"
                            }),
                            seeAlso: ["{@op if}, {@op ?:}"]
                        },
                        for: {
                            desc: [a("The 'for' structure allows the repeated execution of a number of statements:", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["[var_declaration =] for counter = from_num to to_num [by step_num]<br>&ensp;&emsp;statements | continue | break<br>&ensp;&emsp;return_expression"],
                            detailedDesc: [{
                                desc: [a("{b_on}var_declaration{b_off} - An optional variable declaration that will be assigned the value of the loop's return_expression.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}counter{b_off} - A variable holding the value of the loop's counter, which is incremented/decremented by 1 or by the step_num value on each iteration of the loop.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a('{b_on}from_num{b_off} - The starting value of the counter. "series int/float" values/expressions are allowed.', {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a('{b_on}to_num{b_off} - The end value of the counter. When the counter becomes greater than to_num (or less than to_num in cases where from_num > to_num) the loop is broken. "series int/float" values/expressions are allowed, but they are evaluated only on the loop\'s first iteration.', {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}step_num{b_off} - The increment/decrement value of the counter. It is optional. The default value is +1 or -1, depending on which of from_num or to_num is the greatest. When a value is used, the counter is also incremented/decremented depending on which of from_num or to_num is the greatest, so the +/- sign of step_num is optional.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}statements | continue | break{b_off} - Any number of statements, or the 'continue' or 'break' keywords, indented by 4 spaces or a tab.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}return_expression{b_off} - The loop's return value which is assigned to the variable in var_declaration if one is present. If the loop exits because of a 'continue' or 'break' keyword, the loop's return value is that of the last variable assigned a value before the loop's exit.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}continue{b_off} - A keyword that can only be used in loops. It causes the next iteration of the loop to be executed.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}break{b_off} - A keyword that exits the loop.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                })],
                                examples: ["//@version=5", 'indicator("for")', "// Here, we count the quantity of bars in a given 'lookback' length which closed above the current bar's close", "qtyOfHigherCloses(lookback) =>", "\tint result = 0", "\tfor i = 1 to lookback", "\t\tif close[i] > close", "\t\t\tresult += 1", "\tresult", "plot(qtyOfHigherCloses(14))"]
                            }],
                            seeAlso: ["{@op for...in} {@op while}"]
                        },
                        "for...in": {
                            desc: [a("The `for...in` structure allows the repeated execution of a number of statements for each element in an array. It can be used with either one argument: `array_element`, or with two: `[index, array_element]`. The second form doesn't affect the functionality of the loop. It tracks the current iteration's index in the tuple's first variable.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["[var_declaration =] for array_element in array_id<br>&ensp;&emsp;statements | continue | break<br>&ensp;&emsp;return_expression<br><br>[var_declaration =] for [index, array_element] in array_id<br>&ensp;&emsp;statements | continue | break<br>&ensp;&emsp;return_expression"],
                            detailedDesc: [{
                                desc: [a("{b_on}var_declaration{b_off} - An optional variable declaration that will be assigned the value of the loop's `return_expression`.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}index{b_off} - An optional variable that tracks the current iteration's index. Indexing starts at 0. The variable is immutable in the loop's body. When used, it must be included in a tuple also containing `array_element`.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}array_element{b_off} - A variable containing each successive array element to be processed in the loop. The variable is immutable in the loop's body.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}array_id{b_off} - The ID of the array over which the loop is iterated.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}statements | continue | break{b_off} - Any number of statements, or the 'continue' or 'break' keywords, indented by 4 spaces or a tab.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}return_expression{b_off} - The loop's return value assigned to the variable in `var_declaration`, if one is present. If the loop exits because of a 'continue' or 'break' keyword, the loop's return value is that of the last variable assigned a value before the loop's exit.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}continue{b_off} - A keyword that can only be used in loops. It causes the next iteration of the loop to be executed.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}break{b_off} - A keyword that exits the loop.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("It is allowed to modify the array's elements or its size inside the loop.", {
                                    context: "pine_docs_desc"
                                })]
                            }, {
                                desc: [a("Here, we use the single-argument form of `for...in` to determine on each bar how many of the bar's OHLC values are greater than the SMA of 'close' values:", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("for...in")', "// Here we determine on each bar how many of the bar's OHLC values are greater than the SMA of 'close' values", "float[] ohlcValues = array.from(open, high, low, close)", "qtyGreaterThan(value, array) =>", "\tint result = 0", "\tfor currentElement in array", "\t\tif currentElement > value", "\t\t\tresult += 1", "\t\tresult", "plot(qtyGreaterThan(ta.sma(close, 20), ohlcValues))"]
                            }, {
                                desc: [a("Here, we use the two-argument form of {@op for...in} to set the values of our `isPos` array to `true` when their corresponding value in our `valuesArray` array is positive:", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("for...in")', "var valuesArray = array.from(4, -8, 11, 78, -16, 34, 7, 99, 0, 55)", "var isPos = array.new_bool(10, false)", "", "for [index, value] in valuesArray", "\tif value > 0", "\t\tarray.set(isPos, index, true)", "", "if barstate.islastconfirmedhistory", "\tlabel.new(bar_index, high, str.tostring(isPos))"]
                            }, {
                                desc: [a("Iterate through matrix rows as arrays.", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`for ... in` matrix Example")', "", "// Create a 2x3 matrix with values `4`.", "matrix1 = matrix.new&lt;int&gt;(2, 3, 4)", "", "sum = 0.0", "// Loop through every row of the matrix.", "for rowArray in matrix1", "\t// Sum values of the every row ", "\tsum += array.sum(rowArray)", "", "plot(sum)"]
                            }],
                            seeAlso: ["{@op for} {@op while} {@fun array.sum} {@fun array.min} {@fun array.max}"]
                        },
                        while: {
                            desc: [a("The `while` statement allows the conditional iteration of a local code block.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["variable_declaration = while boolean_expression<br>&ensp;&emsp;…<br>&ensp;&emsp;continue<br>&ensp;&emsp;…<br>&ensp;&emsp;break<br>&ensp;&emsp;…<br>&ensp;&emsp;return_expression"],
                            detailedDesc: [{
                                desc: [a("where:", {
                                    context: "pine_docs_desc"
                                }), a("{b_on}variable_declaration{b_off} - An optional variable declaration. The `return expression` can provide the initialization value for this variable.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}boolean_expression{b_off} - when true, the local block of the `while` statement is executed. When false, execution of the script resumes after the `while` statement.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}continue{b_off} - The `continue` keyword causes the loop to branch to its next iteration.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}break{b_off} - The `break` keyword causes the loop to terminate. The script's execution resumes after the `while` statement.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}return_expression{b_off} - An optional line providing the `while` statement's returning value.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                })],
                                examples: ["//@version=5", 'indicator("while")', "// This is a simple example of calculating a factorial using a while loop.", 'int i_n = input.int(10, "Factorial Size", minval=0)', "int counter   = i_n", "int factorial = 1", "while counter > 0", "\tfactorial := factorial * counter", "\tcounter   := counter - 1", "", "plot(factorial)"]
                            }],
                            remarks: a("The local code block after the initial `while` line must be indented with four spaces or a tab. For the `while` loop to terminate, the boolean expression following `while` must eventually become false, or a `break` must be executed.", {
                                context: "pine_docs_remarks"
                            })
                        },
                        var: {
                            desc: [a("{b_on}var{b_off} is the keyword used for assigning and one-time initializing of the variable.", {
                                context: "pine_docs_desc"
                            }).format({
                                b_on: "<b>",
                                b_off: "</b>"
                            }), a("Normally, a syntax of assignment of variables, which doesn’t include the keyword var, results in the value of the variable being overwritten with every update of the data. Contrary to that, when assigning variables with the keyword var, they can “keep the state” despite the data updating, only changing it when conditions within if-expressions are met.", {
                                context: "pine_docs_desc"
                            })],
                            syntax: ["var variable_name = expression"],
                            detailedDesc: [{
                                desc: [a("where:", {
                                    context: "pine_docs_desc"
                                }), a("{b_on}variable_name{b_off} - any name of the user’s variable that’s allowed in Pine Script™ (can contain capital and lowercase Latin characters, numbers, and underscores (_), but can’t start with a number).", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}expression{b_off} - any arithmetic expression, just as with defining a regular variable. The expression will be calculated and assigned to a variable once.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                })],
                                examples: ["//@version=5", 'indicator("Var keyword example")', "var a = close", "var b = 0.0", "var c = 0.0", "var green_bars_count = 0", "if close > open", "\tvar x = close", "\tb := x", "\tgreen_bars_count := green_bars_count + 1", "\tif green_bars_count >= 10", "\t\tvar y = close", "\t\tc := y", "plot(a)", "plot(b)", "plot(c)"]
                            }, {
                                desc: [a("The variable 'a' keeps the closing price of the first bar for each bar in the series.", {
                                    context: "pine_docs_desc"
                                }), a("The variable 'b' keeps the closing price of the first \"green\" bar in the series.", {
                                    context: "pine_docs_desc"
                                }), a("The variable 'c' keeps the closing price of the tenth \"green\" bar in the series.", {
                                    context: "pine_docs_desc"
                                })]
                            }]
                        },
                        varip: {
                            desc: [a("{b_on}varip{b_off} (var intrabar persist) is the keyword used for assigning and one-time initializing of a variable. It is similar to the var keyword, but variables declared with varip retain their values between the updates of a real-time bar.", {
                                context: "pine_docs_desc"
                            }).format({
                                b_on: "<b>",
                                b_off: "</b>"
                            })],
                            syntax: ["varip variable_name = expression"],
                            detailedDesc: [{
                                desc: [a("where:", {
                                    context: "pine_docs_desc"
                                }), a("{b_on}variable_name{b_off} - any name of the user's variable that's allowed in Pine Script™ (can contain capital and lowercase Latin characters, numbers, and underscores (_), but can't start with a number).", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }), a("{b_on}expression{b_off} - any arithmetic expression, just as when defining a regular variable. The expression will be calculated and assigned to the variable only once, on the first bar.", {
                                    context: "pine_docs_desc"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                })],
                                examples: ["//@version=5", 'indicator("varip")', "varip int v = -1", "v := v + 1", "plot(v)"]
                            }, {
                                desc: [a("With var, the plot would return the value of bar_index. With varip, the same behavior occurs on historical bars, but in the real-time bar, the plot returns a value that increases by one for each tick.", {
                                    context: "pine_docs_desc"
                                })]
                            }],
                            remarks: a("Can be used only with simple types such as float, int, bool, string, and with arrays of these types.", {
                                context: "pine_docs_remarks"
                            })
                        },
                        import: {
                            desc: [a("Used to load an external {@fun library} into a script and bind its functions to a namespace. The importing script can be an indicator, a strategy, or another library. A library must be published (privately or publicly) before it can be imported.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "username",
                                info: a("User name of the library's author.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "literal string"
                            }, {
                                name: "libraryName",
                                info: a("Name of the imported library, which corresponds to the `title` argument used by the author in his library script.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "literal string"
                            }, {
                                name: "libraryVersion",
                                info: a("Version number of the imported library.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "literal int"
                            }, {
                                name: "alias",
                                info: a("Namespace used to refer to the library's functions. Optional. The default is the libraryName string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "literal string"
                            }],
                            remarks: [a("Using an alias that replaces a built-in namespace such as math.* or strategy.* is allowed, but if the library contains function names that shadow Pine Script™'s built-in functions, the built-ins will become unavailable. The same version of a library can only be imported once. Aliases must be distinct for each imported library. When calling library functions, casting their arguments to types other than their declared type is not allowed.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("num_methods import")', '// Import the first version of the username’s "num_methods" library and assign it to the "m" namespace",', "import username/num_methods/1 as m", "// Call the “sinh()” function from the imported library", "y = m.sinh(3.14)", '// Plot value returned by the "sinh()" function",', "plot(y)"],
                            syntax: ["import {username}/{libraryName}/{libraryVersion} as {alias}"],
                            seeAlso: ["{@fun library}, {@op export}"]
                        },
                        export: {
                            desc: [a("Used in libraries to prefix the declaration of functions that will be available from other scripts importing the library.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Each library must have at least one exported function. Exported functions cannot use variables from the global scope if they are arrays, mutable variables (reassigned with `:=`), or variables of 'input' form. Exported functions cannot use request.* functions, e.g. {@fun request.security}. Exported functions must explicitly declare the type of their arguments, and all arguments must be used in the function's body. By default, all arguments of exported functions are of the {@op series} form, unless explicitly specified as {@op simple} type in the function signature. The @description, @function, @param, and @returns directives are used to automatically generate the library's release notes, and in the Pine Script™ Editor's tooltips.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", "//@description Library of debugging functions.", 'library("Debugging_library", overlay = true)', "//@function Displays a string as a table cell for debugging purposes.", "//@param txt String to display.", "//@returns Void.", "export print(string txt) => ", "\tvar table t = table.new(position.middle_right, 1, 1)", "\ttable.cell(t, 0, 0, txt, bgcolor = color.yellow)", "// Using the function from inside the library to show an example on the published chart.", "// This has no impact on scripts using the library.", 'print("Library Test")'],
                            seeAlso: ["{@fun library} {@op import} {@op simple} {@op series}"]
                        },
                        simple: {
                            desc: [a('{b_on}simple{b_off} is a keyword that can be used in a library\'s exported functions to specify the type form required for a function\'s arguments. By default, all arguments of exported functions are automatically converted into the "series" type form. In some cases, this would make arguments unusable with those of built-in functions that do not support the "series" form. For these cases, the `simple` keyword can be used instead.', {
                                context: "pine_docs_desc"
                            }).format({
                                b_on: "<b>",
                                b_off: "</b>"
                            })],
                            syntax: ["export &lt;functionName&gt;([[simple] &lt;type&gt;] &lt;arg1&gt;[ = &lt;default_value&gt;])"],
                            examples: ["//@version=5", "//@description Library of debugging functions.", 'library("Debugging_library", overlay = true)', "export emaWrong(float source, int length) =>", "\t// By default, both `source` and `length` will expect values of the `series` type form: `series float` for `source`, `series int` for `length`.", '\t// This function will not compile because `ema()` does not support a "series int" argument for `length`. A "simple int" is required.', "\tta.ema(source, length)", "", "export emaRight(float source, simple int length) =>", '\t// This function requires an argument of "simple int" type for its `length` parameter.', "\tta.ema(source, length)"]
                        },
                        series: {
                            desc: [a("{b_on}series{b_off} is a keyword that can be used in a library's exported functions to specify the type form required for a function's arguments. Explicit use of the `series` keyword is usually unnecessary because all arguments of exported functions are automatically converted to the \"series\" form by default.", {
                                context: "pine_docs_desc"
                            }).format({
                                b_on: "<b>",
                                b_off: "</b>"
                            })],
                            syntax: ["export &lt;functionName&gt;([[series] &lt;type&gt;] &lt;arg1&gt;[ = &lt;default_value&gt;])"],
                            examples: ["//@version=5", "//@description Library of debugging functions.", 'library("Debugging_library", overlay = true)', "export smaCustom(series float source, series int length) =>", "\tta.sma(source, length)"]
                        },
                        int: {
                            desc: [a('Keyword used to explicitly declare the "int" (integer) type of a variable or a parameter.', {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("int")', "int i = 14    // Same as `i = 14`", "i := na", "plot(i)"],
                            remarks: [a("Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with {@var na}. Learn more about Pine Script™ types in the User Manual page on the {html_markup_1}Type System{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html">',
                                html_markup_2: "</a>"
                            })],
                            seeAlso: ["{@op var}, {@op varip}, {@op float}, {@op bool}, {@op color}, {@op string}"]
                        },
                        float: {
                            desc: [a('Keyword used to explicitly declare the "float" (floating point) type of a variable or a parameter.', {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("float")', "float f = 3.14    // Same as `f = 3.14`", "f := na", "plot(f)"],
                            remarks: [a("Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with {@var na}. Learn more about Pine Script™ types in the User Manual page on the {html_markup_1}Type System{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html">',
                                html_markup_2: "</a>"
                            })],
                            seeAlso: ["{@op var}, {@op varip}, {@op int}, {@op bool}, {@op color}, {@op string}"]
                        },
                        bool: {
                            desc: [a('Keyword used to explicitly declare the "bool" (boolean) type of a variable or a parameter. "Bool" variables can have values {@op true}, {@op false} or {@var na}.', {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("bool")', "bool b = true    // Same as `b = true`", "b := na", "plot(b ? open : close)"],
                            remarks: [a("Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with {@var na}. Learn more about Pine Script™ types in the User Manual page on the {html_markup_1}Type System{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html">',
                                html_markup_2: "</a>"
                            })],
                            seeAlso: ["{@op var}, {@op varip}, {@op int}, {@op float}, {@op color}, {@op string}, {@op true}, {@op false}"]
                        },
                        string: {
                            desc: [a('Keyword used to explicitly declare the "string" type of a variable or a parameter.', {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("string")', 'string s = "Hello World!"    // Same as `s = "Hello world!"`', '// string s = na // same as "" ', "plot(na, title=s)"],
                            remarks: [a("Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with {@var na}. Learn more about Pine Script™ types in the User Manual page on the {html_markup_1}Type System{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html">',
                                html_markup_2: "</a>"
                            })],
                            seeAlso: ["{@op var}, {@op varip}, {@op int}, {@op float}, {@op bool}, {@fun str.tostring}, {@fun str.format}"]
                        },
                        color: {
                            desc: [a('Keyword used to explicitly declare the "color" type of a variable or a parameter.', {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("color", overlay = true)', "", "color textColor = color.green   ", "color labelColor = #FF000080  // Red color (FF0000) with 50% transparency (80 which is half of FF).", "if barstate.islastconfirmedhistory", '\tlabel.new(bar_index, high, text = "Label", color = labelColor, textcolor = textColor)', "", '// When declaring variables with color literals, built-in constants(color.green) or functions (color.new(), color.rgb()), the "color" keyword for the type can be omitted.', "c = color.rgb(0,255,0,0)", "plot(close, color = c)"],
                            remarks: [a("Color literals have the following format: #RRGGBB or #RRGGBBAA. The letter pairs represent 00 to FF hexadecimal values (0 to 255 in decimal) where RR, GG and BB pairs are the values for the color's red, green and blue components. AA is an optional value for the color's transparency (or alpha component) where 00 is invisible and FF opaque. When no AA pair is supplied, FF is used. The hexadecimal letters can be upper or lower case.", {
                                context: "pine_docs_remarks"
                            }), a("Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with {@var na}. Learn more about Pine Script™ types in the User Manual page on the {html_markup_1}Type System{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html">',
                                html_markup_2: "</a>"
                            })],
                            seeAlso: ["{@op var}, {@op varip}, {@op int}, {@op float}, {@op string}, {@fun color.rgb}, {@fun color.new}"]
                        },
                        line: {
                            desc: [a('Keyword used to explicitly declare the "line" type of a variable or a parameter. Line objects (or IDs) can be created with the {@fun line.new} function.', {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("line")', "// Empty `line1` line ID.", "var line line1 = na", '// `line` type is unnecessary because `line.new()` returns "line" type.', "var line2 = line.new(na, na, na, na)", "line3 = line.new(bar_index - 1, high, bar_index, high, extend = extend.right)"],
                            remarks: [a('Line objects are always of "series" form.', {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@op var}, {@op label}, {@op box}, {@fun line.new}"]
                        },
                        label: {
                            desc: [a('Keyword used to explicitly declare the "label" type of a variable or a parameter. Label objects (or IDs) can be created with the {@fun label.new} function.', {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("label")', "// Empty `label1` label ID.", "var label label1 = na", '// `label` type is unnecessary because `label.new()` returns "label" type.', "var label2 = label.new(na, na, na)", "if barstate.islastconfirmedhistory", '\tlabel3 = label.new(bar_index, high, text = "label3 text")'],
                            remarks: [a('Label objects are always of "series" form.', {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@op var}, {@op line}, {@op box}, {@fun label.new}"]
                        },
                        box: {
                            desc: [a('Keyword used to explicitly declare the "box" type of a variable or a parameter. Box objects (or IDs) can be created with the {@fun box.new} function.', {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("box")', "// Empty `box1` box ID.", "var box box1 = na", '// `box` type is unnecessary because `box.new()` returns a "box" type.', "var box2 = box.new(na, na, na, na)", "box3 = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)"],
                            remarks: [a('Box objects are always of "series" form.', {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@op var}, {@op line}, {@op label}, {@op table}, {@fun box.new}"]
                        },
                        table: {
                            desc: [a('Keyword used to explicitly declare the "table" type of a variable or a parameter. Table objects (or IDs) can be created with the {@fun table.new} function.', {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("table")', "// Empty `table1` table ID.", "var table table1 = na", '// `table` type is unnecessary because `table.new()` returns "table" type.', "var table2 = table.new(position.top_left, na, na)", "", "if barstate.islastconfirmedhistory", "\tvar table3 = table.new(position = position.top_right, columns = 1, rows = 1, bgcolor = color.yellow, border_width = 1)", '\ttable.cell(table_id = table3, column = 0, row = 0, text = "table3 text")'],
                            remarks: [a('Table objects are always of "series" form.', {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@op var}, {@op line}, {@op label}, {@op box}, {@fun table.new}"]
                        },
                        linefill: {
                            desc: [a('Keyword used to explicitly declare the "linefill" type of a variable or a parameter. Linefill objects (or IDs) can be created with the {@fun linefill.new} function.', {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("linefill", overlay=true)', "// Empty `linefill1` line ID.", "var linefill linefill1 = na", '// `linefill` type is unnecessary because `linefill.new()` returns "linefill" type.', "var linefill2 = linefill.new(na, na, na)", "", "if barstate.islastconfirmedhistory", "\tline1 = line.new(bar_index - 10, high+1, bar_index, high+1, extend = extend.right)", "\tline2 = line.new(bar_index - 10, low+1, bar_index, low+1, extend = extend.right)", "\tlinefill3 = linefill.new(line1, line2, color = color.new(color.green, 80))"],
                            remarks: [a('Linefill objects are always of "series" form.', {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@op var}, {@op line}, {@op label}, {@op table}, {@op box}, {@fun linefill.new}"]
                        },
                        array: {
                            desc: [a('Keyword used to explicitly declare the "array" type of a variable or a parameter. Array objects (or IDs) can be created with the {html_markup_1}{html_markup_2}, {@fun array.from} function.', {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a href="">{@fun array.new<type>}',
                                html_markup_2: "</a>"
                            })],
                            examples: ["//@version=5", 'indicator("array", overlay=true)', "array&lt;float&gt; a = na", "a := array.new&lt;float&gt;(1, close)", "plot(array.get(a, 0))"],
                            remarks: [a('Array objects are always of "series" form.', {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ['{@op var}, {@op line}, {@op label}, {@op table}, {@op box}, {html_markup_start}<a href="">{@fun array.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun array.from}']
                        },
                        matrix: {
                            desc: [a('Keyword used to explicitly declare the "matrix" type of a variable or a parameter. Matrix objects (or IDs) can be created with the {html_markup_1}{html_markup_2} function.', {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a href="">{@fun matrix.new<type>}',
                                html_markup_2: "</a>"
                            })],
                            examples: ["//@version=5", 'indicator("matrix example")', "", "// Create `m1` matrix of `int` type.", "matrix&lt;int&gt; m1 = matrix.new&lt;int&gt;(2, 3, 0)", "", "// `matrix&lt;int&gt;` is unnecessary because the `matrix.new&lt;int&gt;()` function returns an `int` type matrix object.", "m2 = matrix.new&lt;int&gt;(2, 3, 0)", "", "// Display matrix using a label.", "if barstate.islastconfirmedhistory", "\tlabel.new(bar_index, high, str.tostring(m2))"],
                            remarks: [a('Matrix objects are always of "series" form.', {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ['{@op var}, {html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@op array}']
                        },
                        true: {
                            desc: [a("Literal representing one of the values a {@op bool} variable can hold, or an expression can evaluate to when it uses comparison or logical operators.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("See the User Manual for {html_markup_1}comparison operators{html_markup_2} and {html_markup_3}logical operators{html_markup_4}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Operators.html#comparison-operators">',
                                html_markup_2: "</a>",
                                html_markup_3: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Operators.html#logical-operators">',
                                html_markup_4: "</a>"
                            })],
                            seeAlso: ["{@op bool}"]
                        },
                        false: {
                            desc: [a("Literal representing a {@op bool} value, and result of a comparison operation.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("See the User Manual for {html_markup_1}comparison operators{html_markup_2} and {html_markup_3}logical operators{html_markup_4}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Operators.html#comparison-operators">',
                                html_markup_2: "</a>",
                                html_markup_3: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Operators.html#logical-operators">',
                                html_markup_4: "</a>"
                            })],
                            seeAlso: ["{@op bool}"]
                        }
                    }
                },
                variables: {
                    title: a("Built-in Variables"),
                    prefix: "var_",
                    docs: {
                        "session.isfirstbar": {
                            name: "session.isfirstbar",
                            type: "series bool",
                            kind: "FUN_KIND_DECL",
                            desc: [a("Returns {@op true} if the current bar is the first bar of the day's session, `false` otherwise. If extended session information is used, only returns {@op true} on the first bar of the pre-market bars.", {
                                context: "pine_docs_desc"
                            })]
                        },
                        "session.islastbar": {
                            name: "session.islastbar",
                            type: "series bool",
                            kind: "FUN_KIND_DECL",
                            desc: [a("Returns {@op true} if the current bar is the last bar of the day's session, `false` otherwise. If extended session information is used, only returns {@op true} on the last bar of the post-market bars.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("This variable is not guaranteed to return {@op true} once in every session because the last bar of the session might not exist if no trades occur during what should be the session's last bar.", {
                                context: "pine_docs_remarks"
                            }), a("This variable is not guaranteed to work as expected on non-standard chart types, e.g., Renko.", {
                                context: "pine_docs_remarks"
                            })]
                        },
                        "session.isfirstbar_regular": {
                            name: "session.isfirstbar_regular",
                            type: "series bool",
                            kind: "FUN_KIND_DECL",
                            desc: [a("Returns {@op true} on the first regular session bar of the day, `false` otherwise. The result is the same whether extended session information is used or not.", {
                                context: "pine_docs_desc"
                            })]
                        },
                        "session.islastbar_regular": {
                            name: "session.islastbar_regular",
                            type: "series bool",
                            kind: "FUN_KIND_DECL",
                            desc: [a("Returns {@op true} on the last regular session bar of the day, `false` otherwise. The result is the same whether extended session information is used or not.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("This variable is not guaranteed to return {@op true} once in every session because the last bar of the session might not exist if no trades occur during what should be the session's last bar.", {
                                context: "pine_docs_remarks"
                            }), a("This variable is not guaranteed to work as expected on non-standard chart types, e.g., Renko.", {
                                context: "pine_docs_remarks"
                            })]
                        },
                        bar_index: {
                            name: "bar_index",
                            type: "series int",
                            desc: [a("Current bar index. Numbering is zero-based, index of the first bar is 0.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Note that {b_on}bar_index{b_off} has replaced {b_on}n{b_off} variable in version 4.", {
                                context: "pine_docs_remarks"
                            }).format({
                                b_on: "<b>",
                                b_off: "</b>"
                            }), a("Note that bar indexing starts from 0 on the first historical bar.", {
                                context: "pine_docs_remarks"
                            }), a("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            })],
                            examples: ["//@version=5", 'indicator("bar_index")', "plot(bar_index)", "plot(bar_index > 5000 ? close : 0)"],
                            seeAlso: ["{@var last_bar_index}, {@var barstate.isfirst}, {@var barstate.islast}, {@var barstate.isrealtime}"]
                        },
                        last_bar_index: {
                            name: "last_bar_index",
                            type: "series int",
                            desc: [a("Bar index of the last chart bar. Bar indices begin at zero on the first bar.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Last historical bar index for closed markets, or the real-time bar index for open markets.", {
                                context: "pine_docs_returns"
                            })],
                            remarks: [a("Please note that using this variable can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            })],
                            examples: ["//@version=5", 'strategy("Mark Last X Bars For Backtesting", overlay = true, calc_on_every_tick = true)', 'lastBarsFilterInput = input.int(100, "Bars Count:")', "// Here, we store the 'last_bar_index' value that is known from the beginning of the script's calculation.", "// The 'last_bar_index' will change when new real-time bars appear, so we declare 'lastbar' with the 'var' keyword.", "var lastbar = last_bar_index", "// Check if the current bar_index is 'lastBarsFilterInput' removed from the last bar on the chart, or the chart is traded in real-time.", "allowedToTrade = (lastbar - bar_index <= lastBarsFilterInput) or barstate.isrealtime", "bgcolor(allowedToTrade ? color.new(color.green, 80) : na)"],
                            seeAlso: ["{@var bar_index}, {@var last_bar_time}, {@var barstate.ishistory}, {@var barstate.isrealtime}"]
                        },
                        last_bar_time: {
                            name: "last_bar_time",
                            type: "series int",
                            desc: [a("Time in UNIX format of the last chart bar. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            }), a("Note that this variable returns the timestamp based on the time of the bar's open.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var time}, {@var timenow}, {@fun timestamp}, {@var last_bar_index}"]
                        },
                        na: {
                            name: "na",
                            type: "simple na",
                            desc: [a('A keyword signifying "not available", indicating that a variable has no assigned value.', {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("")', "// CORRECT", "// Plot no value when on bars zero to nine. Plot `close` on other bars.", "plot(bar_index < 10 ? na : close)", "// CORRECT ALTERNATIVE", "// Initialize `a` to `na`. Reassign `close` to `a` on bars 10 and later.", "float a = na", "if bar_index >= 10", "\ta := close", "plot(a)", "", "// INCORRECT", "// Trying to test the preceding bar's `close` for `na`.", "// Will not work correctly on bar zero, when `close[1]` is `na`.", "plot(close[1] == na ? close : close[1])", "// CORRECT", "// Use the `na()` function to test for `na`.", "plot(na(close[1]) ? close : close[1])", "// CORRECT ALTERNATIVE", "// `nz()` tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.", "plot(nz(close[1], close))"],
                            remarks: [a("Do not use this variable with {html_markup_1}comparison operators{html_markup_2} to test values for `na`, as it might lead to unexpected behavior. Instead, use the {@fun na} function. Note that `na` can be used to initialize variables when the initialization statement also specifies the variable's type.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Operators.html#comparison-operators">',
                                html_markup_2: "</a>"
                            })],
                            seeAlso: ["{@fun na}", "{@fun nz}, {@fun fixnan}"]
                        },
                        volume: {
                            name: "volume",
                            type: "series float",
                            desc: [a("Current bar volume.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Previous values may be accessed with square brackets operator [], e.g. volume[1], volume[2].", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var open}, {@var high}, {@var low}, {@var close}, {@fun time}, {@var hl2}, {@var hlc3}, {@var hlcc4}, {@var ohlc4}"]
                        },
                        "math.pi": {
                            name: "math.pi",
                            type: "const float",
                            desc: [a("Is a named constant for {html_markup_1}Archimedes' constant{html_markup_2}. It is equal to 3.1415926535897932.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Pi" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            seeAlso: ["{@var math.e}, {@var math.phi}, {@var math.rphi}"]
                        },
                        "math.phi": {
                            name: "math.phi",
                            type: "const float",
                            desc: [a("Is a named constant for the {html_markup_1}golden ratio{html_markup_2}. It is equal to 1.6180339887498948.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Golden_ratio" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            seeAlso: ["{@var math.e}, {@var math.pi}, {@var math.rphi}"]
                        },
                        "math.rphi": {
                            name: "math.rphi",
                            type: "const float",
                            desc: [a("Is a named constant for the {html_markup_1}golden ratio conjugate{html_markup_2}. It is equal to 0.6180339887498948.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Golden_ratio#Golden_ratio_conjugate" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            seeAlso: ["{@var math.e}, {@var math.pi}, {@var math.phi}"]
                        },
                        "math.e": {
                            name: "math.e",
                            type: "const float",
                            desc: [a("Is a named constant for {html_markup_1}Euler's number{html_markup_2}. It is equal to 2.7182818284590452.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/E_(mathematical_constant)" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            seeAlso: ["{@var math.phi}, {@var math.pi}, {@var math.rphi}"]
                        },
                        open: {
                            name: "open",
                            type: "series float",
                            desc: [a("Current open price.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Previous values may be accessed with square brackets operator [], e.g. open[1], open[2].", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var high}, {@var low}, {@var close}, {@var volume}, {@fun time}, {@var hl2}, {@var hlc3}, {@var hlcc4}, {@var ohlc4}"]
                        },
                        high: {
                            name: "high",
                            type: "series float",
                            desc: [a("Current high price.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Previous values may be accessed with square brackets operator [], e.g. high[1], high[2].", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var open}, {@var low}, {@var close}, {@var volume}, {@fun time}, {@var hl2}, {@var hlc3}, {@var hlcc4}, {@var ohlc4}"]
                        },
                        low: {
                            name: "low",
                            type: "series float",
                            desc: [a("Current low price.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Previous values may be accessed with square brackets operator [], e.g. low[1], low[2].", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var open}, {@var high}, {@var close}, {@var volume}, {@fun time}, {@var hl2}, {@var hlc3}, {@var hlcc4}, {@var ohlc4}"]
                        },
                        close: {
                            name: "close",
                            type: "series float",
                            desc: [a("Close price of the current bar when it has closed, or last traded price of a yet incomplete, realtime bar.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Previous values may be accessed with square brackets operator [], e.g. close[1], close[2].", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var open}, {@var high}, {@var low}, {@var volume}, {@fun time}, {@var hl2}, {@var hlc3}, {@var hlcc4}, {@var ohlc4}"]
                        },
                        hl2: {
                            name: "hl2",
                            type: "series float",
                            desc: [a("Is a shortcut for (high + low)/2", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var open}, {@var high}, {@var low}, {@var close}, {@var volume}, {@fun time}, {@var hlc3}, {@var hlcc4}, {@var ohlc4}"]
                        },
                        hlc3: {
                            name: "hlc3",
                            type: "series float",
                            desc: [a("Is a shortcut for (high + low + close)/3", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var open}, {@var high}, {@var low}, {@var close}, {@var volume}, {@fun time}, {@var hl2}, {@var hlcc4}, {@var ohlc4}"]
                        },
                        hlcc4: {
                            name: "hlcc4",
                            type: "series float",
                            desc: [a("Is a shortcut for (high + low + close + close)/4", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var open}, {@var high}, {@var low}, {@var close}, {@var volume}, {@fun time}, {@var hl2}, {@var hlc3}, {@var ohlc4}"]
                        },
                        ohlc4: {
                            name: "ohlc4",
                            type: "series float",
                            desc: [a("Is a shortcut for (open + high + low + close)/4", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var open}, {@var high}, {@var low}, {@var close}, {@var volume}, {@fun time}, {@var hl2}, {@var hlc3}, {@var hlcc4}"]
                        },
                        "ta.vwap": {
                            name: "ta.vwap",
                            type: "series float",
                            desc: [a("Volume Weighted Average Price. It uses {@var hlc3} as its source series.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun ta.vwap} (function)"]
                        },
                        "ta.accdist": {
                            name: "ta.accdist",
                            type: "series float",
                            desc: [a("Accumulation/distribution index.", {
                                context: "pine_docs_desc"
                            })]
                        },
                        "ta.tr": {
                            name: "ta.tr",
                            type: "series float",
                            desc: [a("True range. Same as tr(false). It is max(high - low, abs(high - close[1]), abs(low - close[1]))", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun ta.tr}, {@fun ta.atr}"]
                        },
                        "ta.iii": {
                            name: "ta.iii",
                            type: "series float",
                            desc: [a("Intraday Intensity Index.", {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("Intraday Intensity Index")', "plot(ta.iii, color=color.yellow)", "", "// the same on pine", "f_iii() =>", "    (2 * close - high - low) / ((high - low) * volume)", "", "plot(f_iii())"]
                        },
                        "ta.wvad": {
                            name: "ta.wvad",
                            type: "series float",
                            desc: [a("Williams Variable Accumulation/Distribution.", {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("Williams Variable Accumulation/Distribution")', "plot(ta.wvad, color=color.yellow)", "", "// the same on pine", "f_wvad() =>", "    (close - open) / (high - low) * volume", "", "plot(f_wvad())"]
                        },
                        "ta.wad": {
                            name: "ta.wad",
                            type: "series float",
                            desc: [a("Williams Accumulation/Distribution.", {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("Williams Accumulation/Distribution")', "plot(ta.wad, color=color.yellow)", "", "// the same on pine", "f_wad() =>", "    trueHigh = math.max(high, close[1])", "    trueLow = math.min(low, close[1])", "    mom = ta.change(close)", "    gain = (mom > 0) ? close - trueLow : (mom < 0) ? close - trueHigh : 0", "    ta.cum(gain)", "", "plot(f_wad())"]
                        },
                        "ta.obv": {
                            name: "ta.obv",
                            type: "series float",
                            desc: [a("On Balance Volume.", {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("On Balance Volume")', "plot(ta.obv, color=color.yellow)", "", "// the same on pine", "f_obv() =>", "    ta.cum(math.sign(ta.change(close)) * volume)", "", "plot(f_obv())"]
                        },
                        "ta.pvt": {
                            name: "ta.pvt",
                            type: "series float",
                            desc: [a("Price-Volume Trend.", {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("Price-Volume Trend")', "plot(ta.pvt, color=color.yellow)", "", "// the same on pine", "f_pvt() =>", "    ta.cum((ta.change(close) / close[1]) * volume)", "", "plot(f_pvt())"]
                        },
                        "ta.nvi": {
                            name: "ta.nvi",
                            type: "series float",
                            desc: [a("Negative Volume Index.", {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("Negative Volume Index")', "", "plot(ta.nvi, color=color.yellow)", "", "// the same on pine", "f_nvi() =>", "    float ta_nvi = 1.0", "    float prevNvi = (nz(ta_nvi[1], 0.0) == 0.0)  ? 1.0: ta_nvi[1]", "    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0", "        ta_nvi := prevNvi", "    else", "        ta_nvi := (volume < nz(volume[1], 0.0)) ? prevNvi + ((close - close[1]) / close[1]) * prevNvi : prevNvi", "    result = ta_nvi", "", "plot(f_nvi())"]
                        },
                        "ta.pvi": {
                            name: "ta.pvi",
                            type: "series float",
                            desc: [a("Positive Volume Index.", {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'indicator("Positive Volume Index")', "", "plot(ta.pvi, color=color.yellow)", "", "// the same on pine", "f_pvi() =>", "    float ta_pvi = 1.0", "    float prevPvi = (nz(ta_pvi[1], 0.0) == 0.0)  ? 1.0: ta_pvi[1]", "    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0", "        ta_pvi := prevPvi", "    else", "        ta_pvi := (volume > nz(volume[1], 0.0)) ? prevPvi + ((close - close[1]) / close[1]) * prevPvi : prevPvi", "    result = ta_pvi", "", "plot(f_pvi())"]
                        },
                        "syminfo.ticker": {
                            name: "syminfo.ticker",
                            type: "simple string",
                            desc: [a("Symbol name without exchange prefix, e.g. 'MSFT'.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var syminfo.tickerid}, {@var timeframe.period}, {@var timeframe.multiplier}, {@var syminfo.root}"]
                        },
                        "syminfo.tickerid": {
                            name: "syminfo.tickerid",
                            type: "simple string",
                            desc: [a("Symbol name with exchange prefix, e.g. 'BATS:MSFT', 'NASDAQ:MSFT'.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun ticker.new} (function), {@var syminfo.ticker}, {@var timeframe.period}, {@var timeframe.multiplier}, {@var syminfo.root}"]
                        },
                        "timeframe.period": {
                            name: "timeframe.period",
                            type: "simple string",
                            desc: [a("Resolution, e.g. '60' - 60 minutes, 'D' - daily, 'W' - weekly, 'M' - monthly, '5D' - 5 days, '12M' - one year, '3M' - one quarter.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var syminfo.ticker}, {@var syminfo.tickerid}, {@var timeframe.multiplier}"]
                        },
                        "syminfo.root": {
                            name: "syminfo.root",
                            type: "simple string",
                            desc: [a("Root for derivatives like futures contract. For other symbols returns the same value as {@var syminfo.ticker}.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var syminfo.ticker}, {@var syminfo.tickerid}"],
                            examples: ["//@version=5", 'indicator("syminfo.root")', "", "// If the current chart symbol is continuous futures ('ES1!'), it would display 'ES'.", "if barstate.islastconfirmedhistory", "\tlabel.new(bar_index, high, syminfo.root)"]
                        },
                        "syminfo.prefix": {
                            name: "syminfo.prefix",
                            type: "simple string",
                            desc: [a("Prefix of current symbol name (i.e. for 'CME_EOD:TICKER' prefix is 'CME_EOD').", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var syminfo.ticker}, {@var syminfo.tickerid}"],
                            examples: ["//@version=5", 'indicator("syminfo.prefix")', "", "// If current chart symbol is 'BATS:MSFT' then syminfo.prefix is 'BATS'.", "if barstate.islastconfirmedhistory", "\tlabel.new(bar_index, high, text=syminfo.prefix)"]
                        },
                        "syminfo.mintick": {
                            name: "syminfo.mintick",
                            type: "simple float",
                            desc: [a("Min tick value for the current symbol.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var syminfo.pointvalue}"]
                        },
                        "syminfo.pointvalue": {
                            name: "syminfo.pointvalue",
                            type: "simple float",
                            desc: [a("Point value for the current symbol.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var syminfo.mintick}"]
                        },
                        "syminfo.session": {
                            name: "syminfo.session",
                            type: "simple string",
                            desc: [a("Session type of the chart main series. Possible values are {@var session.regular}, {@var session.extended}.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var session.regular}, {@var session.extended}."]
                        },
                        "syminfo.timezone": {
                            name: "syminfo.timezone",
                            type: "simple string",
                            desc: [a("Timezone of the exchange of the chart main series. Possible values see in {@fun timestamp}.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun timestamp}"]
                        },
                        "syminfo.description": {
                            name: "syminfo.description",
                            type: "simple string",
                            desc: [a("Description for the current symbol.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var syminfo.ticker}, {@var syminfo.prefix}"]
                        },
                        "syminfo.currency": {
                            name: "syminfo.currency",
                            type: "simple string",
                            desc: [a("Currency for the current symbol. Returns currency code: 'USD', 'EUR', etc.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var syminfo.basecurrency}, {@var syminfo.ticker}, {@var currency.USD}, {@var currency.EUR}"]
                        },
                        "syminfo.basecurrency": {
                            name: "syminfo.basecurrency",
                            type: "simple string",
                            desc: [a("Base currency for the symbol. For the symbol 'BTCUSD' returns 'BTC'.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var syminfo.currency}, {@var syminfo.ticker}"]
                        },
                        "syminfo.type": {
                            name: "syminfo.type",
                            type: "simple string",
                            desc: [a("Type of the current symbol. Possible values are stock, futures, index, forex, crypto, fund, dr.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var syminfo.ticker}"]
                        },
                        "syminfo.volumetype": {
                            name: "syminfo.volumetype",
                            type: "simple string",
                            desc: [a("Volume type of the current symbol. Possible values are:", {
                                context: "pine_docs_desc"
                            }), a('&ensp;"base" - base currency.', {
                                context: "pine_docs_desc"
                            }), a('&ensp;"quote" - currency.', {
                                context: "pine_docs_desc"
                            }), a('&ensp;"tick" - the number of transactions.', {
                                context: "pine_docs_desc"
                            }), a('&ensp;"n/a" - no volume or type is not specified.', {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Only some data feed suppliers provide information qualifying volume. As a result, the variable will return a value on some symbols only, mostly in the crypto sector.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var syminfo.type}"]
                        },
                        "session.regular": {
                            name: "session.regular",
                            type: "const string",
                            desc: [a("Constant for regular session type (no extended hours data).", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var session.extended}, {@var syminfo.session}"]
                        },
                        "session.extended": {
                            name: "session.extended",
                            type: "const string",
                            desc: [a("Constant for extended session type (with extended hours data).", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var session.regular}, {@var syminfo.session}"]
                        },
                        "adjustment.none": {
                            name: "adjustment.none",
                            type: "const string",
                            desc: [a("Constant for none adjustment type (no adjustment is applied).", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var adjustment.splits}, {@var adjustment.dividends}, {@fun ticker.new}"]
                        },
                        "adjustment.splits": {
                            name: "adjustment.splits",
                            type: "const string",
                            desc: [a("Constant for splits adjustment type (splits adjustment is applied).", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var adjustment.none}, {@var adjustment.dividends}, {@fun ticker.new}"]
                        },
                        "adjustment.dividends": {
                            name: "adjustment.dividends",
                            type: "const string",
                            desc: [a("Constant for dividends adjustment type (dividends adjustment is applied).", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var adjustment.none}, {@var adjustment.splits}, {@fun ticker.new}"]
                        },
                        "timeframe.multiplier": {
                            name: "timeframe.multiplier",
                            type: "simple int",
                            desc: [a("Multiplier of resolution, e.g. '60' - 60, 'D' - 1, '5D' - 5, '12M' - 12.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var syminfo.ticker}, {@var syminfo.tickerid}, {@var timeframe.period}"]
                        },
                        "timeframe.isdwm": {
                            name: "timeframe.isdwm",
                            type: "simple bool",
                            desc: [a("Returns true if current resolution is a daily or weekly or monthly resolution, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var timeframe.isintraday}, {@var timeframe.isminutes}, {@var timeframe.isseconds}, {@var timeframe.isdaily}, {@var timeframe.isweekly}, {@var timeframe.ismonthly}"]
                        },
                        "timeframe.isintraday": {
                            name: "timeframe.isintraday",
                            type: "simple bool",
                            desc: [a("Returns true if current resolution is an intraday (minutes or seconds) resolution, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var timeframe.isminutes}, {@var timeframe.isseconds}, {@var timeframe.isdwm}, {@var timeframe.isdaily}, {@var timeframe.isweekly}, {@var timeframe.ismonthly}"]
                        },
                        "timeframe.isdaily": {
                            name: "timeframe.isdaily",
                            type: "simple bool",
                            desc: [a("Returns true if current resolution is a daily resolution, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var timeframe.isdwm}, {@var timeframe.isintraday}, {@var timeframe.isminutes}, {@var timeframe.isseconds}, {@var timeframe.isweekly}, {@var timeframe.ismonthly}"]
                        },
                        "timeframe.isweekly": {
                            name: "timeframe.isweekly",
                            type: "simple bool",
                            desc: [a("Returns true if current resolution is a weekly resolution, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var timeframe.isdwm}, {@var timeframe.isintraday}, {@var timeframe.isminutes}, {@var timeframe.isseconds}, {@var timeframe.isdaily}, {@var timeframe.ismonthly}"]
                        },
                        "timeframe.ismonthly": {
                            name: "timeframe.ismonthly",
                            type: "simple bool",
                            desc: [a("Returns true if current resolution is a monthly resolution, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var timeframe.isdwm}, {@var timeframe.isintraday}, {@var timeframe.isminutes}, {@var timeframe.isseconds}, {@var timeframe.isdaily}, {@var timeframe.isweekly}"]
                        },
                        "timeframe.isminutes": {
                            name: "timeframe.isminutes",
                            type: "simple bool",
                            desc: [a("Returns true if current resolution is a minutes resolution, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var timeframe.isdwm}, {@var timeframe.isintraday}, {@var timeframe.isseconds}, {@var timeframe.isdaily}, {@var timeframe.isweekly}, {@var timeframe.ismonthly}"]
                        },
                        "timeframe.isseconds": {
                            name: "timeframe.isseconds",
                            type: "simple bool",
                            desc: [a("Returns true if current resolution is a seconds resolution, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var timeframe.isdwm}, {@var timeframe.isintraday}, {@var timeframe.isminutes}, {@var timeframe.isdaily}, {@var timeframe.isweekly}, {@var timeframe.ismonthly}"]
                        },
                        "hline.style_solid": {
                            name: "hline.style_solid",
                            type: "hline_style",
                            desc: [a("Is a named constant for solid linestyle of {@fun hline} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var hline.style_dotted}, {@var hline.style_dashed}"]
                        },
                        "hline.style_dotted": {
                            name: "hline.style_dotted",
                            type: "hline_style",
                            desc: [a("Is a named constant for dotted linestyle of {@fun hline} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var hline.style_solid}, {@var hline.style_dashed}"]
                        },
                        "hline.style_dashed": {
                            name: "hline.style_dashed",
                            type: "hline_style",
                            desc: [a("Is a named constant for dashed linestyle of {@fun hline} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var hline.style_solid}, {@var hline.style_dotted}"]
                        },
                        "position.top_left": {
                            name: "position.top_left",
                            type: "const string",
                            desc: [a("Table position is used in {@fun table.new}, {@fun table.cell} functions.", {
                                context: "pine_docs_desc"
                            }), a("Binds the table to the upper-left edge.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center},\t{@var position.bottom_right}"]
                        },
                        "position.top_center": {
                            name: "position.top_center",
                            type: "const string",
                            desc: [a("Table position is used in {@fun table.new}, {@fun table.cell} functions.", {
                                context: "pine_docs_desc"
                            }), a("Binds the table to the top edge in the center.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center},\t{@var position.bottom_right}"]
                        },
                        "position.top_right": {
                            name: "position.top_right",
                            type: "const string",
                            desc: [a("Table position is used in {@fun table.new}, {@fun table.cell} functions.", {
                                context: "pine_docs_desc"
                            }), a("Binds the table to the upper-right edge.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center},\t{@var position.bottom_right}"]
                        },
                        "position.middle_left": {
                            name: "position.middle_left",
                            type: "const string",
                            desc: [a("Table position is used in {@fun table.new}, {@fun table.cell} functions.", {
                                context: "pine_docs_desc"
                            }), a("Binds the table to the left side of the screen.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center},\t{@var position.bottom_right}"]
                        },
                        "position.middle_center": {
                            name: "position.middle_center",
                            type: "const string",
                            desc: [a("Table position is used in {@fun table.new}, {@fun table.cell} functions.", {
                                context: "pine_docs_desc"
                            }), a("Binds the table to the center of the screen.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center},\t{@var position.bottom_right}"]
                        },
                        "position.middle_right": {
                            name: "position.middle_right",
                            type: "const string",
                            desc: [a("Table position is used in {@fun table.new}, {@fun table.cell} functions.", {
                                context: "pine_docs_desc"
                            }), a("Binds the table to the right side of the screen.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.bottom_left}, {@var position.bottom_center},\t{@var position.bottom_right}"]
                        },
                        "position.bottom_left": {
                            name: "position.bottom_left",
                            type: "const string",
                            desc: [a("Table position is used in {@fun table.new}, {@fun table.cell} functions.", {
                                context: "pine_docs_desc"
                            }), a("Binds the table to the bottom left of the screen.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_center},\t{@var position.bottom_right}"]
                        },
                        "position.bottom_center": {
                            name: "position.bottom_center",
                            type: "const string",
                            desc: [a("Table position is used in {@fun table.new}, {@fun table.cell} functions.", {
                                context: "pine_docs_desc"
                            }), a("Binds the table to the bottom edge in the center.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left},\t{@var position.bottom_right}"]
                        },
                        "position.bottom_right": {
                            name: "position.bottom_right",
                            type: "const string",
                            desc: [a("Table position is used in {@fun table.new}, {@fun table.cell} functions.", {
                                context: "pine_docs_desc"
                            }), a("Binds the table to the bottom right of the screen.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center}"]
                        },
                        "size.auto": {
                            name: "size.auto",
                            type: "const string",
                            desc: [a("Size value for {@fun plotshape}, {@fun plotchar} functions. The size of the shape automatically adapts to the size of the bars.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}, {@fun plotchar}, {@fun label.set_size}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}"]
                        },
                        "size.tiny": {
                            name: "size.tiny",
                            type: "const string",
                            desc: [a("Size value for {@fun plotshape}, {@fun plotchar} functions. The size of the shape constantly tiny.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}, {@fun plotchar}, {@fun label.set_size}, {@var size.auto}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}"]
                        },
                        "size.small": {
                            name: "size.small",
                            type: "const string",
                            desc: [a("Size value for {@fun plotshape}, {@fun plotchar} functions. The size of the shape constantly small.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}, {@fun plotchar}, {@fun label.set_size}, {@var size.auto}, {@var size.tiny}, {@var size.normal}, {@var size.large}, {@var size.huge}"]
                        },
                        "size.normal": {
                            name: "size.normal",
                            type: "const string",
                            desc: [a("Size value for {@fun plotshape}, {@fun plotchar} functions. The size of the shape constantly normal.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}, {@fun plotchar}, {@fun label.set_size}, {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.large}, {@var size.huge}"]
                        },
                        "size.large": {
                            name: "size.large",
                            type: "const string",
                            desc: [a("Size value for {@fun plotshape}, {@fun plotchar} functions. The size of the shape constantly large.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}, {@fun plotchar}, {@fun label.set_size}, {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.huge}"]
                        },
                        "size.huge": {
                            name: "size.huge",
                            type: "const string",
                            desc: [a("Size value for {@fun plotshape}, {@fun plotchar} functions. The size of the shape constantly huge.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}, {@fun plotchar}, {@fun label.set_size}, {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}"]
                        },
                        "plot.style_line": {
                            name: "plot.style_line",
                            type: "plot_style",
                            desc: [a("A named constant for the 'Line' style, to be used as an argument for the `style` parameter in the {@fun plot} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_stepline_diamond}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_columns}, {@var plot.style_circles}"]
                        },
                        "plot.style_linebr": {
                            name: "plot.style_linebr",
                            type: "plot_style",
                            desc: [a("A named constant for the 'Line With Breaks' style, to be used as an argument for the `style` parameter in the {@fun plot} function. Similar to {@var plot.style_line}, except the gaps in the data are not filled.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@var plot.style_line}, {@var plot.style_stepline}, {@var plot.style_stepline_diamond}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_columns}, {@var plot.style_circles}"]
                        },
                        "plot.style_stepline": {
                            name: "plot.style_stepline",
                            type: "plot_style",
                            desc: [a("A named constant for the 'Step Line' style, to be used as an argument for the `style` parameter in the {@fun plot} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@var plot.style_stepline_diamond}, {@var plot.style_linebr}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_columns}, {@var plot.style_circles}"]
                        },
                        "plot.style_stepline_diamond": {
                            name: "plot.style_stepline_diamond",
                            type: "plot_style",
                            desc: [a("A named constant for the 'Step Line With Diamonds' style, to be used as an argument for the `style` parameter in the {@fun plot} function. Similar to {@var plot.style_stepline}, except the data changes are also marked with the Diamond shapes.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_columns}, {@var plot.style_circles}"]
                        },
                        "plot.style_histogram": {
                            name: "plot.style_histogram",
                            type: "plot_style",
                            desc: [a("A named constant for the 'Histogram' style, to be used as an argument for the `style` parameter in the {@fun plot} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_stepline_diamond}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_columns}, {@var plot.style_circles}"]
                        },
                        "plot.style_cross": {
                            name: "plot.style_cross",
                            type: "plot_style",
                            desc: [a("A named constant for the 'Cross' style, to be used as an argument for the `style` parameter in the {@fun plot} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_stepline_diamond}, {@var plot.style_histogram}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_columns}, {@var plot.style_circles}"]
                        },
                        "plot.style_area": {
                            name: "plot.style_area",
                            type: "plot_style",
                            desc: [a("A named constant for the 'Area' style, to be used as an argument for the `style` parameter in the {@fun plot} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_stepline_diamond}, {@var plot.style_histogram}, {@var plot.style_areabr}, {@var plot.style_cross}, {@var plot.style_columns}, {@var plot.style_circles}"]
                        },
                        "plot.style_areabr": {
                            name: "plot.style_areabr",
                            type: "plot_style",
                            desc: [a("A named constant for the 'Area With Breaks' style, to be used as an argument for the `style` parameter in the {@fun plot} function. Similar to {@var plot.style_area}, except the gaps in the data are not filled.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_stepline_diamond}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_columns}, {@var plot.style_circles}"]
                        },
                        "plot.style_columns": {
                            name: "plot.style_columns",
                            type: "plot_style",
                            desc: [a("A named constant for the 'Columns' style, to be used as an argument for the `style` parameter in the {@fun plot} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_stepline_diamond}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_circles}"]
                        },
                        "plot.style_circles": {
                            name: "plot.style_circles",
                            type: "plot_style",
                            desc: [a("A named constant for the 'Circles' style, to be used as an argument for the `style` parameter in the {@fun plot} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_stepline_diamond}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_columns}"]
                        },
                        "format.inherit": {
                            name: "format.inherit",
                            type: "const string",
                            desc: [a("Is a named constant for selecting the formatting of the script output values from the parent series in the {@fun indicator} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun indicator}, {@var format.price}, {@var format.volume}"]
                        },
                        "format.price": {
                            name: "format.price",
                            type: "const string",
                            desc: [a("Is a named constant for selecting the formatting of the script output values as prices in the {@fun indicator} function.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("If format is format.price, default precision value is set. You can use the precision argument of indicator function to change the precision value.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun indicator}, {@var format.inherit}, {@var format.volume}"]
                        },
                        "format.volume": {
                            name: "format.volume",
                            type: "const string",
                            desc: [a("Is a named constant for selecting the formatting of the script output values as volume in the {@fun indicator} function, e.g. '5183' will be formatted as '5.183K'.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun indicator}, {@var format.inherit}, {@var format.price}"]
                        },
                        "format.percent": {
                            name: "format.percent",
                            type: "const string",
                            desc: [a("Is a named constant for selecting the formatting of the script output values as a percentage in the indicator function. It adds a percent sign after values.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("The default precision is 2, regardless of the precision of the chart itself. This can be changed with the 'precision' argument of the {@fun indicator} function.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun indicator}, {@var format.inherit}, {@var format.price}, {@var format.volume}"]
                        },
                        "format.mintick": {
                            name: "format.mintick",
                            type: "const string",
                            desc: [a("Is a named constant to use with the {@fun str.tostring} function. Passing a number to {@fun str.tostring} with this argument rounds the number to the nearest value that can be divided by {@var syminfo.mintick}, without the remainder, with ties rounding up, and returns the string version of said value with trailing zeroes.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun indicator}, {@var format.inherit}, {@var format.price}, {@var format.volume}"]
                        },
                        "dayofweek.sunday": {
                            name: "dayofweek.sunday",
                            type: "const int",
                            desc: [a("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var dayofweek.monday}, {@var dayofweek.tuesday}, {@var dayofweek.wednesday}, {@var dayofweek.thursday}, {@var dayofweek.friday}, {@var dayofweek.saturday}"]
                        },
                        "dayofweek.monday": {
                            name: "dayofweek.monday",
                            type: "const int",
                            desc: [a("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var dayofweek.sunday}, {@var dayofweek.tuesday}, {@var dayofweek.wednesday}, {@var dayofweek.thursday}, {@var dayofweek.friday}, {@var dayofweek.saturday}"]
                        },
                        "dayofweek.tuesday": {
                            name: "dayofweek.tuesday",
                            type: "const int",
                            desc: [a("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var dayofweek.sunday}, {@var dayofweek.monday}, {@var dayofweek.wednesday}, {@var dayofweek.thursday}, {@var dayofweek.friday}, {@var dayofweek.saturday}"]
                        },
                        "dayofweek.wednesday": {
                            name: "dayofweek.wednesday",
                            type: "const int",
                            desc: [a("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var dayofweek.sunday}, {@var dayofweek.monday}, {@var dayofweek.tuesday}, {@var dayofweek.thursday}, {@var dayofweek.friday}, {@var dayofweek.saturday}"]
                        },
                        "dayofweek.thursday": {
                            name: "dayofweek.thursday",
                            type: "const int",
                            desc: [a("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var dayofweek.sunday}, {@var dayofweek.monday}, {@var dayofweek.tuesday}, {@var dayofweek.wednesday}, {@var dayofweek.friday}, {@var dayofweek.saturday}"]
                        },
                        "dayofweek.friday": {
                            name: "dayofweek.friday",
                            type: "const int",
                            desc: [a("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var dayofweek.sunday}, {@var dayofweek.monday}, {@var dayofweek.tuesday}, {@var dayofweek.wednesday}, {@var dayofweek.thursday}, {@var dayofweek.saturday}"]
                        },
                        "dayofweek.saturday": {
                            name: "dayofweek.saturday",
                            type: "const int",
                            desc: [a("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var dayofweek.sunday}, {@var dayofweek.monday}, {@var dayofweek.tuesday}, {@var dayofweek.wednesday}, {@var dayofweek.thursday}, {@var dayofweek.friday}"]
                        },
                        timenow: {
                            name: "timenow",
                            type: "series int",
                            desc: [a("Current time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            })],
                            seeAlso: ["{@fun timestamp}, {@var time} (variable), {@var time_close}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]
                        },
                        time: {
                            name: "time",
                            type: "series int",
                            desc: [a("Current bar time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Note that this variable returns the timestamp based on the time of the bar's open. Because of that, for overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this variable can return time before the specified date of the trading day. For example, on EURUSD, `dayofmonth(time)` can be lower by 1 than the date of the trading day, because the bar for the current day actually opens one day prior.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun time} (function), {@var time_close}, {@var timenow}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]
                        },
                        time_close: {
                            name: "time_close",
                            type: "series int",
                            desc: [a("Current bar close time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. On price-based charts this variable value is {@var na}.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var time}, {@var timenow}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]
                        },
                        time_tradingday: {
                            name: "time_tradingday",
                            type: "series int",
                            desc: [a("The beginning time of the trading day the current bar belongs to, in UNIX format (the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970).", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("The variable is useful for overnight sessions, where the current day's session can start on the previous calendar day (e.g., on EURUSD the Monday session will start on Sunday, 17:00). Unlike `time`, which would return the timestamp for Sunday at 17:00 for the Monday daily bar, `time_tradingday` will return the timestamp for Monday, 00:00.", {
                                context: "pine_docs_remarks"
                            }), a("When used on timeframes higher than 1D, `time_tradingday` returns the trading day of the last day inside the bar (e.g. on 1W, it will return the last trading day of the week).", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var time}, {@var time_close}"]
                        },
                        year: {
                            name: "year",
                            type: "series int",
                            desc: [a("Current bar year in exchange timezone.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Note that this variable returns the year based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the year of the trading day.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun year} (function), {@var time}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]
                        },
                        month: {
                            name: "month",
                            type: "series int",
                            desc: [a("Current bar month in exchange timezone.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Note that this variable returns the month based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the month of the trading day.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun month} (function), {@var time}, {@var year}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]
                        },
                        weekofyear: {
                            name: "weekofyear",
                            type: "series int",
                            desc: [a("Week number of current bar time in exchange timezone.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Note that this variable returns the week based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the week of the trading day.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun weekofyear} (function), {@var time}, {@var year}, {@var month}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]
                        },
                        dayofmonth: {
                            name: "dayofmonth",
                            type: "series int",
                            desc: [a("Date of current bar time in exchange timezone.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Note that this variable returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun dayofmonth} (function), {@var time}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]
                        },
                        dayofweek: {
                            name: "dayofweek",
                            type: "series int",
                            desc: [a("Day of week for current bar time in exchange timezone.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Note that this variable returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.", {
                                context: "pine_docs_remarks"
                            }), a("You can use {@var dayofweek.sunday}, {@var dayofweek.monday}, {@var dayofweek.tuesday}, {@var dayofweek.wednesday}, {@var dayofweek.thursday}, {@var dayofweek.friday} and {@var dayofweek.saturday} variables for comparisons.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun dayofweek} (function), {@var time}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var hour}, {@var minute}, {@var second}"]
                        },
                        hour: {
                            name: "hour",
                            type: "series int",
                            desc: [a("Current bar hour in exchange timezone.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun hour} (function), {@var time}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var minute}, {@var second}"]
                        },
                        minute: {
                            name: "minute",
                            type: "series int",
                            desc: [a("Current bar minute in exchange timezone.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun minute} (function), {@var time}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var second}"]
                        },
                        second: {
                            name: "second",
                            type: "series int",
                            desc: [a("Current bar second in exchange timezone.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun second} (function), {@var time}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}"]
                        },
                        "shape.xcross": {
                            name: "shape.xcross",
                            type: "const string",
                            desc: [a("Shape style for {@fun plotshape} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}"]
                        },
                        "shape.cross": {
                            name: "shape.cross",
                            type: "const string",
                            desc: [a("Shape style for {@fun plotshape} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}"]
                        },
                        "shape.circle": {
                            name: "shape.circle",
                            type: "const string",
                            desc: [a("Shape style for {@fun plotshape} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}"]
                        },
                        "shape.triangleup": {
                            name: "shape.triangleup",
                            type: "const string",
                            desc: [a("Shape style for {@fun plotshape} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}"]
                        },
                        "shape.triangledown": {
                            name: "shape.triangledown",
                            type: "const string",
                            desc: [a("Shape style for {@fun plotshape} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}"]
                        },
                        "shape.flag": {
                            name: "shape.flag",
                            type: "const string",
                            desc: [a("Shape style for {@fun plotshape} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}"]
                        },
                        "shape.arrowup": {
                            name: "shape.arrowup",
                            type: "const string",
                            desc: [a("Shape style for {@fun plotshape} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}"]
                        },
                        "shape.arrowdown": {
                            name: "shape.arrowdown",
                            type: "const string",
                            desc: [a("Shape style for {@fun plotshape} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}"]
                        },
                        "shape.labelup": {
                            name: "shape.labelup",
                            type: "const string",
                            desc: [a("Shape style for {@fun plotshape} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}"]
                        },
                        "shape.labeldown": {
                            name: "shape.labeldown",
                            type: "const string",
                            desc: [a("Shape style for {@fun plotshape} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}"]
                        },
                        "shape.square": {
                            name: "shape.square",
                            type: "const string",
                            desc: [a("Shape style for {@fun plotshape} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}"]
                        },
                        "shape.diamond": {
                            name: "shape.diamond",
                            type: "const string",
                            desc: [a("Shape style for {@fun plotshape} function.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}"]
                        },
                        "location.abovebar": {
                            name: "location.abovebar",
                            type: "const string",
                            desc: [a("Location value for {@fun plotshape}, {@fun plotchar} functions. Shape is plotted above main series bars.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}, {@fun plotchar}, {@var location.belowbar}, {@var location.top}, {@var location.bottom}, {@var location.absolute}"]
                        },
                        "location.belowbar": {
                            name: "location.belowbar",
                            type: "const string",
                            desc: [a("Location value for {@fun plotshape}, {@fun plotchar} functions. Shape is plotted below main series bars.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}, {@fun plotchar}, {@var location.abovebar}, {@var location.top}, {@var location.bottom}, {@var location.absolute}"]
                        },
                        "location.top": {
                            name: "location.top",
                            type: "const string",
                            desc: [a("Location value for {@fun plotshape}, {@fun plotchar} functions. Shape is plotted near the top chart border.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}, {@fun plotchar}, {@var location.abovebar}, {@var location.belowbar}, {@var location.bottom}, {@var location.absolute}"]
                        },
                        "location.bottom": {
                            name: "location.bottom",
                            type: "const string",
                            desc: [a("Location value for {@fun plotshape}, {@fun plotchar} functions. Shape is plotted near the bottom chart border.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}, {@fun plotchar}, {@var location.abovebar}, {@var location.belowbar}, {@var location.top}, {@var location.absolute}"]
                        },
                        "location.absolute": {
                            name: "location.absolute",
                            type: "const string",
                            desc: [a("Location value for {@fun plotshape}, {@fun plotchar} functions. Shape is plotted on chart using indicator value as a price coordinate.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plotshape}, {@fun plotchar}, {@var location.abovebar}, {@var location.belowbar}, {@var location.top}, {@var location.bottom}"]
                        },
                        "scale.right": {
                            name: "scale.right",
                            type: "scale_type",
                            desc: [a("Scale value for {@fun indicator} function. Indicator is added to the right price scale.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun indicator}"]
                        },
                        "scale.left": {
                            name: "scale.left",
                            type: "scale_type",
                            desc: [a("Scale value for {@fun indicator} function. Indicator is added to the left price scale.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun indicator}"]
                        },
                        "scale.none": {
                            name: "scale.none",
                            type: "scale_type",
                            desc: [a("Scale value for {@fun indicator} function. Indicator is added in 'No Scale' mode. Can be used only with 'overlay=true'.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun indicator}"]
                        },
                        "strategy.oca.none": {
                            name: "strategy.oca.none",
                            type: "const string",
                            desc: [a("OCA type value for strategy's functions. The parameter determines that an order should not belong to any particular OCO group.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy.entry}, {@fun strategy.exit}, {@fun strategy.order}"]
                        },
                        "strategy.oca.cancel": {
                            name: "strategy.oca.cancel",
                            type: "const string",
                            desc: [a("OCA type value for strategy's functions. The parameter determines that an order should belong to an OCO group, where as soon as an order is filled, all other orders of the same group are cancelled. Note: if more than 1 guaranteed-to-be-executed orders of the same OCA group are placed at once, all those orders are filled.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy.entry}, {@fun strategy.exit}, {@fun strategy.order}"]
                        },
                        "strategy.oca.reduce": {
                            name: "strategy.oca.reduce",
                            type: "const string",
                            desc: [a("OCA type value for strategy's functions. The parameter determines that an order should belong to an OCO group, where if X number of contracts of an order is filled, number of contracts for each other order of the same OCO group is decreased by X. Note: if more than 1 guaranteed-to-be-executed orders of the same OCA group are placed at once, all those orders are filled.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy.entry}, {@fun strategy.exit}, {@fun strategy.order}"]
                        },
                        "strategy.commission.percent": {
                            name: "strategy.commission.percent",
                            type: "const string",
                            desc: [a("Commission type for an order. A percentage of the cash volume of order.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "strategy.commission.cash_per_contract": {
                            name: "strategy.commission.cash_per_contract",
                            type: "const string",
                            desc: [a("Commission type for an order. Money displayed in the account currency per contract.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "strategy.commission.cash_per_order": {
                            name: "strategy.commission.cash_per_order",
                            type: "const string",
                            desc: [a("Commission type for an order. Money displayed in the account currency per order.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "strategy.fixed": {
                            name: "strategy.fixed",
                            type: "const string",
                            desc: [a("This is one of the arguments that can be supplied to the `default_qty_type` parameter in the {@fun strategy} declaration statement. It is only relevant when no value is used for the ‘qty’ parameter in {@fun strategy.entry} or {@fun strategy.order} function calls. It specifies that a number of contracts/shares/lots will be used to enter trades.", {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'strategy("strategy.fixed", overlay = true, default_qty_value = 50, default_qty_type = strategy.fixed, initial_capital = 1000000)', "", "if bar_index == 0", "    // As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 contracts.", "    // qty = 50", '    strategy.entry("EN", strategy.long)', "if bar_index == 2", '    strategy.close("EN")'],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "strategy.cash": {
                            name: "strategy.cash",
                            type: "const string",
                            desc: [a("This is one of the arguments that can be supplied to the `default_qty_type` parameter in the {@fun strategy} declaration statement. It is only relevant when no value is used for the ‘qty’ parameter in {@fun strategy.entry} or {@fun strategy.order} function calls. It specifies that an amount of cash in the `strategy.account_currency` will be used to enter trades.", {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'strategy("strategy.cash", overlay = true, default_qty_value = 50, default_qty_type = strategy.cash, initial_capital = 1000000)', "", "if bar_index == 0", "    // As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 units of cash in the currency of `strategy.account_currency`.", "    // `qty` is calculated as (default_qty_value)/(close price). If current price is $5, then qty = 50/5 = 10.", '    strategy.entry("EN", strategy.long)', "if bar_index == 2", '    strategy.close("EN")'],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "strategy.percent_of_equity": {
                            name: "strategy.percent_of_equity",
                            type: "const string",
                            desc: [a("This is one of the arguments that can be supplied to the `default_qty_type` parameter in the {@fun strategy} declaration statement. It is only relevant when no value is used for the ‘qty’ parameter in {@fun strategy.entry} or {@fun strategy.order} function calls. It specifies that a percentage (0-100) of equity will be used to enter trades.", {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'strategy("strategy.percent_of_equity", overlay = false, default_qty_value = 100, default_qty_type = strategy.percent_of_equity, initial_capital = 1000000)', "", "// As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 100% of available equity.", "if bar_index == 0", '    strategy.entry("EN", strategy.long)', "if bar_index == 2", '    strategy.close("EN")', "plot(strategy.equity)", "", " // The ‘qty’ parameter is set to 10. Entering position with fixed size of 10 contracts and entry market price = (10 * close).", "if bar_index == 4", '    strategy.entry("EN", strategy.long, qty = 10)', "if bar_index == 6", '    strategy.close("EN")'],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "strategy.direction.all": {
                            name: "strategy.direction.all",
                            type: "const string",
                            desc: [a("It allows strategy to open both long and short positions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy.risk.allow_entry_in}"]
                        },
                        "strategy.direction.long": {
                            name: "strategy.direction.long",
                            type: "const string",
                            desc: [a("It allows strategy to open only long positions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy.risk.allow_entry_in}"]
                        },
                        "strategy.direction.short": {
                            name: "strategy.direction.short",
                            type: "const string",
                            desc: [a("It allows strategy to open only short positions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy.risk.allow_entry_in}"]
                        },
                        "strategy.position_size": {
                            name: "strategy.position_size",
                            type: "series float",
                            desc: [a("Direction and size of the current market position. If the value is > 0, the market position is long. If the value is < 0, the market position is short. The absolute value is the number of contracts/shares/lots/units in trade (position size).", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.position_avg_price}"]
                        },
                        "strategy.position_avg_price": {
                            name: "strategy.position_avg_price",
                            type: "series float",
                            desc: [a("Average entry price of current market position. If the market position is flat, 'NaN' is returned.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.position_size}"]
                        },
                        "strategy.openprofit": {
                            name: "strategy.openprofit",
                            type: "series float",
                            desc: [a("Current unrealized profit or loss for all open positions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.netprofit}, {@var strategy.position_size}"]
                        },
                        "strategy.netprofit": {
                            name: "strategy.netprofit",
                            type: "series float",
                            desc: [a("Total currency value of all completed trades.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.openprofit}, {@var strategy.position_size}, {@var strategy.grossprofit}, {@var strategy.grossloss}"]
                        },
                        "strategy.equity": {
                            name: "strategy.equity",
                            type: "series float",
                            desc: [a("Current equity ({@var strategy.initial_capital} + {@var strategy.netprofit} + {@var strategy.openprofit}).", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.netprofit}, {@var strategy.openprofit}, {@var strategy.position_size}"]
                        },
                        "strategy.position_entry_name": {
                            name: "strategy.position_entry_name",
                            type: "simple string",
                            desc: [a("Name of the order that initially opened current market position.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.position_size}"]
                        },
                        "strategy.grossprofit": {
                            name: "strategy.grossprofit",
                            type: "series float",
                            desc: [a("Total currency value of all completed winning trades.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.netprofit}, {@var strategy.grossloss}"]
                        },
                        "strategy.grossloss": {
                            name: "strategy.grossloss",
                            type: "series float",
                            desc: [a("Total currency value of all completed losing trades.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.netprofit}, {@var strategy.grossprofit}"]
                        },
                        "strategy.max_drawdown": {
                            name: "strategy.max_drawdown",
                            type: "series float",
                            desc: [a("Maximum equity drawdown value for the whole trading interval.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.netprofit}, {@var strategy.equity}, {@var strategy.max_runup}"]
                        },
                        "strategy.max_runup": {
                            name: "strategy.max_runup",
                            type: "series float",
                            desc: [a("Maximum equity run-up value for the whole trading interval.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.netprofit}, {@var strategy.equity}, {@var strategy.max_drawdown}"]
                        },
                        "strategy.max_contracts_held_all": {
                            name: "strategy.max_contracts_held_all",
                            type: "series float",
                            desc: [a("Maximum number of contracts/shares/lots/units in one trade for the whole trading interval.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.position_size}, {@var strategy.max_contracts_held_long}, {@var strategy.max_contracts_held_short}"]
                        },
                        "strategy.max_contracts_held_long": {
                            name: "strategy.max_contracts_held_long",
                            type: "series float",
                            desc: [a("Maximum number of contracts/shares/lots/units in one long trade for the whole trading interval.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.position_size}, {@var strategy.max_contracts_held_all}, {@var strategy.max_contracts_held_short}"]
                        },
                        "strategy.max_contracts_held_short": {
                            name: "strategy.max_contracts_held_short",
                            type: "series float",
                            desc: [a("Maximum number of contracts/shares/lots/units in one short trade for the whole trading interval.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.position_size}, {@var strategy.max_contracts_held_all}, {@var strategy.max_contracts_held_long}"]
                        },
                        "strategy.opentrades": {
                            name: "strategy.opentrades",
                            type: "series int",
                            desc: [a("Number of market position entries, which were not closed and remain opened. If there is no open market position, 0 is returned.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.position_size}"]
                        },
                        "strategy.closedtrades": {
                            name: "strategy.closedtrades",
                            type: "series int",
                            desc: [a("Number of trades, which were closed for the whole trading interval.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.position_size}, {@var strategy.opentrades}, {@var strategy.wintrades}, {@var strategy.losstrades}, {@var strategy.eventrades}"]
                        },
                        "strategy.wintrades": {
                            name: "strategy.wintrades",
                            type: "series int",
                            desc: [a("Number of profitable trades for the whole trading interval.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.position_size}, {@var strategy.opentrades}, {@var strategy.closedtrades}, {@var strategy.losstrades}, {@var strategy.eventrades}"]
                        },
                        "strategy.losstrades": {
                            name: "strategy.losstrades",
                            type: "series int",
                            desc: [a("Number of unprofitable trades for the whole trading interval.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.position_size}, {@var strategy.opentrades}, {@var strategy.closedtrades}, {@var strategy.wintrades}, {@var strategy.eventrades}"]
                        },
                        "strategy.eventrades": {
                            name: "strategy.eventrades",
                            type: "series int",
                            desc: [a("Number of breakeven trades for the whole trading interval.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var strategy.position_size}, {@var strategy.opentrades}, {@var strategy.closedtrades}, {@var strategy.wintrades}, {@var strategy.losstrades}"]
                        },
                        "strategy.initial_capital": {
                            name: "strategy.initial_capital",
                            type: "series float",
                            desc: [a("The amount of initial capital set in the strategy properties.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "strategy.account_currency": {
                            name: "strategy.account_currency",
                            type: "simple string",
                            desc: [a("Returns the currency used to calculate results, which can be set in the strategy's properties.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}, {@fun strategy.convert_to_account}, {@fun strategy.convert_to_symbol}"]
                        },
                        "currency.NONE": {
                            name: "currency.NONE",
                            type: "const string",
                            desc: [a("Unspecified currency.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.USD": {
                            name: "currency.USD",
                            type: "const string",
                            desc: [a("United States dollar.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.EUR": {
                            name: "currency.EUR",
                            type: "const string",
                            desc: [a("Euro.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.AUD": {
                            name: "currency.AUD",
                            type: "const string",
                            desc: [a("Australian dollar.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.GBP": {
                            name: "currency.GBP",
                            type: "const string",
                            desc: [a("Pound sterling.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.NZD": {
                            name: "currency.NZD",
                            type: "const string",
                            desc: [a("New Zealand dollar.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.CAD": {
                            name: "currency.CAD",
                            type: "const string",
                            desc: [a("Canadian dollar.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.CHF": {
                            name: "currency.CHF",
                            type: "const string",
                            desc: [a("Swiss franc.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.HKD": {
                            name: "currency.HKD",
                            type: "const string",
                            desc: [a("Hong Kong dollar.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.JPY": {
                            name: "currency.JPY",
                            type: "const string",
                            desc: [a("Japanese yen.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.NOK": {
                            name: "currency.NOK",
                            type: "const string",
                            desc: [a("Norwegian krone.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.SEK": {
                            name: "currency.SEK",
                            type: "const string",
                            desc: [a("Swedish krona.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.SGD": {
                            name: "currency.SGD",
                            type: "const string",
                            desc: [a("Singapore dollar.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.TRY": {
                            name: "currency.TRY",
                            type: "const string",
                            desc: [a("Turkish lira.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.ZAR": {
                            name: "currency.ZAR",
                            type: "const string",
                            desc: [a("South African rand.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.RUB": {
                            name: "currency.RUB",
                            type: "const string",
                            desc: [a("Russian ruble.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.BTC": {
                            name: "currency.BTC",
                            type: "const string",
                            desc: [a("Bitcoin.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.ETH": {
                            name: "currency.ETH",
                            type: "const string",
                            desc: [a("Ethereum.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.MYR": {
                            name: "currency.MYR",
                            type: "const string",
                            desc: [a("Malaysian ringgit.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.KRW": {
                            name: "currency.KRW",
                            type: "const string",
                            desc: [a("South Korean won.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "currency.USDT": {
                            name: "currency.USDT",
                            type: "const string",
                            desc: [a("Tether.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy}"]
                        },
                        "strategy.long": {
                            name: "strategy.long",
                            type: "strategy_direction",
                            desc: [a("Long position entry.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy.entry}, {@fun strategy.exit}, {@fun strategy.order}"]
                        },
                        "strategy.short": {
                            name: "strategy.short",
                            type: "strategy_direction",
                            desc: [a("Short position entry.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun strategy.entry}, {@fun strategy.exit}, {@fun strategy.order}"]
                        },
                        "barstate.isfirst": {
                            name: "barstate.isfirst",
                            type: "series bool",
                            desc: [a("Returns true if current bar is first bar in barset, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var barstate.islast}, {@var barstate.ishistory}, {@var barstate.isrealtime}, {@var barstate.isnew}, {@var barstate.isconfirmed}, {@var barstate.islastconfirmedhistory}"],
                            remarks: [a("PineScript code that uses this variable could calculate differently on history and real-time data.", {
                                context: "pine_docs_remarks"
                            }), a("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            })]
                        },
                        "barstate.islast": {
                            name: "barstate.islast",
                            type: "series bool",
                            desc: [a("Returns true if current bar is the last bar in barset, false otherwise. This condition is true for all real-time bars in barset.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var barstate.isfirst}, {@var barstate.ishistory}, {@var barstate.isrealtime}, {@var barstate.isnew}, {@var barstate.isconfirmed}, {@var barstate.islastconfirmedhistory}"],
                            remarks: [a("PineScript code that uses this variable could calculate differently on history and real-time data.", {
                                context: "pine_docs_remarks"
                            }), a("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            })]
                        },
                        "barstate.ishistory": {
                            name: "barstate.ishistory",
                            type: "series bool",
                            desc: [a("Returns true if current bar is a historical bar, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var barstate.isfirst}, {@var barstate.islast}, {@var barstate.isrealtime}, {@var barstate.isnew}, {@var barstate.isconfirmed}, {@var barstate.islastconfirmedhistory}"],
                            remarks: [a("PineScript code that uses this variable could calculate differently on history and real-time data.", {
                                context: "pine_docs_remarks"
                            }), a("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            })]
                        },
                        "barstate.isrealtime": {
                            name: "barstate.isrealtime",
                            type: "series bool",
                            desc: [a("Returns true if current bar is a real-time bar, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var barstate.isfirst}, {@var barstate.islast}, {@var barstate.ishistory}, {@var barstate.isnew}, {@var barstate.isconfirmed}, {@var barstate.islastconfirmedhistory}"],
                            remarks: [a("PineScript code that uses this variable could calculate differently on history and real-time data.", {
                                context: "pine_docs_remarks"
                            }), a("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            })]
                        },
                        "barstate.isnew": {
                            name: "barstate.isnew",
                            type: "series bool",
                            desc: [a("Returns true if script is currently calculating on new bar, false otherwise. This variable is true when calculating on historical bars or on first update of a newly generated real-time bar.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var barstate.isfirst}, {@var barstate.islast}, {@var barstate.ishistory}, {@var barstate.isrealtime}, {@var barstate.isconfirmed}, {@var barstate.islastconfirmedhistory}"],
                            remarks: [a("PineScript code that uses this variable could calculate differently on history and real-time data.", {
                                context: "pine_docs_remarks"
                            }), a("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            })]
                        },
                        "barstate.isconfirmed": {
                            name: "barstate.isconfirmed",
                            type: "series bool",
                            desc: [a("Returns true if the script is calculating the last (closing) update of the current bar. The next script calculation will be on the new bar data.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var barstate.isfirst}, {@var barstate.islast}, {@var barstate.ishistory}, {@var barstate.isrealtime}, {@var barstate.isnew}, {@var barstate.islastconfirmedhistory}"],
                            remarks: [a("PineScript code that uses this variable could calculate differently on history and real-time data.", {
                                context: "pine_docs_remarks"
                            }), a("It is NOT recommended to use {@var barstate.isconfirmed} in {@fun request.security} expression. Its value requested from {@fun request.security} is unpredictable.", {
                                context: "pine_docs_remarks"
                            }), a("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            })]
                        },
                        "barstate.islastconfirmedhistory": {
                            name: "barstate.islastconfirmedhistory",
                            type: "series bool",
                            desc: [a("Returns true if script is executing on the dataset's last bar when market is closed, or script is executing on the bar immediately preceding the real-time bar, if market is open. Returns false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var barstate.isfirst}, {@var barstate.islast}, {@var barstate.ishistory}, {@var barstate.isrealtime}, {@var barstate.isnew}"],
                            remarks: [a("PineScript code that uses this variable could calculate differently on history and real-time data.", {
                                context: "pine_docs_remarks"
                            }), a("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            })]
                        },
                        "session.ismarket": {
                            name: "session.ismarket",
                            type: "series bool",
                            desc: [a("Returns true if the current bar is a part of the regular trading hours (i.e. market hours), false otherwise", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var session.ispremarket}, {@var session.ispostmarket}"]
                        },
                        "session.ispremarket": {
                            name: "session.ispremarket",
                            type: "series bool",
                            desc: [a("Returns true if the current bar is a part of the pre-market, false otherwise. On non-intraday charts always returns false.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var session.ismarket}, {@var session.ispostmarket}"]
                        },
                        "session.ispostmarket": {
                            name: "session.ispostmarket",
                            type: "series bool",
                            desc: [a("Returns true if the current bar is a part of the post-market, false otherwise. On non-intraday charts always returns false.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var session.ismarket}, {@var session.ispremarket}"]
                        },
                        "barmerge.lookahead_off": {
                            name: "barmerge.lookahead_off",
                            type: "barmerge_lookahead",
                            desc: [a('Merge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their close time. This merge strategy disables effect of getting data from "future" on calculation on history.', {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun request.security}, {@var barmerge.lookahead_on}"]
                        },
                        "barmerge.lookahead_on": {
                            name: "barmerge.lookahead_on",
                            type: "barmerge_lookahead",
                            desc: [a('Merge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their opening time. This merge strategy can lead to undesirable effect of getting data from "future" on calculation on history. This is unacceptable in backtesting strategies, but can be useful in indicators.', {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun request.security}, {@var barmerge.lookahead_off}"]
                        },
                        "barmerge.gaps_off": {
                            name: "barmerge.gaps_off",
                            type: "barmerge_gaps",
                            desc: [a("Merge strategy for requested data. Data is merged continuously without gaps, all the gaps are filled with the previous nearest existing value.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun request.security}, {@var barmerge.gaps_on}"]
                        },
                        "barmerge.gaps_on": {
                            name: "barmerge.gaps_on",
                            type: "barmerge_gaps",
                            desc: [a("Merge strategy for requested data. Data is merged with possible gaps ({@var na} values).", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun request.security}, {@var barmerge.gaps_off}"]
                        },
                        "xloc.bar_index": {
                            name: "xloc.bar_index",
                            type: "const string",
                            desc: [a("A named constant that specifies the algorithm of interpretation of x-value in functions {@fun line.new} and {@fun label.new}. If xloc = {@var xloc.bar_index}, value of x is a bar index.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun line.new}, {@fun label.new}, {@fun line.set_xloc}, {@fun label.set_xloc}, {@var xloc.bar_time}"]
                        },
                        "xloc.bar_time": {
                            name: "xloc.bar_time",
                            type: "const string",
                            desc: [a("A named constant that specifies the algorithm of interpretation of x-value in functions {@fun line.new} and {@fun label.new}. If xloc = {@var xloc.bar_time}, value of x is a bar UNIX time.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun line.new}, {@fun label.new}, {@fun line.set_xloc}, {@fun label.set_xloc}, {@var xloc.bar_index}"]
                        },
                        "yloc.price": {
                            name: "yloc.price",
                            type: "const string",
                            desc: [a("A named constant that specifies the algorithm of interpretation of y-value in function {@fun label.new}.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_yloc}, {@var yloc.abovebar}, {@var yloc.belowbar}"]
                        },
                        "yloc.abovebar": {
                            name: "yloc.abovebar",
                            type: "const string",
                            desc: [a("A named constant that specifies the algorithm of interpretation of y-value in function {@fun label.new}.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_yloc}, {@var yloc.price}, {@var yloc.belowbar}"]
                        },
                        "yloc.belowbar": {
                            name: "yloc.belowbar",
                            type: "const string",
                            desc: [a("A named constant that specifies the algorithm of interpretation of y-value in function {@fun label.new}.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_yloc}, {@var yloc.price}, {@var yloc.abovebar}"]
                        },
                        "extend.none": {
                            name: "extend.none",
                            type: "const string",
                            desc: [a("A named constant for {@fun line.new} and {@fun line.set_extend} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun line.new}, {@fun line.set_extend}, {@var extend.left}, {@var extend.right}, {@var extend.both}"]
                        },
                        "extend.left": {
                            name: "extend.left",
                            type: "const string",
                            desc: [a("A named constant for {@fun line.new} and {@fun line.set_extend} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun line.new}, {@fun line.set_extend}, {@var extend.none}, {@var extend.right}, {@var extend.both}"]
                        },
                        "extend.right": {
                            name: "extend.right",
                            type: "const string",
                            desc: [a("A named constant for {@fun line.new} and {@fun line.set_extend} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun line.new}, {@fun line.set_extend}, {@var extend.none}, {@var extend.left}, {@var extend.both}"]
                        },
                        "extend.both": {
                            name: "extend.both",
                            type: "const string",
                            desc: [a("A named constant for {@fun line.new} and {@fun line.set_extend} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun line.new}, {@fun line.set_extend}, {@var extend.none}, {@var extend.left}, {@var extend.right}"]
                        },
                        "label.style_none": {
                            name: "label.style_none",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_xcross": {
                            name: "label.style_xcross",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_cross": {
                            name: "label.style_cross",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_triangleup": {
                            name: "label.style_triangleup",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_triangledown": {
                            name: "label.style_triangledown",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_flag": {
                            name: "label.style_flag",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_circle": {
                            name: "label.style_circle",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_arrowup": {
                            name: "label.style_arrowup",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_arrowdown": {
                            name: "label.style_arrowdown",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_label_up": {
                            name: "label.style_label_up",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_label_down": {
                            name: "label.style_label_down",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_label_left": {
                            name: "label.style_label_left",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_label_right": {
                            name: "label.style_label_right",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_label_lower_left": {
                            name: "label.style_label_lower_left",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_label_lower_right": {
                            name: "label.style_label_lower_right",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_label_upper_left": {
                            name: "label.style_label_upper_left",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_label_upper_right": {
                            name: "label.style_label_upper_right",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_label_center": {
                            name: "label.style_label_center",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_square}, {@var label.style_diamond}"]
                        },
                        "label.style_square": {
                            name: "label.style_square",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_diamond}"]
                        },
                        "label.style_diamond": {
                            name: "label.style_diamond",
                            type: "const string",
                            desc: [a("Label style for {@fun label.new} and {@fun label.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}"]
                        },
                        "display.none": {
                            name: "display.none",
                            type: "plot_simple_display",
                            desc: [a("A named argument for use with the `display` parameter. Causes no plot values to be displayed. The plotted values can nonetheless be used in alert template messages, and will appear in exported chart data.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@fun plotshape}, {@fun plotchar}, {@fun plotarrow}, {@fun plotbar}, {@fun plotcandle}"]
                        },
                        "display.pane": {
                            name: "display.pane",
                            type: "plot_display",
                            desc: [a("A named argument for use with the `display` parameter. Displays the plot in the pane used by the script, as defined with the {@fun indicator}/{@fun strategy} declaration statement's `overlay` parameter.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@fun plotshape}, {@fun plotchar}, {@fun plotarrow}, {@fun plotbar}, {@fun plotcandle}"]
                        },
                        "display.data_window": {
                            name: "display.data_window",
                            type: "plot_display",
                            desc: [a("A named argument for use with the `display` parameter. Displays the plot values in the Data Window, a menu available in the chart's right sidebar.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@fun plotshape}, {@fun plotchar}, {@fun plotarrow}, {@fun plotbar}, {@fun plotcandle}"]
                        },
                        "display.price_scale": {
                            name: "display.price_scale",
                            type: "plot_display",
                            desc: [a("A named argument for use with the `display` parameter. Controls the display of the plot's label and price in the price scale, if the chart's settings allow them.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@fun plotshape}, {@fun plotchar}, {@fun plotarrow}, {@fun plotbar}, {@fun plotcandle}"]
                        },
                        "display.status_line": {
                            name: "display.status_line",
                            type: "plot_display",
                            desc: [a("A named argument for use with the `display` parameter. Displays the plot values in the script's status line, next to the script's name on the chart, if the chart's settings allow them.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@fun plotshape}, {@fun plotchar}, {@fun plotarrow}, {@fun plotbar}, {@fun plotcandle}"]
                        },
                        "display.all": {
                            name: "display.all",
                            type: "plot_simple_display",
                            desc: [a("A named argument for use with the `display` parameter. Displays everywhere.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun plot}, {@fun plotshape}, {@fun plotchar}, {@fun plotarrow}, {@fun plotbar}, {@fun plotcandle}"]
                        },
                        "line.style_solid": {
                            name: "line.style_solid",
                            type: "const string",
                            desc: [a("Line style for {@fun line.new} and {@fun line.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun line.new}, {@fun line.set_style}, {@var line.style_dotted}, {@var line.style_dashed}, {@var line.style_arrow_left}, {@var line.style_arrow_right}, {@var line.style_arrow_both}"]
                        },
                        "line.style_dotted": {
                            name: "line.style_dotted",
                            type: "const string",
                            desc: [a("Line style for {@fun line.new} and {@fun line.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun line.new}, {@fun line.set_style}, {@var line.style_solid}, {@var line.style_dashed}, {@var line.style_arrow_left}, {@var line.style_arrow_right}, {@var line.style_arrow_both}"]
                        },
                        "line.style_dashed": {
                            name: "line.style_dashed",
                            type: "const string",
                            desc: [a("Line style for {@fun line.new} and {@fun line.set_style} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun line.new}, {@fun line.set_style}, {@var line.style_solid}, {@var line.style_dotted}, {@var line.style_arrow_left}, {@var line.style_arrow_right}, {@var line.style_arrow_both}"]
                        },
                        "line.style_arrow_left": {
                            name: "line.style_arrow_left",
                            type: "const string",
                            desc: [a("Line style for {@fun line.new} and {@fun line.set_style} functions. Solid line with arrow on the first point.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun line.new}, {@fun line.set_style}, {@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}, {@var line.style_arrow_right}, {@var line.style_arrow_both}"]
                        },
                        "line.style_arrow_right": {
                            name: "line.style_arrow_right",
                            type: "const string",
                            desc: [a("Line style for {@fun line.new} and {@fun line.set_style} functions. Solid line with arrow on the second point.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun line.new}, {@fun line.set_style}, {@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}, {@var line.style_arrow_left}, {@var line.style_arrow_both}"]
                        },
                        "line.style_arrow_both": {
                            name: "line.style_arrow_both",
                            type: "const string",
                            desc: [a("Line style for {@fun line.new} and {@fun line.set_style} functions. Solid line with arrows on both points.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun line.new}, {@fun line.set_style}, {@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}, {@var line.style_arrow_left}, {@var line.style_arrow_right}"]
                        },
                        "text.align_center": {
                            name: "text.align_center",
                            type: "const string",
                            desc: [a("Text alignment for {@fun box.new}, {@fun box.set_text_halign}, {@fun box.set_text_valign}, {@fun label.new} and {@fun label.set_textalign} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@var text.align_left}, {@var text.align_right}."]
                        },
                        "text.align_left": {
                            name: "text.align_left",
                            type: "const string",
                            desc: [a("Horizontal text alignment for {@fun box.new}, {@fun box.set_text_halign}, {@fun label.new} and {@fun label.set_textalign} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@var text.align_center}, {@var text.align_right}."]
                        },
                        "text.align_right": {
                            name: "text.align_right",
                            type: "const string",
                            desc: [a("Horizontal text alignment for {@fun box.new}, {@fun box.set_text_halign}, {@fun label.new} and {@fun label.set_textalign} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@fun label.set_style}, {@var text.align_center}, {@var text.align_left}."]
                        },
                        "text.align_top": {
                            name: "text.align_top",
                            type: "const string",
                            desc: [a("Vertical text alignment for {@fun box.new}, {@fun box.set_text_valign}, {@fun table.cell} and {@fun table.cell_set_text_valign} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun table.cell}, {@fun table.cell_set_text_valign}, {@var text.align_center}, {@var text.align_left}, {@var text.align_right}."]
                        },
                        "text.align_bottom": {
                            name: "text.align_bottom",
                            type: "const string",
                            desc: [a("Vertical text alignment for {@fun box.new}, {@fun box.set_text_valign}, {@fun table.cell} and {@fun table.cell_set_text_valign} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun table.cell}, {@fun table.cell_set_text_valign}, {@var text.align_center}, {@var text.align_left}, {@var text.align_right}."]
                        },
                        "text.wrap_auto": {
                            name: "text.wrap_auto",
                            type: "const string",
                            desc: [a("Automatic wrapping mode for {@fun box.new} and {@fun box.set_text_wrap} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun box.new} {@fun box.set_text} {@fun box.set_text_wrap}"]
                        },
                        "text.wrap_none": {
                            name: "text.wrap_none",
                            type: "const string",
                            desc: [a("Disabled wrapping mode for {@fun box.new} and {@fun box.set_text_wrap} functions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun box.new} {@fun box.set_text} {@fun box.set_text_wrap}"]
                        },
                        "order.ascending": {
                            name: "order.ascending",
                            type: "sort_order",
                            desc: [a("Determines the sort order of the array from the smallest to the largest value.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun array.new_float}, {@fun array.sort}."]
                        },
                        "order.descending": {
                            name: "order.descending",
                            type: "sort_order",
                            desc: [a("Determines the sort order of the array from the largest to the smallest value.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun array.new_float}, {@fun array.sort}."]
                        },
                        "alert.freq_all": {
                            name: "alert.freq_all",
                            type: "const string",
                            desc: [a("A named constant for use with the `freq` parameter of the alert() function.", {
                                context: "pine_docs_desc"
                            }), a("All function calls trigger the alert.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun alert}."]
                        },
                        "alert.freq_once_per_bar": {
                            name: "alert.freq_once_per_bar",
                            type: "const string",
                            desc: [a("A named constant for use with the `freq` parameter of the alert() function.", {
                                context: "pine_docs_desc"
                            }), a("The first function call during the bar triggers the alert.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun alert}."]
                        },
                        "alert.freq_once_per_bar_close": {
                            name: "alert.freq_once_per_bar_close",
                            type: "const string",
                            desc: [a("A named constant for use with the `freq` parameter of the alert() function.", {
                                context: "pine_docs_desc"
                            }), a("The function call triggers the alert only when it occurs during the last script iteration of the real-time bar, when it closes.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun alert}."]
                        },
                        "earnings.actual": {
                            name: "earnings.actual",
                            type: "const string",
                            desc: [a("A named constant for the {@fun request.earnings} function. Is used to request the earnings value as it was reported.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun request.earnings}."]
                        },
                        "earnings.estimate": {
                            name: "earnings.estimate",
                            type: "const string",
                            desc: [a("A named constant for the {@fun request.earnings} function. Is used to request the estimated earnings value.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun request.earnings}."]
                        },
                        "earnings.standardized": {
                            name: "earnings.standardized",
                            type: "const string",
                            desc: [a("A named constant for the {@fun request.earnings} function. Is used to request the standardized earnings value.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun request.earnings}."]
                        },
                        "dividends.net": {
                            name: "dividends.net",
                            type: "const string",
                            desc: [a("A named constant for the {@fun request.dividends} function. Is used to request the dividends return on a stock after deductions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun request.dividends}."]
                        },
                        "dividends.gross": {
                            name: "dividends.gross",
                            type: "const string",
                            desc: [a("A named constant for the {@fun request.dividends} function. Is used to request the dividends return on a stock before deductions.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun request.dividends}."]
                        },
                        "splits.denominator": {
                            name: "splits.denominator",
                            type: "const string",
                            desc: [a("A named constant for the {@fun request.splits} function. Is used to request the denominator (the number below the line in a fraction) of a splits.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun request.splits}."]
                        },
                        "splits.numerator": {
                            name: "splits.numerator",
                            type: "const string",
                            desc: [a("A named constant for the {@fun request.splits} function. Is used to request the numerator (the number above the line in a fraction) of a splits.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun request.splits}."]
                        },
                        "label.all": {
                            name: "label.all",
                            type: "label[]",
                            desc: [a("Returns an array filled with all the current labels drawn by the script.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun label.new}, {@var line.all}, {@var box.all}, {@var table.all}."],
                            examples: ["//@version=5", 'indicator("label.all")', "//delete all labels", "label.new(bar_index, close)", "a_allLabels = label.all", "if array.size(a_allLabels) > 0", "\tfor i = 0 to array.size(a_allLabels) - 1", "\t\tlabel.delete(array.get(a_allLabels, i))"],
                            remarks: [a("The array is read-only. Index zero of the array is the ID of the oldest object on the chart.", {
                                context: "pine_docs_remarks"
                            })]
                        },
                        "line.all": {
                            name: "line.all",
                            type: "line[]",
                            desc: [a("Returns an array filled with all the current lines drawn by the script.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun line.new}, {@var label.all}, {@var box.all}, {@var table.all}."],
                            examples: ["//@version=5", 'indicator("line.all")', "//delete all lines", "line.new(bar_index - 10, close, bar_index, close)", "a_allLines = line.all", "if array.size(a_allLines) > 0", "\tfor i = 0 to array.size(a_allLines) - 1", "\t\tline.delete(array.get(a_allLines, i))"],
                            remarks: [a("The array is read-only. Index zero of the array is the ID of the oldest object on the chart.", {
                                context: "pine_docs_remarks"
                            })]
                        },
                        "linefill.all": {
                            name: "linefill.all",
                            type: "linefill[]",
                            desc: [a("Returns an array filled with all the current linefill objects drawn by the script.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("The array is read-only. Index zero of the array is the ID of the oldest object on the chart.", {
                                context: "pine_docs_remarks"
                            })]
                        },
                        "box.all": {
                            name: "box.all",
                            type: "box[]",
                            desc: [a("Returns an array filled with all the current boxes drawn by the script.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun box.new}, {@var line.all}, {@var label.all}, {@var table.all}."],
                            examples: ["//@version=5", 'indicator("box.all")', "//delete all boxes", "box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)", "a_allBoxes = box.all", "if array.size(a_allBoxes) > 0", "\tfor i = 0 to array.size(a_allBoxes) - 1", "\t\tbox.delete(array.get(a_allBoxes, i))"],
                            remarks: [a("The array is read-only. Index zero of the array is the ID of the oldest object on the chart.", {
                                context: "pine_docs_remarks"
                            })]
                        },
                        "table.all": {
                            name: "table.all",
                            type: "table[]",
                            desc: [a("Returns an array filled with all the current tables drawn by the script.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@fun table.new}, {@var line.all}, {@var label.all}, {@var box.all}."],
                            examples: ["//@version=5", 'indicator("table.all")', "//delete all tables", "table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)", "a_allTables = table.all", "if array.size(a_allTables) > 0", "\tfor i = 0 to array.size(a_allTables) - 1", "\t\ttable.delete(array.get(a_allTables, i))"],
                            remarks: [a("The array is read-only. Index zero of the array is the ID of the oldest object on the chart.", {
                                context: "pine_docs_remarks"
                            })]
                        },
                        "chart.bg_color": {
                            name: "chart.bg_color",
                            type: "input color",
                            desc: [a('Returns the color of the chart\'s background from the "Chart settings/Appearance/Background" field. When a gradient is selected, the middle point of the gradient is returned.', {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var chart.fg_color}"],
                            skipForReference: !1
                        },
                        "chart.fg_color": {
                            name: "chart.fg_color",
                            type: "input color",
                            desc: [a("Returns a color providing optimal contrast with {@var chart.bg_color}.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var chart.bg_color}"],
                            skipForReference: !1
                        },
                        "chart.left_visible_bar_time": {
                            name: "chart.left_visible_bar_time",
                            type: "input int",
                            desc: [a("The {@var time} of the leftmost bar currently visible on the chart.", {
                                context: "pine_docs_desc"
                            })],
                            skipForReference: !1,
                            seeAlso: ["{@var chart.right_visible_bar_time}"],
                            remarks: [a("Scripts using this variable will automatically re-execute when its value updates to reflect changes in the chart, which can be caused by users scrolling the chart, or new real-time bars.", {
                                context: "pine_docs_remarks"
                            })]
                        },
                        "chart.right_visible_bar_time": {
                            name: "chart.right_visible_bar_time",
                            type: "input int",
                            desc: [a("The {@var time} of the rightmost bar currently visible on the chart.", {
                                context: "pine_docs_desc"
                            })],
                            skipForReference: !1,
                            seeAlso: ["{@var chart.left_visible_bar_time}"],
                            remarks: [a("Scripts using this variable will automatically re-execute when its value updates to reflect changes in the chart, which can be caused by users scrolling the chart, or new real-time bars.", {
                                context: "pine_docs_remarks"
                            })]
                        },
                        "chart.is_heikinashi": {
                            name: "chart.is_heikinashi",
                            type: "simple bool",
                            returns: [a("Returns {@op true} if the chart type is Heikin Ashi, {@op false} otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@var chart.is_renko}, {@var chart.is_linebreak}, {@var chart.is_kagi}, {@var chart.is_pnf}, {@var chart.is_range}"]
                        },
                        "chart.is_renko": {
                            name: "chart.is_renko",
                            type: "simple bool",
                            returns: [a("Returns {@op true} if the chart type is Renko, {@op false} otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@var chart.is_heikinashi}, {@var chart.is_linebreak}, {@var chart.is_kagi}, {@var chart.is_pnf}, {@var chart.is_range}"]
                        },
                        "chart.is_linebreak": {
                            name: "chart.is_linebreak",
                            type: "simple bool",
                            returns: [a("Returns {@op true} if the chart type is Line break, {@op false} otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@var chart.is_renko}, {@var chart.is_heikinashi}, {@var chart.is_kagi}, {@var chart.is_pnf}, {@var chart.is_range}"]
                        },
                        "chart.is_kagi": {
                            name: "chart.is_kagi",
                            type: "simple bool",
                            returns: [a("Returns {@op true} if the chart type is Kagi, {@op false} otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@var chart.is_renko}, {@var chart.is_linebreak}, {@var chart.is_heikinashi}, {@var chart.is_pnf}, {@var chart.is_range}"]
                        },
                        "chart.is_pnf": {
                            name: "chart.is_pnf",
                            type: "simple bool",
                            returns: [a("Returns {@op true} if the chart type is Point & figure, {@op false} otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@var chart.is_renko}, {@var chart.is_linebreak}, {@var chart.is_kagi}, {@var chart.is_heikinashi}, {@var chart.is_range}"]
                        },
                        "chart.is_range": {
                            name: "chart.is_range",
                            type: "simple bool",
                            returns: [a("Returns {@op true} if the chart type is Range, {@op false} otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@var chart.is_renko}, {@var chart.is_linebreak}, {@var chart.is_kagi}, {@var chart.is_pnf}, {@var chart.is_heikinashi}"]
                        },
                        "chart.is_standard": {
                            name: "chart.is_standard",
                            type: "simple bool",
                            returns: [a("Returns {@op true} if the chart type is bars, candles, hollow candles, line, area or baseline, {@op false} otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@var chart.is_renko}, {@var chart.is_linebreak}, {@var chart.is_kagi}, {@var chart.is_pnf}, {@var chart.is_range}, {@var chart.is_heikinashi}"]
                        },
                        "color.black": {
                            name: "color.black",
                            type: "const color",
                            desc: [a("Is a named constant for #363A45 color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.silver": {
                            name: "color.silver",
                            type: "const color",
                            desc: [a("Is a named constant for #B2B5BE color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.gray": {
                            name: "color.gray",
                            type: "const color",
                            desc: [a("Is a named constant for #787B86 color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.white": {
                            name: "color.white",
                            type: "const color",
                            desc: [a("Is a named constant for #FFFFFF color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.maroon": {
                            name: "color.maroon",
                            type: "const color",
                            desc: [a("Is a named constant for #880E4F color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.red": {
                            name: "color.red",
                            type: "const color",
                            desc: [a("Is a named constant for #FF5252 color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.purple": {
                            name: "color.purple",
                            type: "const color",
                            desc: [a("Is a named constant for #9C27B0 color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.fuchsia": {
                            name: "color.fuchsia",
                            type: "const color",
                            desc: [a("Is a named constant for #E040FB color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.green": {
                            name: "color.green",
                            type: "const color",
                            desc: [a("Is a named constant for #4CAF50 color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.lime": {
                            name: "color.lime",
                            type: "const color",
                            desc: [a("Is a named constant for #00E676 color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.olive": {
                            name: "color.olive",
                            type: "const color",
                            desc: [a("Is a named constant for #808000 color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.yellow": {
                            name: "color.yellow",
                            type: "const color",
                            desc: [a("Is a named constant for #FFEB3B color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.navy": {
                            name: "color.navy",
                            type: "const color",
                            desc: [a("Is a named constant for #311B92 color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.blue": {
                            name: "color.blue",
                            type: "const color",
                            desc: [a("Is a named constant for #2962ff color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.teal": {
                            name: "color.teal",
                            type: "const color",
                            desc: [a("Is a named constant for #00897B color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.aqua}, {@var color.orange}"]
                        },
                        "color.aqua": {
                            name: "color.aqua",
                            type: "const color",
                            desc: [a("Is a named constant for #00BCD4 color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.orange}"]
                        },
                        "color.orange": {
                            name: "color.orange",
                            type: "const color",
                            desc: [a("Is a named constant for #FF9800 color.", {
                                context: "pine_docs_desc"
                            })],
                            seeAlso: ["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}"]
                        }
                    }
                },
                functions: {
                    title: a("Built-in Functions"),
                    prefix: "fun_",
                    docs: {
                        indicator: {
                            kind: "Built-in annotation function",
                            desc: [a("This declaration statement designates the script as an indicator and sets a number of indicator-related properties.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "title",
                                info: a("The title of the script. It is displayed on the chart when no `shorttitle` argument is used, and becomes the publication's default title when publishing the script.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "shorttitle",
                                info: a("The script's display name on charts. If specified, it will replace the `title` argument in most chart-related windows. Optional. The default is the argument used for `title`.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "overlay",
                                info: a("If {@op true}, the indicator will be displayed over the chart. If {@op false}, it will be added in a separate pane. Optional. The default is {@op false}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "format",
                                info: a("Specifies the formatting of the script's displayed values. Possible values: {@var format.inherit}, {@var format.price}, {@var format.volume}. Optional. The default is {@var format.inherit}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "precision",
                                info: a("Specifies the number of digits after the floating point of the script's displayed values. Must be a non-negative integer no greater than 16. If `format` is set to {@var format.inherit} and `precision` is specified, the format will instead be set to {@var format.price}. Optional. The default is inherited from the precision of the chart's symbol.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "scale",
                                info: a("The price scale used. Possible values: {@var scale.right}, {@var scale.left}, {@var scale.none}. The {@var scale.none} value can only be applied in combination with `overlay = true`. Optional. By default, the script uses the same scale as the chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "scale_type"
                            }, {
                                name: "max_bars_back",
                                info: a("The length of the historical buffer the script keeps for every variable and function, which determines how many past values can be referenced using the `[]` history-referencing operator. The required buffer size is automatically detected by the Pine Script™ runtime. Using this parameter is only necessary when a runtime error occurs because automatic detection fails. More information on the underlying mechanics of the historical buffer can be found {html_markup_1}in our Help Center{html_markup_2}. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://www.tradingview.com/chart/?solution=43000587849">',
                                    html_markup_2: "</a>"
                                }),
                                type: "const int"
                            }, {
                                name: "timeframe",
                                info: a('Adds multi-timeframe functionality to simple scripts. When used, a "Timeframe" field will be added to the script\'s "Settings/Inputs" tab. The field\'s default value will be the argument supplied, whose format must conform to {html_markup_1}timeframe string specifications{html_markup_2}. To specify the chart\'s timeframe, use an empty string or the {@var timeframe.period} variable. The parameter cannot be used with scripts using Pine Script™ drawings. Optional. The default is {@var timeframe.period}.', {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Timeframes.html#timeframe-string-specifications">',
                                    html_markup_2: "</a>"
                                }),
                                type: "const string"
                            }, {
                                name: "max_lines_count",
                                info: a("The number of last {@op line} drawings displayed. Possible values: 1-500. Optional. The default is 50.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "max_labels_count",
                                info: a("The number of last {@op label} drawings displayed. Possible values: 1-500. Optional. The default is 50.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "timeframe_gaps",
                                info: a('Specifies how the indicator\'s values are displayed on chart bars when the `timeframe` is higher than the chart\'s. If {@op true}, a value only appears on a chart bar when the higher `timeframe` value becomes available, otherwise {@var na} is returned (thus a "gap" occurs). With {@op false}, what would otherwise be gaps are filled with the latest known value returned, avoiding {@op na} values. When used, a "Gaps" checkbox will appear in the indicator\'s "Settings/Inputs" tab. Optional. The default is {@op true}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "max_boxes_count",
                                info: a("The number of last {@op box} drawings displayed. Possible values: 1-500. Optional. The default is 50.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "explicit_plot_zorder",
                                info: a("Specifies the order in which the script's plots, fills, and hlines are rendered. If {@op true}, plots are drawn in the order in which they appear in the script's code, each newer plot being drawn above the previous ones. This only applies to `plot*()` functions, {@fun fill}, and {@fun hline}. Optional. The default is {@op false}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }],
                            remarks: [a("Every indicator script must have one {@fun indicator} call.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("My script", shorttitle="Script")', "plot(close)"],
                            seeAlso: ["{@fun strategy}", "{@fun library}"],
                            syntax: ["indicator(title, shorttitle, overlay, format, precision, scale, max_bars_back, timeframe, timeframe_gaps, explicit_plot_zorder, max_lines_count, max_labels_count, max_boxes_count) → void"]
                        },
                        plot: {
                            kind: "Built-in annotation function",
                            desc: [a("Plots a series of data on the chart.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "series",
                                info: a("Series of data to be plotted. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "title",
                                info: a("Title of the plot.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "color",
                                info: a("Color of the plot. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "linewidth",
                                info: a("Width of the plotted line. Default value is 1. Not applicable to every style.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }, {
                                name: "style",
                                info: a("Type of plot. Possible values are: {@var plot.style_line}, {@var plot.style_stepline}, {@var plot.style_stepline_diamond}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_columns}, {@var plot.style_circles}, {@var plot.style_linebr}, {@var plot.style_areabr}. Default value is {@var plot.style_line}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "plot_style"
                            }, {
                                name: "trackprice",
                                info: a("If true then a horizontal price line will be shown at the level of the last indicator value. Default is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input bool"
                            }, {
                                name: "histbase",
                                info: a("The price value used as the reference level when rendering plot with {@var plot.style_histogram}, {@var plot.style_columns} or {@var plot.style_area} style. Default is 0.0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int/float"
                            }, {
                                name: "offset",
                                info: a("Shifts the plot to the left or to the right on the given number of bars. Default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "join",
                                info: a("If true then plot points will be joined with line, applicable only to {@var plot.style_cross} and {@var plot.style_circles} styles. Default is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input bool"
                            }, {
                                name: "editable",
                                info: a("If true then plot style will be editable in Format dialog. Default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "show_last",
                                info: a("If set, defines the number of bars (from the last bar back to the past) to plot on chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }, {
                                name: "display",
                                info: a("Controls where the plot's information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot's information everywhere except in the script's status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line. When `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. Possible values: {@var display.none}, {@var display.pane}, {@var display.data_window}, {@var display.price_scale}, {@var display.status_line}, {@var display.all}. Optional. The default is {@var display.all}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "plot_display"
                            }],
                            returns: [a("A plot object, that can be used in {@fun fill}", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("plot")', "plot(high+low, title='Title', color=color.new(#00ffaa, 70), linewidth=2, style=plot.style_area, offset=15, trackprice=true)", "", "// You may fill the background between any two plots with a fill() function:", "p1 = plot(open)", "p2 = plot(close)", "fill(p1, p2, color=color.new(color.green, 90))"],
                            seeAlso: ["{@fun plotshape}, {@fun plotchar}, {@fun plotarrow}, {@fun barcolor}, {@fun bgcolor}, {@fun fill}"],
                            syntax: ["plot(series, title, color, linewidth, style, trackprice, histbase, offset, join, editable, show_last, display) → plot"]
                        },
                        plotshape: {
                            kind: "Built-in annotation function",
                            desc: [a("Plots visual shapes on the chart.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "series",
                                info: a("Series of data to be plotted as shapes. Series is treated as a series of boolean values for all location values except {@var location.absolute}. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }, {
                                name: "title",
                                info: a("Title of the plot.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "style",
                                info: a("Type of plot. Possible values are: {@var shape.xcross}, {@var shape.cross}, {@var shape.triangleup}, {@var shape.triangledown}, {@var shape.flag}, {@var shape.circle}, {@var shape.arrowup}, {@var shape.arrowdown}, {@var shape.labelup}, {@var shape.labeldown}, {@var shape.square}, {@var shape.diamond}. Default value is {@var shape.xcross}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input string"
                            }, {
                                name: "location",
                                info: a("Location of shapes on the chart. Possible values are: {@var location.abovebar}, {@var location.belowbar}, {@var location.top}, {@var location.bottom}, {@var location.absolute}. Default value is {@var location.abovebar}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input string"
                            }, {
                                name: "color",
                                info: a("Color of the shapes. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "offset",
                                info: a("Shifts shapes to the left or to the right on the given number of bars. Default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "text",
                                info: a("Text to display with the shape. You can use multiline text, to separate lines use '\\n' escape sequence. Example: 'line one\\nline two'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "textcolor",
                                info: a("Color of the text. You can use constants like 'textcolor=color.red' or 'textcolor=#ff001a' as well as complex expressions like 'textcolor = close >= open ? color.green : color.red'. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "editable",
                                info: a("If true then plotshape style will be editable in Format dialog. Default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "show_last",
                                info: a("If set, defines the number of shapes (from the last bar back to the past) to plot on chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }, {
                                name: "size",
                                info: a("Size of shapes on the chart. Possible values are: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}. Default is {@var size.auto}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "display",
                                info: a("Controls where the plot's information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot's information everywhere except in the script's status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line. When `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. Possible values: {@var display.none}, {@var display.pane}, {@var display.data_window}, {@var display.price_scale}, {@var display.status_line}, {@var display.all}. Optional. The default is {@var display.all}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "plot_display"
                            }],
                            remarks: [a("Use {@fun plotshape} function in conjunction with 'overlay=true' {@fun indicator} parameter!", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("plotshape example 1", overlay=true)', "data = close >= open", "plotshape(data, style=shape.xcross)"],
                            seeAlso: ["{@fun plot}, {@fun plotchar}, {@fun plotarrow}, {@fun barcolor}, {@fun bgcolor}"],
                            syntax: ["plotshape(series, title, style, location, color, offset, text, textcolor, editable, size, show_last, display) → void"]
                        },
                        plotchar: {
                            kind: "Built-in annotation function",
                            desc: [a("Plots visual shapes using any given one Unicode character on the chart.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "series",
                                info: a("Series of data to be plotted as shapes. Series is treated as a series of boolean values for all location values except {@var location.absolute}. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }, {
                                name: "title",
                                info: a("Title of the plot.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "char",
                                info: a("Character to use as a visual shape.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input string"
                            }, {
                                name: "location",
                                info: a("Location of shapes on the chart. Possible values are: {@var location.abovebar}, {@var location.belowbar}, {@var location.top}, {@var location.bottom}, {@var location.absolute}. Default value is {@var location.abovebar}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input string"
                            }, {
                                name: "color",
                                info: a("Color of the shapes. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "offset",
                                info: a("Shifts shapes to the left or to the right on the given number of bars. Default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "text",
                                info: a("Text to display with the shape. You can use multiline text, to separate lines use '\\n' escape sequence. Example: 'line one\\nline two'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "textcolor",
                                info: a("Color of the text. You can use constants like 'textcolor=color.red' or 'textcolor=#ff001a' as well as complex expressions like 'textcolor = close >= open ? color.green : color.red'. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "editable",
                                info: a("If true then plotchar style will be editable in Format dialog. Default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "show_last",
                                info: a("If set, defines the number of chars (from the last bar back to the past) to plot on chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }, {
                                name: "size",
                                info: a("Size of characters on the chart. Possible values are: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}. Default is {@var size.auto}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "display",
                                info: a("Controls where the plot's information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot's information everywhere except in the script's status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line. When `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. Possible values: {@var display.none}, {@var display.pane}, {@var display.data_window}, {@var display.price_scale}, {@var display.status_line}, {@var display.all}. Optional. The default is {@var display.all}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "plot_display"
                            }],
                            remarks: [a("Use {@fun plotchar} function in conjunction with 'overlay=true' {@fun indicator} parameter!", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("plotchar example", overlay=true)', "data = close >= open", "plotchar(data, char='❄')"],
                            seeAlso: ["{@fun plot}, {@fun plotshape}, {@fun plotarrow}, {@fun barcolor}, {@fun bgcolor}"],
                            syntax: ["plotchar(series, title, char, location, color, offset, text, textcolor, editable, size, show_last, display) → void"]
                        },
                        plotarrow: {
                            kind: "Built-in annotation function",
                            desc: [a("Plots up and down arrows on the chart. Up arrow is drawn at every indicator positive value, down arrow is drawn at every negative value. If indicator returns {@var na} then no arrow is drawn. Arrows has different height, the more absolute indicator value the longer arrow is drawn.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "series",
                                info: a("Series of data to be plotted as arrows. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "title",
                                info: a("Title of the plot.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "colorup",
                                info: a("Color of the up arrows. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "colordown",
                                info: a("Color of the down arrows. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "offset",
                                info: a("Shifts arrows to the left or to the right on the given number of bars. Default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "minheight",
                                info: a("Minimal possible arrow height in pixels. Default is 5.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }, {
                                name: "maxheight",
                                info: a("Maximum possible arrow height in pixels. Default is 100.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }, {
                                name: "editable",
                                info: a("If true then plotarrow style will be editable in Format dialog. Default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "show_last",
                                info: a("If set, defines the number of arrows (from the last bar back to the past) to plot on chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }, {
                                name: "display",
                                info: a("Controls where the plot's information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot's information everywhere except in the script's status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line. When `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. Possible values: {@var display.none}, {@var display.pane}, {@var display.data_window}, {@var display.price_scale}, {@var display.status_line}, {@var display.all}. Optional. The default is {@var display.all}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "plot_display"
                            }],
                            remarks: [a("Use {@fun plotarrow} function in conjunction with 'overlay=true' {@fun indicator} parameter!", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("plotarrow example", overlay=true)', "codiff = close - open", "plotarrow(codiff, colorup=color.new(color.teal,40), colordown=color.new(color.orange, 40))"],
                            seeAlso: ["{@fun plot}, {@fun plotshape}, {@fun plotchar}, {@fun barcolor}, {@fun bgcolor}"],
                            syntax: ["plotarrow(series, title, colorup, colordown, offset, minheight, maxheight, editable, show_last, display) → void"]
                        },
                        plotbar: {
                            kind: "Built-in annotation function",
                            desc: [a("Plots ohlc bars on the chart.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "open",
                                info: a("Open series of data to be used as open values of bars. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "high",
                                info: a("High series of data to be used as high values of bars. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "low",
                                info: a("Low series of data to be used as low values of bars. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "close",
                                info: a("Close series of data to be used as close values of bars. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "title",
                                info: a("Title of the plotbar. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "color",
                                info: a("Color of the ohlc bars. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "editable",
                                info: a("If true then plotbar style will be editable in Format dialog. Default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "show_last",
                                info: a("If set, defines the number of bars (from the last bar back to the past) to plot on chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }, {
                                name: "display",
                                info: a("Controls where the plot's information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot's information everywhere except in the script's status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line. When `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. Possible values: {@var display.none}, {@var display.pane}, {@var display.data_window}, {@var display.price_scale}, {@var display.status_line}, {@var display.all}. Optional. The default is {@var display.all}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "plot_display"
                            }],
                            remarks: [a("Even if one value of open, high, low or close equal NaN then bar no draw.", {
                                context: "pine_docs_remarks"
                            }), a("The maximal value of open, high, low or close will be set as 'high', and the minimal value will be set as 'low'.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("plotbar example", overlay=true)', "plotbar(open, high, low, close, title='Title', color = open < close ? color.green : color.red)"],
                            seeAlso: ["{@fun plotcandle}"],
                            syntax: ["plotbar(open, high, low, close, title, color, editable, show_last, display) → void"]
                        },
                        plotcandle: {
                            kind: "Built-in annotation function",
                            desc: [a("Plots candles on the chart.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "open",
                                info: a("Open series of data to be used as open values of candles. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "high",
                                info: a("High series of data to be used as high values of candles. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "low",
                                info: a("Low series of data to be used as low values of candles. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "close",
                                info: a("Close series of data to be used as close values of candles. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "title",
                                info: a("Title of the plotcandles. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "color",
                                info: a("Color of the candles. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "wickcolor",
                                info: a("The color of the wick of candles. An optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "editable",
                                info: a("If true then plotcandle style will be editable in Format dialog. Default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "show_last",
                                info: a("If set, defines the number of candles (from the last bar back to the past) to plot on chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }, {
                                name: "bordercolor",
                                info: a("The border color of candles. An optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "display",
                                info: a("Controls where the plot's information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot's information everywhere except in the script's status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line. When `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. Possible values: {@var display.none}, {@var display.pane}, {@var display.data_window}, {@var display.price_scale}, {@var display.status_line}, {@var display.all}. Optional. The default is {@var display.all}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "plot_display"
                            }],
                            remarks: [a("Even if one value of open, high, low or close equal NaN then bar no draw.", {
                                context: "pine_docs_remarks"
                            }), a("The maximal value of open, high, low or close will be set as 'high', and the minimal value will be set as 'low'.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("plotcandle example", overlay=true)', "plotcandle(open, high, low, close, title='Title', color = open < close ? color.green : color.red, wickcolor=color.black)"],
                            seeAlso: ["{@fun plotbar}"],
                            syntax: ["plotcandle(open, high, low, close, title, color, wickcolor, editable, show_last, bordercolor, display) → void"]
                        },
                        barcolor: {
                            kind: "Built-in annotation function",
                            desc: [a("Set color of bars.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "color",
                                info: a("Color of bars. You can use constants like 'red' or '#ff001a' as well as complex expressions like 'close >= open ? color.green : color.red'. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "offset",
                                info: a("Shifts the color series to the left or to the right on the given number of bars. Default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "editable",
                                info: a("If true then barcolor style will be editable in Format dialog. Default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "show_last",
                                info: a("If set, defines the number of bars (from the last bar back to the past) to fill on chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }, {
                                name: "title",
                                info: a("Title of the barcolor. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "display",
                                info: a("Controls where the barcolor is displayed. Possible values are: {@var display.none}, {@var display.all}. Default is {@var display.all}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "plot_simple_display"
                            }],
                            examples: ["//@version=5", 'indicator("barcolor example", overlay=true)', "barcolor(close < open ? color.black : color.white)"],
                            seeAlso: ["{@fun bgcolor}, {@fun plot}, {@fun fill}"],
                            syntax: ["barcolor(color, offset, editable, show_last, title, display) → void"]
                        },
                        bgcolor: {
                            kind: "Built-in annotation function",
                            desc: [a("Fill background of bars with specified color.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "color",
                                info: a("Color of the filled background. You can use constants like 'red' or '#ff001a' as well as complex expressions like 'close >= open ? color.green : color.red'. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "offset",
                                info: a("Shifts the color series to the left or to the right on the given number of bars. Default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "editable",
                                info: a("If true then bgcolor style will be editable in Format dialog. Default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "show_last",
                                info: a("If set, defines the number of bars (from the last bar back to the past) to fill on chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }, {
                                name: "title",
                                info: a("Title of the bgcolor. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "display",
                                info: a("Controls where the bgcolor is displayed. Possible values are: {@var display.none}, {@var display.all}. Default is {@var display.all}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "plot_simple_display"
                            }],
                            examples: ["//@version=5", 'indicator("bgcolor example", overlay=true)', "bgcolor(close < open ? color.new(color.red,70) : color.new(color.green, 70))"],
                            seeAlso: ["{@fun barcolor}, {@fun plot}, {@fun fill}"],
                            syntax: ["bgcolor(color, offset, editable, show_last, title, display) → void"]
                        },
                        "color.new": {
                            kind: "Built-in function",
                            desc: [a("Function color applies the specified transparency to the given color.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Color with specified transparency.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "color",
                                type: "series color"
                            }, {
                                name: "transp",
                                info: a("Possible values are from 0 (not transparent) to 100 (invisible).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            examples: ["//@version=5", 'indicator("color.new", overlay=true)', "plot(close, color=color.new(color.red, 50))"],
                            remarks: [a("Using arguments that are not constants (e.g., 'simple', 'input' or 'series') will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the {html_markup_1}User Manual{html_markup_2} for more information.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Colors.html#stylecolors">',
                                html_markup_2: "</a>"
                            })],
                            syntax: ["color.new(color, transp) → const color", "color.new(color, transp) → series color", "color.new(color, transp) → input color"]
                        },
                        "color.rgb": {
                            kind: "Built-in function",
                            desc: [a("Creates a new color with transparency using the RGB color model.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Color with specified transparency.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "red",
                                info: a("Red color component. Possible values are from 0 to 255.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "green",
                                info: a("Green color component. Possible values are from 0 to 255.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "blue",
                                info: a("Blue color component. Possible values are from 0 to 255.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "transp",
                                info: a("Optional. Color transparency. Possible values are from 0 (opaque) to 100 (invisible). Default value is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            examples: ["//@version=5", 'indicator("color.rgb", overlay=true)', "plot(close, color=color.rgb(255, 0, 0, 50))"],
                            remarks: [a("Using arguments that are not constants (e.g., 'simple', 'input' or 'series') will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the {html_markup_1}User Manual{html_markup_2} for more information.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Colors.html#stylecolors">',
                                html_markup_2: "</a>"
                            })],
                            syntax: ["color.rgb(red, green, blue, transp) → series color", "color.rgb(red, green, blue, transp) → const color", "color.rgb(red, green, blue, transp) → input color"]
                        },
                        "color.r": {
                            kind: "Built-in function",
                            desc: [a("Retrieves the value of the color's red component.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The value (0 to 255) of the color's red component.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "color",
                                info: a("Color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            examples: ["//@version=5", 'indicator("color.r", overlay=true)', "plot(color.r(color.red))"],
                            syntax: ["color.r(color) → series float", "color.r(color) → const float", "color.r(color) → input float"]
                        },
                        "color.g": {
                            kind: "Built-in function",
                            desc: [a("Retrieves the value of the color's green component.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The value (0 to 255) of the color's green component.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "color",
                                info: a("Color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            examples: ["//@version=5", 'indicator("color.g", overlay=true)', "plot(color.g(color.green))"],
                            syntax: ["color.g(color) → series float", "color.g(color) → const float", "color.g(color) → input float"]
                        },
                        "color.b": {
                            kind: "Built-in function",
                            desc: [a("Retrieves the value of the color's blue component.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The value (0 to 255) of the color's blue component.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "color",
                                info: a("Color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            examples: ["//@version=5", 'indicator("color.b", overlay=true)', "plot(color.b(color.blue))"],
                            syntax: ["color.b(color) → series float", "color.b(color) → const float", "color.b(color) → input float"]
                        },
                        "color.t": {
                            kind: "Built-in function",
                            desc: [a("Retrieves the color's transparency.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The value (0-100) of the color's transparency.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "color",
                                info: a("Color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            examples: ["//@version=5", 'indicator("color.t", overlay=true)', "plot(color.t(color.new(color.red, 50)))"],
                            syntax: ["color.t(color) → series float", "color.t(color) → const float", "color.t(color) → input float"]
                        },
                        "color.from_gradient": {
                            kind: "Built-in function",
                            desc: [a("Based on the relative position of value in the bottom_value to top_value range, the function returns a color from the gradient defined by bottom_color to top_color.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("A color calculated from the linear gradient between bottom_color to top_color.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "value",
                                info: a("Value to calculate the position-dependent color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "bottom_value",
                                info: a("Bottom position value corresponding to bottom_color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "top_value",
                                info: a("Top position value corresponding to top_color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "bottom_color",
                                info: a("Bottom position color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "top_color",
                                info: a("Top position color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            examples: ["//@version=5", 'indicator("color.from_gradient", overlay=true)', "color1 = color.from_gradient(close, low, high, color.yellow, color.lime)", "color2 = color.from_gradient(ta.rsi(close, 7), 0, 100, color.rgb(255, 0, 0), color.rgb(0, 255, 0, 50))", "plot(close, color=color1)", "plot(ta.rsi(close,7), color=color2)"],
                            remarks: [a('Using this function will have an impact on the colors displayed in the script\'s "Settings/Style" tab. See the {html_markup_1}User Manual{html_markup_2} for more information.', {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Colors.html#stylecolors">',
                                html_markup_2: "</a>"
                            })],
                            syntax: ["color.from_gradient(value, bottom_value, top_value, bottom_color, top_color) → series color"]
                        },
                        alertcondition: {
                            kind: "Built-in annotation function",
                            desc: [a("Creates alert condition, that is available in Create Alert dialog. Please note, that {@fun alertcondition} does NOT create an alert, it just gives you more options in Create Alert dialog. Also, {@fun alertcondition} effect is invisible on chart.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "condition",
                                info: a("Series of boolean values that is used for alert. True values mean alert fire, false - no alert. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }, {
                                name: "title",
                                info: a("Title of the alert condition. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "message",
                                info: a("Message to display when alert fires. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }],
                            examples: ["//@version=5", 'indicator("alertcondition", overlay=true)', "alertcondition(close >= open, title='Alert on Green Bar', message='Green Bar!')"],
                            remarks: [a("Please note that an alertcondition call generates an additional plot. All such calls are taken into account when we calculate the number of the output series per script.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun alert}"],
                            syntax: ["alertcondition(condition, title, message) → void"]
                        },
                        input: {
                            kind: "Built-in annotation function",
                            desc: [a("Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function automatically detects the type of the argument used for 'defval' and uses the corresponding input widget.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Value of input variable.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "defval",
                                type: "const int/float/bool/string/color or source-type built-ins",
                                info: a('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where script users can change it. Source-type built-ins are built-in series float variables that specify the source of the calculation: `close`, `hlc3`, etc.', {
                                    context: "pine_docs_args_info"
                                })
                            }, {
                                name: "title",
                                info: a("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "tooltip",
                                info: a("The string that will be shown to the user when hovering over the tooltip icon.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "inline",
                                info: a("Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "group",
                                info: a("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }],
                            remarks: [a("Result of {@fun input} function always should be assigned to a variable, see examples above.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("input", overlay=true)', 'i_switch = input(true, "On/Off")', "plot(i_switch ? open : na)", "", 'i_len = input(7, "Length")', 'i_src = input(close, "Source")', "plot(ta.sma(i_src, i_len))", "", 'i_border = input(142.50, "Price Border")', "hline(i_border)", "bgcolor(close > i_border ? color.green : color.red)", "", 'i_col = input(color.red, "Plot Color")', "plot(close, color=i_col)", "", 'i_text = input("Hello!", "Message")', "l = label.new(bar_index, high, text=i_text)", "label.delete(l[1])"],
                            seeAlso: ["{@fun input.bool}, {@fun input.color}, {@fun input.int}, {@fun input.float}, {@fun input.string}, {@fun input.symbol}, {@fun input.timeframe}, {@fun input.text_area}, {@fun input.session}, {@fun input.source}, {@fun input.time}"],
                            syntax: ["input(defval, title, tooltip, inline, group) → input bool", "input(defval, title, tooltip, inline, group) → input color", "input(defval, title, tooltip, inline, group) → input int", "input(defval, title, tooltip, inline, group) → input float", "input(defval, title, tooltip, inline, group) → input string", "input(defval, title, inline, group, tooltip) → series float"]
                        },
                        "input.bool": {
                            kind: "Built-in annotation function",
                            desc: [a("Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a checkmark to the script's inputs.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Value of input variable.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "defval",
                                info: a('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where the user can change it.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "title",
                                info: a("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "tooltip",
                                info: a("The string that will be shown to the user when hovering over the tooltip icon.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "inline",
                                info: a("Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "group",
                                info: a("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "confirm",
                                info: a("If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }],
                            remarks: [a("Result of {@fun input.bool} function always should be assigned to a variable, see examples above.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("input.bool", overlay=true)', 'i_switch = input.bool(true, "On/Off")', "plot(i_switch ? open : na)"],
                            seeAlso: ["{@fun input.int}, {@fun input.float}, {@fun input.string}, {@fun input.text_area}, {@fun input.symbol}, {@fun input.timeframe}, {@fun input.session}, {@fun input.source}, {@fun input.color}, {@fun input.time}, {@fun input}"],
                            syntax: ["input.bool(defval, title, tooltip, inline, group, confirm) → input bool"]
                        },
                        "input.int": {
                            kind: "Built-in annotation function",
                            desc: [a("Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for an integer input to the script's inputs.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Value of input variable.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "defval",
                                info: a('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where script users can change it. When a list of values is used with the `options` parameter, the value must be one of them.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "title",
                                info: a("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "minval",
                                info: a("Minimal possible value of the input variable. Optional.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "maxval",
                                info: a("Maximum possible value of the input variable. Optional.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "step",
                                info: a("Step value used for incrementing/decrementing the input. Optional. The default is 1.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "options",
                                type: "tuple of const int values: [val1, val2, ...]",
                                info: a("A list of options to choose from a dropdown menu, separated by commas and enclosed in square brackets: [val1, val2, ...]. When using this parameter, the `minval`, `maxval` and `step` parameters cannot be used.", {
                                    context: "pine_docs_args_info"
                                })
                            }, {
                                name: "tooltip",
                                info: a("The string that will be shown to the user when hovering over the tooltip icon.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "inline",
                                info: a("Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "group",
                                info: a("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "confirm",
                                info: a("If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }],
                            remarks: [a("Result of {@fun input.int} function always should be assigned to a variable, see examples above.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("input.int", overlay=true)', 'i_len1 = input.int(10, "Length 1", minval=5, maxval=21, step=1)', "plot(ta.sma(close, i_len1))", "", 'i_len2 = input.int(10, "Length 2", options=[5, 10, 21])', "plot(ta.sma(close, i_len2))"],
                            seeAlso: ["{@fun input.bool}, {@fun input.float}, {@fun input.string}, {@fun input.text_area}, {@fun input.symbol}, {@fun input.timeframe}, {@fun input.session}, {@fun input.source}, {@fun input.color}, {@fun input.time}, {@fun input}"],
                            syntax: ["input.int(defval, title, minval, maxval, step, tooltip, inline, group, confirm) → input int", "input.int(defval, title, options, tooltip, inline, group, confirm) → input int"]
                        },
                        "input.float": {
                            kind: "Built-in annotation function",
                            desc: [a("Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for a float input to the script's inputs.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Value of input variable.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "defval",
                                info: a('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where script users can change it. When a list of values is used with the `options` parameter, the value must be one of them.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int/float"
                            }, {
                                name: "title",
                                info: a("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "minval",
                                info: a("Minimal possible value of the input variable. Optional.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int/float"
                            }, {
                                name: "maxval",
                                info: a("Maximum possible value of the input variable. Optional.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int/float"
                            }, {
                                name: "step",
                                info: a("Step value used for incrementing/decrementing the input. Optional. The default is 1.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int/float"
                            }, {
                                name: "options",
                                type: "tuple of const int/float values: [val1, val2, ...]",
                                info: a("A list of options to choose from a dropdown menu, separated by commas and enclosed in square brackets: [val1, val2, ...]. When using this parameter, the `minval`, `maxval` and `step` parameters cannot be used.", {
                                    context: "pine_docs_args_info"
                                })
                            }, {
                                name: "tooltip",
                                info: a("The string that will be shown to the user when hovering over the tooltip icon.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "inline",
                                info: a("Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "group",
                                info: a("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "confirm",
                                info: a("If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }],
                            remarks: [a("Result of {@fun input.float} function always should be assigned to a variable, see examples above.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("input.float", overlay=true)', 'i_angle1 = input.float(0.5, "Sin Angle", minval=-3.14, maxval=3.14, step=0.02)', 'plot(math.sin(i_angle1) > 0 ? close : open, "sin", color=color.green)', "", 'i_angle2 = input.float(0, "Cos Angle", options=[-3.14, -1.57, 0, 1.57, 3.14])', 'plot(math.cos(i_angle2) > 0 ? close : open, "cos", color=color.red)'],
                            seeAlso: ["{@fun input.bool}, {@fun input.int}, {@fun input.string}, {@fun input.text_area}, {@fun input.symbol}, {@fun input.timeframe}, {@fun input.session}, {@fun input.source}, {@fun input.color}, {@fun input.time}, {@fun input}"],
                            syntax: ["input.float(defval, title, minval, maxval, step, tooltip, inline, group, confirm) → input float", "input.float(defval, title, options, tooltip, inline, group, confirm) → input float"]
                        },
                        "input.string": {
                            kind: "Built-in annotation function",
                            desc: [a("Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for a string input to the script's inputs.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Value of input variable.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "defval",
                                info: a('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where the user can change it. When a list of values is used with the `options` parameter, the value must be one of them.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "title",
                                info: a("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "options",
                                type: "tuple of const string values: [val1, val2, ...]",
                                info: a("A list of options to choose from.", {
                                    context: "pine_docs_args_info"
                                })
                            }, {
                                name: "tooltip",
                                info: a("The string that will be shown to the user when hovering over the tooltip icon.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "inline",
                                info: a("Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "group",
                                info: a("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "confirm",
                                info: a("If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }],
                            remarks: [a("Result of {@fun input.string} function always should be assigned to a variable, see examples above.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("input.string", overlay=true)', 'i_text = input.string("Hello!", "Message")', "l = label.new(bar_index, high, i_text)", "label.delete(l[1])"],
                            seeAlso: ["{@fun input.text_area}, {@fun input.bool}, {@fun input.int}, {@fun input.float}, {@fun input.symbol}, {@fun input.timeframe}, {@fun input.session}, {@fun input.source}, {@fun input.color}, {@fun input.time}, {@fun input}"],
                            syntax: ["input.string(defval, title, options, tooltip, inline, group, confirm) → input string"]
                        },
                        "input.text_area": {
                            kind: "Built-in annotation function",
                            desc: [a("Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for a multiline text input.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Value of input variable.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "defval",
                                info: a('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where the user can change it.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "title",
                                info: a("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "tooltip",
                                info: a("The string that will be shown to the user when hovering over the tooltip icon.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "group",
                                info: a("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "confirm",
                                info: a("If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }],
                            remarks: [a("Result of {@fun input.text_area} function always should be assigned to a variable, see examples above.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("input.text_area")', 'i_text = input.text_area(defval = "Hello \\nWorld!", title = "Message")', "plot(close)"],
                            seeAlso: ["{@fun input.string}, {@fun input.bool}, {@fun input.int}, {@fun input.float}, {@fun input.symbol}, {@fun input.timeframe}, {@fun input.session}, {@fun input.source}, {@fun input.color}, {@fun input.time}, {@fun input}"],
                            syntax: ["input.text_area(defval, title, tooltip, group, confirm) → input string"]
                        },
                        "input.symbol": {
                            kind: "Built-in annotation function",
                            desc: [a("Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field that allows the user to select a specific symbol using the symbol search and returns that symbol, paired with its exchange prefix, as a string.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Value of input variable.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "defval",
                                info: a('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where the user can change it.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "title",
                                info: a("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "tooltip",
                                info: a("The string that will be shown to the user when hovering over the tooltip icon.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "inline",
                                info: a("Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "group",
                                info: a("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "confirm",
                                info: a("If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }],
                            remarks: [a("Result of {@fun input.symbol} function always should be assigned to a variable, see examples above.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("input.symbol", overlay=true)', 'i_sym = input.symbol("DELL", "Symbol")', "s = request.security(i_sym, 'D', close)", "plot(s)"],
                            seeAlso: ["{@fun input.bool}, {@fun input.int}, {@fun input.float}, {@fun input.string}, {@fun input.text_area}, {@fun input.timeframe}, {@fun input.session}, {@fun input.source}, {@fun input.color}, {@fun input.time}, {@fun input}"],
                            syntax: ["input.symbol(defval, title, tooltip, inline, group, confirm) → input string"]
                        },
                        "input.timeframe": {
                            kind: "Built-in annotation function",
                            desc: [a("Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a dropdown that allows the user to select a specific timeframe via the timeframe selector and returns it as a string. The selector includes the custom timeframes a user may have added using the chart's Timeframe dropdown.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Value of input variable.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "defval",
                                info: a('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where the user can change it. When a list of values is used with the `options` parameter, the value must be one of them.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "title",
                                info: a("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "options",
                                type: "tuple of const string values: [val1, val2, ...]",
                                info: a("A list of options to choose from.", {
                                    context: "pine_docs_args_info"
                                })
                            }, {
                                name: "tooltip",
                                info: a("The string that will be shown to the user when hovering over the tooltip icon.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "inline",
                                info: a("Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "group",
                                info: a("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "confirm",
                                info: a("If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }],
                            remarks: [a("Result of {@fun input.timeframe} function always should be assigned to a variable, see examples above.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("input.timeframe", overlay=true)', "i_res = input.timeframe('D', \"Resolution\", options=['D', 'W', 'M'])", 's = request.security("AAPL", i_res, close)', "plot(s)"],
                            seeAlso: ["{@fun input.bool}, {@fun input.int}, {@fun input.float}, {@fun input.string}, {@fun input.text_area}, {@fun input.symbol}, {@fun input.session}, {@fun input.source}, {@fun input.color}, {@fun input.time}, {@fun input}"],
                            syntax: ["input.timeframe(defval, title, options, tooltip, inline, group, confirm) → input string"]
                        },
                        "input.session": {
                            kind: "Built-in annotation function",
                            desc: [a("Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds two dropdowns that allow the user to specify the beginning and the end of a session using the session selector and returns the result as a string.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Value of input variable.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "defval",
                                info: a('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where the user can change it. When a list of values is used with the `options` parameter, the value must be one of them.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "title",
                                info: a("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "options",
                                type: "tuple of const string values: [val1, val2, ...]",
                                info: a("A list of options to choose from.", {
                                    context: "pine_docs_args_info"
                                })
                            }, {
                                name: "tooltip",
                                info: a("The string that will be shown to the user when hovering over the tooltip icon.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "inline",
                                info: a("Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "group",
                                info: a("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "confirm",
                                info: a("If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }],
                            remarks: [a("Result of {@fun input.session} function always should be assigned to a variable, see examples above.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("input.session", overlay=true)', 'i_sess = input.session("1300-1700", "Session", options=["0930-1600", "1300-1700", "1700-2100"])', "t = time(timeframe.period, i_sess)", "bgcolor(time == t ? color.green : na)"],
                            seeAlso: ["{@fun input.bool}, {@fun input.int}, {@fun input.float}, {@fun input.string}, {@fun input.text_area}, {@fun input.symbol}, {@fun input.timeframe}, {@fun input.source}, {@fun input.color}, {@fun input.time}, {@fun input}"],
                            syntax: ["input.session(defval, title, options, tooltip, inline, group, confirm) → input string"]
                        },
                        "input.source": {
                            kind: "Built-in annotation function",
                            desc: [a("Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a dropdown that allows the user to select a source for the calculation, e.g. {@var close}, {@var hl2}, etc. If the script includes only one input.source() call, the user can also select an output from another indicator on their chart as the source.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Value of input variable.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "defval",
                                info: a('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where the user can change it.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "title",
                                info: a("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "tooltip",
                                info: a("The string that will be shown to the user when hovering over the tooltip icon.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "inline",
                                info: a("Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "group",
                                info: a("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }],
                            remarks: [a("Result of {@fun input.source} function always should be assigned to a variable, see examples above.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("input.source", overlay=true)', 'i_src = input.source(close, "Source")', "plot(i_src)"],
                            seeAlso: ["{@fun input.bool}, {@fun input.int}, {@fun input.float}, {@fun input.string}, {@fun input.text_area}, {@fun input.symbol}, {@fun input.timeframe}, {@fun input.session}, {@fun input.color}, {@fun input.time}, {@fun input}"],
                            syntax: ["input.source(defval, title, tooltip, inline, group) → series float"]
                        },
                        "input.color": {
                            kind: "Built-in annotation function",
                            desc: [a("Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a color picker that allows the user to select a color and transparency, either from a palette or a hex value.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Value of input variable.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "defval",
                                info: a('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where the user can change it.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const color"
                            }, {
                                name: "title",
                                info: a("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "tooltip",
                                info: a("The string that will be shown to the user when hovering over the tooltip icon.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "inline",
                                info: a("Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "group",
                                info: a("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "confirm",
                                info: a("If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }],
                            remarks: [a("Result of {@fun input.color} function always should be assigned to a variable, see examples above.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("input.color", overlay=true)', 'i_col = input.color(color.red, "Plot Color")', "plot(close, color=i_col)"],
                            seeAlso: ["{@fun input.bool}, {@fun input.int}, {@fun input.float}, {@fun input.string}, {@fun input.text_area}, {@fun input.symbol}, {@fun input.timeframe}, {@fun input.session}, {@fun input.source}, {@fun input.time}, {@fun input}"],
                            syntax: ["input.color(defval, title, tooltip, inline, group, confirm) → input color"]
                        },
                        "input.time": {
                            kind: "Built-in annotation function",
                            desc: [a('Adds a time input to the script\'s "Settings/Inputs" tab. This function adds two input widgets on the same line: one for the date and one for the time. The function returns a date/time value in UNIX format. Using `confirm = true` activates the interactive input mode where a point in time is selected by clicking on the chart.', {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Value of input variable.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "defval",
                                info: a('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where the user can change it. The value can be a {@fun timestamp} function, but only if it uses a date argument in const string format.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "title",
                                info: a("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "tooltip",
                                info: a("The string that will be shown to the user when hovering over the tooltip icon.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "inline",
                                info: a("Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "group",
                                info: a("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "confirm",
                                info: a("If true, the interactive input mode is enabled and the selection is done by clicking on the chart when the indicator is added to the chart, or by selecting the indicator and moving the selection after that. Optional. The default is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }],
                            remarks: [a("When using interactive mode, a price input can be combined with a time input if both function calls use the same argument for their `inline` parameter.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("input.time", overlay=true)', 'i_date = input.time(timestamp("20 Jul 2021 00:00 +0300"), "Date")', 'l = label.new(i_date, high, "Date", xloc=xloc.bar_time)', "label.delete(l[1])"],
                            seeAlso: ["{@fun input.bool}, {@fun input.int}, {@fun input.float}, {@fun input.string}, {@fun input.text_area}, {@fun input.symbol}, {@fun input.timeframe}, {@fun input.session}, {@fun input.source}, {@fun input.color}, {@fun input}"],
                            syntax: ["input.time(defval, title, tooltip, inline, group, confirm) → input int"]
                        },
                        "input.price": {
                            kind: "Built-in annotation function",
                            desc: [a('Adds a price input to the script\'s "Settings/Inputs" tab. Using `confirm = true` activates the interactive input mode where a price is selected by clicking on the chart.', {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Value of input variable.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "defval",
                                info: a('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where the user can change it.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int/float"
                            }, {
                                name: "title",
                                info: a("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "tooltip",
                                info: a("The string that will be shown to the user when hovering over the tooltip icon.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "inline",
                                info: a("Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "group",
                                info: a("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "confirm",
                                info: a("If true, the interactive input mode is enabled and the selection is done by clicking on the chart when the indicator is added to the chart, or by selecting the indicator and moving the selection after that. Optional. The default is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }],
                            remarks: [a("When using interactive mode, a time input can be combined with a price input if both function calls use the same argument for their `inline` parameter.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("input.price", overlay=true)', 'price1 = input.price(title="Date", defval=42)', "plot(price1)", "", 'price2 = input.price(54, title="Date")', "plot(price2)"],
                            seeAlso: ["{@fun input.bool}, {@fun input.int}, {@fun input.float}, {@fun input.string}, {@fun input.text_area}, {@fun input.symbol}, {@fun input.resolution}, {@fun input.session}, {@fun input.source}, {@fun input.color}, {@fun input}"],
                            syntax: ["input.price(defval, title, tooltip, inline, group, confirm) → input float"]
                        },
                        hline: {
                            kind: "Built-in annotation function",
                            desc: [a("Renders a horizontal line at a given fixed price level.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "price",
                                info: a("Price value at which the object will be rendered. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int/float"
                            }, {
                                name: "title",
                                info: a("Title of the object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "color",
                                info: a("Color of the rendered line. Must be a constant value (not an expression). Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input color"
                            }, {
                                name: "linestyle",
                                info: a("Style of the rendered line. Possible values are: {@var hline.style_solid}, {@var hline.style_dotted}, {@var hline.style_dashed}. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "hline_style"
                            }, {
                                name: "linewidth",
                                info: a("Width of the rendered line. Default value is 1.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }, {
                                name: "editable",
                                info: a("If true then hline style will be editable in Format dialog. Default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "display",
                                info: a("Controls where the hline is displayed. Possible values are: {@var display.none}, {@var display.all}. Default is {@var display.all}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "plot_simple_display"
                            }],
                            returns: [a("An hline object, that can be used in {@fun fill}", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("input.hline", overlay=true)', "hline(3.14, title='Pi', color=color.blue, linestyle=hline.style_dotted, linewidth=2)", "", "// You may fill the background between any two hlines with a fill() function:", "h1 = hline(20)", "h2 = hline(10)", "fill(h1, h2, color=color.new(color.green, 90))"],
                            seeAlso: ["{@fun fill}"],
                            syntax: ["hline(price, title, color, linestyle, linewidth, editable, display) → hline"]
                        },
                        fill: {
                            kind: "Built-in annotation function",
                            desc: [a("Fills background between two plots or hlines with a given color.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "hline1",
                                info: a("The first hline object. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "hline"
                            }, {
                                name: "hline2",
                                info: a("The second hline object. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "hline"
                            }, {
                                name: "plot1",
                                info: a("The first plot object. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "plot"
                            }, {
                                name: "plot2",
                                info: a("The second plot object. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "plot"
                            }, {
                                name: "color",
                                info: a("Color of the plot. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "title",
                                info: a("Title of the created fill object. Optional argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "editable",
                                info: a("If true then fill style will be editable in Format dialog. Default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "show_last",
                                info: a("If set, defines the number of bars (from the last bar back to the past) to fill on chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }, {
                                name: "fillgaps",
                                info: a("Controls continuing fills on gaps, i.e., when one of the plot() calls returns an na value. When true, the last fill will continue on gaps. The default is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "display",
                                info: a("Controls where the fill is displayed. Possible values are: {@var display.none}, {@var display.all}. Default is {@var display.all}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "plot_simple_display"
                            }],
                            examples: ["//@version=5", 'indicator("fill", overlay=true)', "h1 = hline(20)", "h2 = hline(10)", "fill(h1, h2, color=color.new(color.blue, 90))", "", "p1 = plot(open)", "p2 = plot(close)", "fill(p1, p2, color=color.new(color.green, 90))"],
                            seeAlso: ["{@fun plot}, {@fun barcolor}, {@fun bgcolor}, {@fun hline}"],
                            syntax: ["fill(hline1, hline2, color, title, editable, fillgaps, display) → void", "fill(plot1, plot2, color, title, editable, show_last, fillgaps, display) → void"]
                        },
                        nz: {
                            kind: "Built-in function",
                            desc: [a("Replaces NaN values with zeros (or given value) in a series.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float/bool/color"
                            }, {
                                name: "replacement",
                                info: a("Value that will replace all ‘na’ values in the `source` series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float/bool/color"
                            }],
                            examples: ["//@version=5", 'indicator("nz", overlay=true)', "plot(nz(ta.sma(close, 100)))"],
                            seeAlso: ["{@var na} (variable), {@fun na}, {@fun fixnan}"],
                            syntax: ["nz(source, replacement) → simple int", "nz(source, replacement) → simple float", "nz(source, replacement) → simple color", "nz(source, replacement) → simple bool", "nz(source, replacement) → series int", "nz(source, replacement) → series float", "nz(source, replacement) → series color", "nz(source, replacement) → series bool", "nz(source) → simple int", "nz(source) → simple float", "nz(source) → simple color", "nz(source) → simple bool", "nz(source) → series int", "nz(source) → series float", "nz(source) → series color", "nz(source) → series bool"]
                        },
                        na: {
                            kind: "Built-in function",
                            desc: [a("Tests if `x` is {@var na}.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "x",
                                info: a("Value to be tested.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float/bool/color/string/label/line/box/linefill"
                            }],
                            examples: ["//@version=5", 'indicator("")', "// Use the `na()` function to test for `na`.", "plot(na(close[1]) ? close : close[1])", "// ALTERNATIVE", "// `nz()` also tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.", "plot(nz(close[1], close))"],
                            returns: [a("Returns {@op true} if `x` is {@var na}, {@op false} otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@var na}, {@fun fixnan}, {@fun nz}"],
                            syntax: ["na(x) → simple bool", "na(x) → series bool", "na(x) → series linefill"]
                        },
                        "ta.tr": {
                            kind: "Built-in function",
                            returns: [a("True range. It is math.max(high - low, math.abs(high - close[1]), math.abs(low - close[1])).", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "handle_na",
                                info: a("How NaN values are handled. if true, and previous day's close is NaN then tr would be calculated as current day high-low. Otherwise (if false) tr would return NaN in such cases. Also note, that {@fun ta.atr} uses ta.tr(true).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple bool"
                            }],
                            remarks: [a("ta.tr(false) is exactly the same as {@var ta.tr}.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var ta.tr} (variable), {@fun ta.atr}"],
                            syntax: ["ta.tr(handle_na) → series float"]
                        },
                        "math.pow": {
                            kind: "Built-in function",
                            desc: [a("Mathematical power function.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("`base` raised to the power of `exponent`. If `base` is a series, it is calculated elementwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "base",
                                info: a("Specify the base to use.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "exponent",
                                info: a("Specifies the exponent.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            examples: ["//@version=5", 'indicator("math.pow", overlay=true)', "plot(math.pow(close, 2))"],
                            seeAlso: ["{@fun math.sqrt}, {@fun math.exp}"],
                            syntax: ["math.pow(base, exponent) → simple float", "math.pow(base, exponent) → input float", "math.pow(base, exponent) → const float", "math.pow(base, exponent) → series float"]
                        },
                        "math.min": {
                            desc: [a("Returns the smallest of multiple values.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The smallest of multiple given values.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun math.max}"],
                            examples: ["//@version=5", 'indicator("math.min", overlay=true)', "plot(math.min(close, open))", "plot(math.min(close, math.min(open, 42)))"],
                            syntax: ["math.min(number0, number1, ...) → simple int", "math.min(number0, number1, ...) → simple float", "math.min(number0, number1, ...) → input int", "math.min(number0, number1, ...) → input float", "math.min(number0, number1, ...) → series int", "math.min(number0, number1, ...) → series float"]
                        },
                        "math.max": {
                            kind: "Built-in function",
                            desc: [a("Returns the greatest of multiple values.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The greatest of multiple given values.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun math.min}"],
                            examples: ["//@version=5", 'indicator("math.max", overlay=true)', "plot(math.max(close, open))", "plot(math.max(close, math.max(open, 42)))"],
                            syntax: ["math.max(number0, number1, ...) → simple int", "math.max(number0, number1, ...) → simple float", "math.max(number0, number1, ...) → input int", "math.max(number0, number1, ...) → input float", "math.max(number0, number1, ...) → series int", "math.max(number0, number1, ...) → series float"]
                        },
                        "str.format": {
                            kind: "Built-in function",
                            desc: [a("Converts the formatting string and value(s) into a formatted string. The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the str.format argument list.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "formatString",
                                info: a("Format string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "arg0, arg1, ...",
                                info: a("Values to format.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float/bool/string/na/int[]/float[]/bool[]/string[]"
                            }],
                            remarks: [a('Any curly braces within an unquoted pattern must be balanced. For example, "ab {0} de" and "ab \'}\' de" are valid patterns, but "ab {0\'}\' de", "ab } de" and "\'\'{\'\'" are not.', {
                                context: "pine_docs_remarks"
                            })],
                            returns: [a("The formatted string.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("str.format", overlay=true)', "// The format specifier inside the curly braces accepts certain modifiers:", "// - Specify the number of decimals to display:", 's1 = str.format("{0,number,#.#}", 1.34) // returns: 1.3', "label.new(bar_index, close, text=s1)", "// - Round a float value to an integer:", 's2 = str.format("{0,number,integer}", 1.34) // returns: 1', "label.new(bar_index - 1, close, text=s2)", "// - Display a number in currency:", 's3 = str.format("{0,number,currency}", 1.34) // returns: $1.34', "label.new(bar_index - 2, close, text=s3)", "// - Display a number as a percentage:", 's4 = str.format("{0,number,percent}", 0.5) // returns: 50%', "label.new(bar_index - 3, close, text=s4)", "// EXAMPLES WITH SEVERAL ARGUMENTS", "// returns: Number 1 is not equal to 4", 's5 = str.format("Number {0} is not {1} to {2}", 1, "equal", 4)', "label.new(bar_index - 4, close, text=s5)", "// returns: 1.34 != 1.3", 's6 = str.format("{0} != {0, number, #.#}", 1.34)', "label.new(bar_index - 5, close, text=s6)", "// returns: 1 is equal to 1, but 2 is equal to 2", 's7 = str.format("{0, number, integer} is equal to 1, but {1, number, integer} is equal to 2", 1.34, 1.52)', "label.new(bar_index - 6, close, text=s7)", "// returns: The cash turnover amounted to $1,340,000.00", 's8 = str.format("The cash turnover amounted to {0, number, currency}", 1340000)', "label.new(bar_index - 7, close, text=s8)", "// returns: Expected return is 10% - 20%", 's9 = str.format("Expected return is {0, number, percent} - {1, number, percent}", 0.1, 0.2)', "label.new(bar_index - 8, close, text=s9)"],
                            syntax: ["str.format(formatString, arg0, arg1, ...) → simple string", "str.format(formatString, arg0, arg1, ...) → series string"]
                        },
                        "math.abs": {
                            desc: [a("Absolute value of `number` is `number` if `number` >= 0, or -`number` otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The absolute value of `number`.", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["math.abs(number) → simple int", "math.abs(number) → input int", "math.abs(number) → const int", "math.abs(number) → series int", "math.abs(number) → simple float", "math.abs(number) → input float", "math.abs(number) → const float", "math.abs(number) → series float"]
                        },
                        "math.log": {
                            desc: [a("Natural logarithm of any `number` > 0 is the unique y such that e^y = `number`.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The natural logarithm of `number`.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun math.log10}"],
                            syntax: ["math.log(number) → simple float", "math.log(number) → input float", "math.log(number) → const float", "math.log(number) → series float"]
                        },
                        "math.log10": {
                            desc: [a("The common (or base 10) logarithm of `number` is the power to which 10 must be raised to obtain the `number`. 10^y = `number`.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The base 10 logarithm of `number`.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun math.log}"],
                            syntax: ["math.log10(number) → simple float", "math.log10(number) → input float", "math.log10(number) → const float", "math.log10(number) → series float"]
                        },
                        "math.sqrt": {
                            desc: [a("Square root of any `number` >= 0 is the unique y >= 0 such that y^2 = `number`.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The square root of `number`.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun math.pow}"],
                            syntax: ["math.sqrt(number) → simple float", "math.sqrt(number) → input float", "math.sqrt(number) → const float", "math.sqrt(number) → series float"]
                        },
                        "math.sign": {
                            desc: [a("Sign (signum) of `number` is zero if `number` is zero, 1.0 if `number` is greater than zero, -1.0 if `number` is less than zero.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The sign of the argument.", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["math.sign(number) → simple float", "math.sign(number) → input float", "math.sign(number) → const float", "math.sign(number) → series float"]
                        },
                        "math.exp": {
                            desc: [a("The exp function of `number` is e raised to the power of `number`, where e is Euler's number.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("A value representing e raised to the power of `number`.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun math.pow}"],
                            syntax: ["math.exp(number) → simple float", "math.exp(number) → input float", "math.exp(number) → const float", "math.exp(number) → series float"]
                        },
                        "math.sin": {
                            desc: [a("The sin function returns the trigonometric sine of an angle.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The trigonometric sine of an angle.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "angle",
                                info: a("Angle, in radians.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            syntax: ["math.sin(angle) → simple float", "math.sin(angle) → input float", "math.sin(angle) → const float", "math.sin(angle) → series float"]
                        },
                        "math.cos": {
                            desc: [a("The cos function returns the trigonometric cosine of an angle.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The trigonometric cosine of an angle.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "angle",
                                info: a("Angle, in radians.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            syntax: ["math.cos(angle) → simple float", "math.cos(angle) → input float", "math.cos(angle) → const float", "math.cos(angle) → series float"]
                        },
                        "math.tan": {
                            desc: [a("The tan function returns the trigonometric tangent of an angle.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The trigonometric tangent of an angle.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "angle",
                                info: a("Angle, in radians.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            syntax: ["math.tan(angle) → simple float", "math.tan(angle) → input float", "math.tan(angle) → const float", "math.tan(angle) → series float"]
                        },
                        "math.asin": {
                            desc: [a("The asin function returns the arcsine (in radians) of number such that sin(asin(y)) = y for y in range [-1, 1].", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The arcsine of a value; the returned angle is in the range [-Pi/2, Pi/2], or {@var na} if y is outside of range [-1, 1].", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["math.asin(angle) → simple float", "math.asin(angle) → input float", "math.asin(angle) → const float", "math.asin(angle) → series float"]
                        },
                        "math.acos": {
                            desc: [a("The acos function returns the arccosine (in radians) of number such that cos(acos(y)) = y for y in range [-1, 1].", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The arc cosine of a value; the returned angle is in the range [0, Pi], or {@var na} if y is outside of range [-1, 1].", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["math.acos(angle) → simple float", "math.acos(angle) → input float", "math.acos(angle) → const float", "math.acos(angle) → series float"]
                        },
                        "math.atan": {
                            desc: [a("The atan function returns the arctangent (in radians) of number such that tan(atan(y)) = y for any y.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The arc tangent of a value; the returned angle is in the range [-Pi/2, Pi/2].", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["math.atan(angle) → simple float", "math.atan(angle) → input float", "math.atan(angle) → const float", "math.atan(angle) → series float"]
                        },
                        "math.ceil": {
                            desc: [a("The ceil function returns the smallest (closest to negative infinity) integer that is greater than or equal to the argument.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The smallest integer greater than or equal to the given number.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun math.floor}, {@fun math.round}"],
                            syntax: ["math.ceil(number) → simple int", "math.ceil(number) → input int", "math.ceil(number) → const int", "math.ceil(number) → series int"]
                        },
                        "math.floor": {
                            kind: "Built-in function",
                            returns: [a("The largest integer less than or equal to the given number.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun math.ceil}, {@fun math.round}"],
                            syntax: ["math.floor(number) → simple int", "math.floor(number) → input int", "math.floor(number) → const int", "math.floor(number) → series int"]
                        },
                        "math.round": {
                            desc: [a("Returns the value of `number` rounded to the nearest integer, with ties rounding up. If the `precision` parameter is used, returns a float value rounded to that amount of decimal places.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The value of `number` rounded to the nearest integer, or according to precision.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "number",
                                info: a("The value to be rounded.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "precision",
                                info: a("Optional argument. Decimal places to which `number` will be rounded. When no argument is supplied, rounding is to the nearest integer.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            remarks: [a("Note that for 'na' values function returns 'na'.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun math.ceil}, {@fun math.floor}"],
                            syntax: ["math.round(number) → simple int", "math.round(number) → input int", "math.round(number) → const int", "math.round(number) → series int", "math.round(number, precision) → simple float", "math.round(number, precision) → input float", "math.round(number, precision) → const float", "math.round(number, precision) → series float"]
                        },
                        "math.round_to_mintick": {
                            kind: "Built-in function",
                            desc: [a("Returns the value rounded to the symbol's mintick, i.e. the nearest value that can be divided by {@var syminfo.mintick}, without the remainder, with ties rounding up.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The `number` rounded to tick precision.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "number",
                                info: a("The value to be rounded.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun math.ceil}, {@fun math.floor}"],
                            syntax: ["math.round_to_mintick(number) → simple float", "math.round_to_mintick(number) → series float"]
                        },
                        "ta.median": {
                            desc: [a("Returns the median of the series.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The median of the series.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            syntax: ["ta.median(source, length) → series float", "ta.median(source, length) → series int"]
                        },
                        "ta.mode": {
                            desc: [a("Returns the {html_markup_1}mode{html_markup_2} of the series. If there are several values with the same frequency, it returns the smallest value.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Mode_(statistics)" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            kind: "Built-in function",
                            returns: [a("The mode of the series.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            syntax: ["ta.mode(source, length) → series float", "ta.mode(source, length) → series int"]
                        },
                        "ta.range": {
                            desc: [a("Returns the difference between the min and max values in a series.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The difference between the min and max values in the series.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            syntax: ["ta.range(source, length) → series float", "ta.range(source, length) → series int"]
                        },
                        "math.todegrees": {
                            desc: [a("Returns an approximately equivalent angle in degrees from an angle measured in radians.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The angle value in degrees.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "radians",
                                info: a("Angle in radians.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            syntax: ["math.todegrees(radians) → series float"]
                        },
                        "math.toradians": {
                            desc: [a("Returns an approximately equivalent angle in radians from an angle measured in degrees.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The angle value in radians.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "degrees",
                                info: a("Angle in degrees.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            syntax: ["math.toradians(degrees) → series float"]
                        },
                        "math.random": {
                            desc: [a("Returns a pseudo-random value. The function will generate a different sequence of values for each script execution. Using the same value for the optional seed argument will produce a repeatable sequence.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("A random value.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "min",
                                info: a("The lower bound of the range of random values. The value is not included in the range. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "max",
                                info: a("The upper bound of the range of random values. The value is not included in the range. The default is 1.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "seed",
                                info: a("Optional argument. When the same seed is used, allows successive calls to the function to produce a repeatable set of values.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input int"
                            }],
                            syntax: ["math.random(min, max, seed) → series float"]
                        },
                        "math.sum": {
                            desc: [a("The sum function returns the sliding sum of last y values of x.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Sum of `source` for `length` bars back.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun ta.cum}", "{@op for}"],
                            syntax: ["math.sum(source, length) → series float"]
                        },
                        "ta.sma": {
                            desc: [a("The sma function returns the moving average, that is the sum of last y values of x, divided by y.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Simple moving average of `source` for `length` bars back.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("ta.sma")', "plot(ta.sma(close, 15))", "", "// same on pine, but much less efficient", "pine_sma(x, y) =>", "    sum = 0.0", "    for i = 0 to y - 1", "        sum := sum + x[i] / y", "    sum", "plot(pine_sma(close, 15))"],
                            seeAlso: ["{@fun ta.ema}, {@fun ta.rma}, {@fun ta.wma}, {@fun ta.vwma}, {@fun ta.swma}, {@fun ta.alma}"],
                            syntax: ["ta.sma(source, length) → series float"]
                        },
                        "ta.hma": {
                            desc: [a("The hma function returns the Hull Moving Average.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Hull moving average of 'source' for 'length' bars back.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }],
                            examples: ["//@version=5", 'indicator("Hull Moving Average")', 'src = input(defval=close, title="Source")', 'length = input(defval=9, title="Length")', "hmaBuildIn = ta.hma(src, length)", 'plot(hmaBuildIn, title="Hull MA", color=#674EA7)'],
                            seeAlso: ["{@fun ta.ema}, {@fun ta.rma}, {@fun ta.wma}, {@fun ta.vwma}, {@fun ta.sma}"],
                            syntax: ["ta.hma(source, length) → series float"]
                        },
                        "ta.ema": {
                            desc: [a("The ema function returns the exponentially weighted moving average. In ema weighting factors decrease exponentially. It calculates by using a formula: EMA = alpha * source + (1 - alpha) * EMA[1], where alpha = 2 / (length + 1).", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Exponential moving average of `source` with alpha = 2 / (length + 1).", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }],
                            remarks: [a("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            })],
                            examples: ["//@version=5", 'indicator("ta.ema")', "plot(ta.ema(close, 15))", "", "//the same on pine", "pine_ema(src, length) =>", "    alpha = 2 / (length + 1)", "    sum = 0.0", "    sum := na(sum[1]) ? src : alpha * src + (1 - alpha) * nz(sum[1])", "plot(pine_ema(close,15))"],
                            seeAlso: ["{@fun ta.sma}, {@fun ta.rma}, {@fun ta.wma}, {@fun ta.vwma}, {@fun ta.swma}, {@fun ta.alma}"],
                            syntax: ["ta.ema(source, length) → series float"]
                        },
                        "ta.wma": {
                            desc: [a("The wma function returns weighted moving average of `source` for `length` bars back. In wma weighting factors decrease in arithmetical progression.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Weighted moving average of `source` for `length` bars back.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("ta.wma")', "plot(ta.wma(close, 15))", "", "// same on pine, but much less efficient", "pine_wma(x, y) =>", "    norm = 0.0", "    sum = 0.0", "    for i = 0 to y - 1", "        weight = (y - i) * y", "        norm := norm + weight", "        sum := sum + x[i] * weight", "    sum / norm", "plot(pine_wma(close, 15))"],
                            seeAlso: ["{@fun ta.sma}, {@fun ta.ema}, {@fun ta.rma}, {@fun ta.vwma}, {@fun ta.swma}, {@fun ta.alma}"],
                            syntax: ["ta.wma(source, length) → series float"]
                        },
                        "ta.vwma": {
                            kind: "Built-in function",
                            desc: [a("The vwma function returns volume-weighted moving average of `source` for `length` bars back. It is the same as: sma(source * volume, length) / sma(volume, length).", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Volume-weighted moving average of `source` for `length` bars back.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("ta.vwma")', "plot(ta.vwma(close, 15))", "", "// same on pine, but less efficient", "pine_vwma(x, y) =>", "    ta.sma(x * volume, y) / ta.sma(volume, y)", "plot(pine_vwma(close, 15))"],
                            seeAlso: ["{@fun ta.sma}, {@fun ta.ema}, {@fun ta.rma}, {@fun ta.wma}, {@fun ta.swma}, {@fun ta.alma}"],
                            syntax: ["ta.vwma(source, length) → series float"]
                        },
                        "ta.supertrend": {
                            kind: "Built-in function",
                            desc: [a("The Supertrend Indicator. The Supertrend is a trend following indicator.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("{html_markup_1}Tuple{html_markup_2} of two supertrend series: supertrend line and direction of trend. Possible values are 1 (down direction) and -1 (up direction).", {
                                context: "pine_docs_returns"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html#tuples">',
                                html_markup_2: "</a>"
                            })],
                            args: [{
                                name: "factor",
                                info: a("The multiplier by which the ATR will get multiplied.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "atrPeriod",
                                info: a("Length of ATR.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }],
                            examples: ["//@version=5", 'indicator("Pine Script™ Supertrend")', "", "[supertrend, direction] = ta.supertrend(3, 10)", 'plot(direction < 0 ? supertrend : na, "Up direction", color = color.green, style=plot.style_linebr)', 'plot(direction > 0 ? supertrend : na, "Down direction", color = color.red, style=plot.style_linebr)', "", "// The same on Pine Script™", "pine_supertrend(factor, atrPeriod) =>", "\tsrc = hl2", "\tatr = ta.atr(atrPeriod)", "\tupperBand = src + factor * atr", "\tlowerBand = src - factor * atr", "\tprevLowerBand = nz(lowerBand[1])", "\tprevUpperBand = nz(upperBand[1])", "", "\tlowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand", "\tupperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand", "\tint direction = na", "\tfloat superTrend = na", "\tprevSuperTrend = superTrend[1]", "\tif na(atr[1])", "\t\tdirection := 1", "\telse if prevSuperTrend == prevUpperBand", "\t\tdirection := close > upperBand ? -1 : 1", "\telse", "\t\tdirection := close < lowerBand ? 1 : -1", "\tsuperTrend := direction == -1 ? lowerBand : upperBand", "\t[superTrend, direction]", "", "[pineSupertrend, pineDirection] = pine_supertrend(3, 10)", 'plot(pineDirection < 0 ? pineSupertrend : na, "Up direction", color = color.green, style=plot.style_linebr)', 'plot(pineDirection > 0 ? pineSupertrend : na, "Down direction", color = color.red, style=plot.style_linebr)'],
                            seeAlso: ["{@fun ta.macd}"],
                            syntax: ["ta.supertrend(factor, atrPeriod) → [series float, series float]"]
                        },
                        "ta.macd": {
                            kind: "Built-in function",
                            desc: [a("MACD (moving average convergence/divergence). It is supposed to reveal changes in the strength, direction, momentum, and duration of a trend in a stock's price.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("{html_markup_1}Tuple{html_markup_2} of three MACD series: MACD line, signal line and histogram line.", {
                                context: "pine_docs_returns"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html#tuples">',
                                html_markup_2: "</a>"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "fastlen",
                                info: a("Fast Length parameter.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }, {
                                name: "slowlen",
                                info: a("Slow Length parameter.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }, {
                                name: "siglen",
                                info: a("Signal Length parameter.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'indicator("MACD")', "[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)", "plot(macdLine, color=color.blue)", "plot(signalLine, color=color.orange)", "plot(histLine, color=color.red, style=plot.style_histogram)"]
                            }, {
                                desc: [a("If you need only one value, use placeholders '_' like this:", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("MACD")', "[_, signalLine, _] = ta.macd(close, 12, 26, 9)", "plot(signalLine, color=color.orange)"]
                            }],
                            seeAlso: ["{@fun ta.sma}, {@fun ta.ema}"],
                            syntax: ["ta.macd(source, fastlen, slowlen, siglen) → [series float, series float, series float]"]
                        },
                        "ta.lowest": {
                            kind: "Built-in function",
                            desc: [a("Lowest value for a given number of bars back.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Lowest value in the series.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            remarks: [a("Two args version: `source` is a series and `length` is the number of bars back.", {
                                context: "pine_docs_remarks"
                            }), a("One arg version: `length` is the number of bars back. Algorithm uses low as a `source` series.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun ta.highest}, {@fun ta.lowestbars}, {@fun ta.highestbars}, {@fun ta.valuewhen}, {@fun ta.barssince}"],
                            syntax: ["ta.lowest(source, length) → series float", "ta.lowest(length) → series float"]
                        },
                        "ta.highest": {
                            kind: "Built-in function",
                            desc: [a("Highest value for a given number of bars back.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Highest value in the series.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            remarks: [a("Two args version: `source` is a series and `length` is the number of bars back.", {
                                context: "pine_docs_remarks"
                            }), a("One arg version: `length` is the number of bars back. Algorithm uses high as a `source` series.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun ta.lowest}, {@fun ta.lowestbars}, {@fun ta.highestbars}, {@fun ta.valuewhen}, {@fun ta.barssince}"],
                            syntax: ["ta.highest(source, length) → series float", "ta.highest(length) → series float"]
                        },
                        "ta.lowestbars": {
                            kind: "Built-in function",
                            desc: [a("Lowest value offset for a given number of bars back.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Offset to the lowest bar.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars back.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            remarks: [a("Two args version: `source` is a series and `length` is the number of bars back.", {
                                context: "pine_docs_remarks"
                            }), a("One arg version: `length` is the number of bars back. Algorithm uses low as a `source` series.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun ta.lowest}, {@fun ta.highest}, {@fun ta.highestbars}, {@fun ta.barssince}, {@fun ta.valuewhen}"],
                            syntax: ["ta.lowestbars(source, length) → series int", "ta.lowestbars(length) → series int"]
                        },
                        "ta.highestbars": {
                            kind: "Built-in function",
                            desc: [a("Highest value offset for a given number of bars back.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Offset to the highest bar.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            remarks: [a("Two args version: `source` is a series and `length` is the number of bars back.", {
                                context: "pine_docs_remarks"
                            }), a("One arg version: `length` is the number of bars back. Algorithm uses high as a `source` series.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun ta.lowest}, {@fun ta.highest}, {@fun ta.lowestbars}, {@fun ta.barssince}, {@fun ta.valuewhen}"],
                            syntax: ["ta.highestbars(source, length) → series int", "ta.highestbars(length) → series int"]
                        },
                        "ta.barssince": {
                            kind: "Built-in function",
                            desc: [a("Counts the number of bars since the last time the condition was true.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Number of bars since condition was true.", {
                                context: "pine_docs_returns"
                            })],
                            remarks: [a("If the condition has never been met prior to the current bar, the function returns na.", {
                                context: "pine_docs_remarks"
                            }), a("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            })],
                            examples: ["//@version=5", 'indicator("ta.barssince")', "// get number of bars since last color.green bar", "plot(ta.barssince(close >= open))"],
                            seeAlso: ["{@fun ta.lowestbars}, {@fun ta.highestbars}, {@fun ta.valuewhen}, {@fun ta.highest}, {@fun ta.lowest}"],
                            syntax: ["ta.barssince(condition) → series int"]
                        },
                        "ta.valuewhen": {
                            kind: "Built-in function",
                            desc: [a("Returns the value of the `source` series on the bar where the `condition` was true on the nth most recent occurrence.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "condition",
                                info: a("The condition to search for.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }, {
                                name: "source",
                                info: a("The value to be returned from the bar where the condition is met.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float/bool/color"
                            }, {
                                name: "occurrence",
                                info: a("The occurrence of the condition. The numbering starts from 0 and goes back in time, so '0' is the most recent occurrence of `condition`, '1' is the second most recent and so forth. Must be an integer >= 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }],
                            remarks: [a("This function requires execution on every bar. It is not recommended to use it inside a {@op for} or {@op while} loop structure, where its behavior can be unexpected. Please note that using this function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            })],
                            examples: ["//@version=5", 'indicator("ta.valuewhen")', "slow = ta.sma(close, 7)", "fast = ta.sma(close, 14)", "// Get value of `close` on second most recent cross", "plot(ta.valuewhen(ta.cross(slow, fast), close, 1))"],
                            seeAlso: ["{@fun ta.lowestbars}, {@fun ta.highestbars}, {@fun ta.barssince}, {@fun ta.highest}, {@fun ta.lowest}"],
                            syntax: ["ta.valuewhen(condition, source, occurrence) → series float", "ta.valuewhen(condition, source, occurrence) → series int", "ta.valuewhen(condition, source, occurrence) → series bool", "ta.valuewhen(condition, source, occurrence) → series color"]
                        },
                        "ta.falling": {
                            kind: "Built-in function",
                            desc: [a("Test if the `source` series is now falling for `length` bars long.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("true if current `source` value is less than any previous `source` value for `length` bars back, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun ta.rising}"],
                            syntax: ["ta.falling(source, length) → series bool"]
                        },
                        "ta.rising": {
                            kind: "Built-in function",
                            desc: [a("Test if the `source` series is now rising for `length` bars long.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("true if current `source` is greater than any previous `source` for `length` bars back, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun ta.falling}"],
                            syntax: ["ta.rising(source, length) → series bool"]
                        },
                        "ta.roc": {
                            kind: "Built-in function",
                            desc: [a("Calculates the percentage of change (rate of change) between the current value of `source` and its value `length` bars ago.", {
                                context: "pine_docs_desc"
                            }), a("It is calculated by the formula: 100 * change(src, length) / src[length].", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The rate of change of `source` for `length` bars back.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            syntax: ["ta.roc(source, length) → series float"]
                        },
                        "ta.cci": {
                            kind: "Built-in function",
                            desc: [a("The CCI (commodity channel index) is calculated as the difference between the typical price of a commodity and its simple moving average, divided by the mean absolute deviation of the typical price. The index is scaled by an inverse factor of 0.015 to provide more readable numbers.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Commodity channel index of source for length bars back.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            syntax: ["ta.cci(source, length) → series float"]
                        },
                        "ta.variance": {
                            kind: "Built-in function",
                            desc: [a("Variance is the expectation of the squared deviation of a series from its mean ({@fun ta.sma}), and it informally measures how far a set of numbers are spread out from their mean.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Variance of `source` for `length` bars back.", {
                                context: "pine_docs_returns"
                            })],
                            remarks: [a("If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.", {
                                context: "pine_docs_remarks"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "biased",
                                info: a("Determines which estimate should be used. Optional. The default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }],
                            seeAlso: ["{@fun ta.dev}, {@fun ta.stdev}"],
                            syntax: ["ta.variance(source, length, biased) → series float"]
                        },
                        "ta.dev": {
                            kind: "Built-in function",
                            desc: [a("Measure of difference between the series and it's {@fun ta.sma}", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Deviation of `source` for `length` bars back.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("ta.dev")', "plot(ta.dev(close, 10))", "", "// the same on pine", "pine_dev(source, length) =>", "    mean = ta.sma(source, length)", "    sum = 0.0", "    for i = 0 to length - 1", "        val = source[i]", "        sum := sum + math.abs(val - mean)", "    dev = sum/length", "plot(pine_dev(close, 10))"],
                            seeAlso: ["{@fun ta.variance}, {@fun ta.stdev}"],
                            syntax: ["ta.dev(source, length) → series float"]
                        },
                        "ta.stdev": {
                            kind: "Built-in function",
                            returns: [a("Standard deviation.", {
                                context: "pine_docs_returns"
                            })],
                            remarks: [a("If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.", {
                                context: "pine_docs_remarks"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "biased",
                                info: a("Determines which estimate should be used. Optional. The default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }],
                            examples: ["//@version=5", 'indicator("ta.stdev")', "plot(ta.stdev(close, 5))", "", "//the same on pine", "isZero(val, eps) => math.abs(val) <= eps", "", "SUM(fst, snd) =>", "    EPS = 1e-10", "    res = fst + snd", "    if isZero(res, EPS)", "        res := 0", "    else", "        if not isZero(res, 1e-4)", "            res := res", "        else", "            15", "", "pine_stdev(src, length) =>", "    avg = ta.sma(src, length)", "    sumOfSquareDeviations = 0.0", "    for i = 0 to length - 1", "        sum = SUM(src[i], -avg)", "        sumOfSquareDeviations := sumOfSquareDeviations + sum * sum", "", "    stdev = math.sqrt(sumOfSquareDeviations / length)", "plot(pine_stdev(close, 5))"],
                            seeAlso: ["{@fun ta.dev}, {@fun ta.variance}"],
                            syntax: ["ta.stdev(source, length, biased) → series float"]
                        },
                        "ta.percentrank": {
                            kind: "Built-in function",
                            desc: [a("Percent rank is the percents of how many previous values was less than or equal to the current value of given series.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Percent rank of `source` for `length` bars back.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            syntax: ["ta.percentrank(source, length) → series float"]
                        },
                        "ta.rma": {
                            desc: [a("Moving average used in RSI. It is the exponentially weighted moving average with alpha = 1 / length.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Exponential moving average of `source` with alpha = 1 / `length`.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }],
                            examples: ["//@version=5", 'indicator("ta.rma")', "plot(ta.rma(close, 15))", "", "//the same on pine", "pine_rma(src, length) =>", "\talpha = 1/length", "\tsum = 0.0", "\tsum := na(sum[1]) ? ta.sma(src, length) : alpha * src + (1 - alpha) * nz(sum[1])", "plot(pine_rma(close, 15))"],
                            seeAlso: ["{@fun ta.sma}, {@fun ta.ema}, {@fun ta.wma}, {@fun ta.vwma}, {@fun ta.swma}, {@fun ta.alma}, {@fun ta.rsi}"],
                            syntax: ["ta.rma(source, length) → series float"]
                        },
                        "ta.rsi": {
                            kind: "Built-in function",
                            desc: [a("Relative strength index. It is calculated using the `ta.rma()` of upward and downward changes of `source` over the last `length` bars.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Relative strength index.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }],
                            examples: ["//@version=5", 'indicator("ta.rsi")', "plot(ta.rsi(close, 7))", "", "// same on pine, but less efficient", "pine_rsi(x, y) => ", "    u = math.max(x - x[1], 0) // upward ta.change", "    d = math.max(x[1] - x, 0) // downward ta.change", "    rs = ta.rma(u, y) / ta.rma(d, y)", "    res = 100 - 100 / (1 + rs)", "    res", "", "plot(pine_rsi(close, 7))"],
                            seeAlso: ["{@fun ta.rma}"],
                            syntax: ["ta.rsi(source, length) → series float"]
                        },
                        "timeframe.in_seconds": {
                            kind: "Built-in function",
                            syntax: ["timeframe.in_seconds(timeframe) -> simple int"],
                            desc: [a("Converts the timeframe passed to the `timeframe` argument into seconds.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("An int representation of the number of seconds in one bar of a `timeframe`.", {
                                context: "pine_docs_returns"
                            })],
                            remarks: [a("For the `timeframe` >= '1M' function calculates number of seconds based on 30.4167 (365/12) days in month.", {
                                context: "pine_docs_remarks"
                            })],
                            args: [{
                                name: "timeframe",
                                info: a("Timeframe. Optional. The default is {@var timeframe.period}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }],
                            examples: ["//@version=5", 'indicator("timeframe_in_seconds")', "", "// Get chart timeframe:", 'i_tf = input.timeframe("1D")', "", "// Convert timeframe to the int value (number of seconds in 1 Day):", "tf = timeframe.in_seconds(i_tf)", "", "plot(tf)"],
                            seeAlso: ["{@fun input.timeframe}, {@var timeframe.period}"]
                        },
                        "ta.dmi": {
                            desc: [a("The dmi function returns the directional movement index.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("{html_markup_1}Tuple{html_markup_2} of three DMI series: Positive Directional Movement (+DI), Negative Directional Movement (-DI) and Average Directional Movement Index (ADX).", {
                                context: "pine_docs_returns"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html#tuples">',
                                html_markup_2: "</a>"
                            })],
                            args: [{
                                name: "diLength",
                                info: a("DI Period.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }, {
                                name: "adxSmoothing",
                                info: a("ADX Smoothing Period.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }],
                            examples: ["//@version=5", 'indicator(title="Directional Movement Index", shorttitle="DMI", format=format.price, precision=4)', 'len = input.int(17, minval=1, title="DI Length")', 'lensig = input.int(14, title="ADX Smoothing", minval=1, maxval=50)', "[diplus, diminus, adx] = ta.dmi(len, lensig)", 'plot(adx, color=color.red, title="ADX")', 'plot(diplus, color=color.blue, title="+DI")', 'plot(diminus, color=color.orange, title="-DI")'],
                            seeAlso: ["{@fun ta.rsi}, {@fun ta.tsi}, {@fun ta.mfi}"],
                            syntax: ["ta.dmi(diLength, adxSmoothing) → [series float, series float, series float]"]
                        },
                        "ta.correlation": {
                            kind: "Built-in function",
                            desc: [a("Correlation coefficient. Describes the degree to which two series tend to deviate from their {@fun ta.sma} values.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Correlation coefficient.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source1",
                                info: a("Source series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "source2",
                                info: a("Target series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Length (number of bars back).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun request.security}"],
                            syntax: ["ta.correlation(source1, source2, length) → series float"]
                        },
                        "ta.tsi": {
                            kind: "Built-in function",
                            desc: [a("True strength index. It uses moving averages of the underlying momentum of a financial instrument.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("True strength index. A value in range [-1, 1].", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "short_length",
                                info: a("Short length.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }, {
                                name: "long_length",
                                info: a("Long length.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }],
                            syntax: ["ta.tsi(source, short_length, long_length) → series float"]
                        },
                        "ta.linreg": {
                            kind: "Built-in function",
                            desc: [a("Linear regression curve. A line that best fits the prices specified over a user-defined time period. It is calculated using the least squares method. The result of this function is calculated using the formula: linreg = intercept + slope * (length - 1 - offset), where intercept and slope are the values calculated with the least squares method on `source` series.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Linear regression curve.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                type: "series int"
                            }, {
                                name: "offset",
                                info: a("Offset.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }],
                            syntax: ["ta.linreg(source, length, offset) → series float"]
                        },
                        "ta.stoch": {
                            kind: "Built-in function",
                            desc: [a("Stochastic. It is calculated by a formula: 100 * (close - lowest(low, length)) / (highest(high, length) - lowest(low, length)).", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Stochastic.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "high",
                                info: a("Series of high.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "low",
                                info: a("Series of low.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Length (number of bars back).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun ta.cog}"],
                            syntax: ["ta.stoch(source, high, low, length) → series float"]
                        },
                        "ta.atr": {
                            kind: "Built-in function",
                            desc: [a("Function atr (average true range) returns the RMA of true range. True range is max(high - low, abs(high - close[1]), abs(low - close[1])).", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Average true range.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "length",
                                info: a("Length (number of bars back).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }],
                            examples: ["//@version=5", 'indicator("ta.atr")', "plot(ta.atr(14))", "", "//the same on pine", "pine_atr(length) =>", "    trueRange = na(high[1])? high-low : math.max(math.max(high - low, math.abs(high - close[1])), math.abs(low - close[1]))", "    //true range can be also calculated with ta.tr(true)", "    ta.rma(trueRange, length)", "", "plot(pine_atr(14))"],
                            seeAlso: ["{@fun ta.tr}, {@fun ta.rma}"],
                            syntax: ["ta.atr(length) → series float"]
                        },
                        fixnan: {
                            kind: "Built-in function",
                            desc: [a("For a given series replaces NaN values with previous nearest non-NaN value.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Series without na gaps.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                type: "series int/float/bool/color"
                            }],
                            seeAlso: ["{@fun na}, {@var na} (variable), {@fun nz}"],
                            syntax: ["fixnan(source) → series float", "fixnan(source) → series int", "fixnan(source) → series bool", "fixnan(source) → series color"]
                        },
                        "ta.cum": {
                            kind: "Built-in function",
                            desc: [a("Cumulative (total) sum of `source`. In other words it's a sum of all elements of `source`.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Total sum series.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun math.sum}"],
                            syntax: ["ta.cum(source) → series float"]
                        },
                        "ta.change": {
                            kind: "Built-in function",
                            desc: [a("Compares the current `source` value to its value `length` bars ago and returns the difference.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The difference between the values when they are numerical. When a 'bool' source is used, returns `true` when the current source is different from the previous source.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float/bool"
                            }, {
                                name: "length",
                                info: a("How far the past `source` value is offset from the current one, in bars. Optional. The default is 1.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", "indicator('Day and Direction Change', overlay = true)", "dailyBarTime = time('1D')", "isNewDay = ta.change(dailyBarTime)", "bgcolor(isNewDay ? color.new(color.green, 80) : na)", "", "isGreenBar = close >= open", "colorChange = ta.change(isGreenBar)", "plotshape(colorChange, 'Direction Change')"],
                            seeAlso: ["{@fun ta.mom}, {@fun ta.cross}"],
                            syntax: ["ta.change(source) → series float", "ta.change(source) → series bool", "ta.change(source) → series int", "ta.change(source, length) → series float", "ta.change(source, length) → series bool", "ta.change(source, length) → series int"]
                        },
                        "ta.mom": {
                            kind: "Built-in function",
                            desc: [a("Momentum of `source` price and `source` price `length` bars ago. This is simply a difference: source - source[length].", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Momentum of `source` price and `source` price `length` bars ago.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Offset from the current bar to the previous bar.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun ta.change}"],
                            syntax: ["ta.mom(source, length) → series float"]
                        },
                        "ta.pivot_point_levels": {
                            kind: "Built-in function",
                            desc: [a("Calculates the pivot point levels using the specified `type` and `anchor`.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "type",
                                info: a('The type of pivot point levels. Possible values: "Traditional", "Fibonacci", "Woodie", "Classic", "DeMark", "Camarilla".', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "anchor",
                                info: a("The condition that triggers the reset of the pivot point calculations. When {@op true}, calculations reset; when {@op false}, results calculated at the last reset persist.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }],
                            examples: ["//@version=5", 'indicator("Weekly Pivots", max_lines_count=500, overlay=true)', 'timeframe = "1W"', 'typeInput = input.string("Traditional", "Type", options=["Traditional", "Fibonacci", "Woodie", "Classic", "DeMark", "Camarilla"])', "weekChange = timeframe.change(timeframe)", "pivotPointsArray = ta.pivot_point_levels(typeInput, weekChange)", "if weekChange", "    for pivotLevel in pivotPointsArray", "        line.new(time, pivotLevel, time + timeframe.in_seconds(timeframe) * 1000, pivotLevel, xloc=xloc.bar_time)"],
                            returns: [a('A float[] array with numerical values representing 11 pivot point levels: [P, R1, S1, R2, S2, R3, S3, R4, S4, R5, S5]. Levels absent from the specified `type` return {@var na} values (e.g., "DeMark" only calculates P, R1, and S1).', {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["ta.pivot_point_levels(type, anchor) → float[]"]
                        },
                        "ta.vwap": {
                            kind: "Built-in function",
                            desc: [a("Volume weighted average price.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("A VWAP series, or a tuple [vwap, upper_band, lower_band] if `stdev_mult` is specified.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source used for the VWAP calculation.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "anchor",
                                info: a('The condition that triggers the reset of VWAP calculations. When {@op true}, calculations reset; when {@op false}, calculations proceed using the values accumulated since the previous reset. Optional. The default is equivalent to passing {@fun timeframe.change} with "1D" as its argument.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }, {
                                name: "stdev_mult",
                                info: a("If specified, the function will calculate the standard deviation bands based on the main VWAP series and return a [vwap, upper_band, lower_band] tuple. The `upper_band`/`lower_band` values are calculated using the VWAP to which the standard deviation multiplied by this argument is added/subtracted. Optional. The default is {@var na}, in which case the function returns a single value, not a tuple.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            remarks: [a("Calculations only begin the first time the anchor condition becomes {@op true}. Until then, the function returns {@var na}.", {
                                context: "pine_docs_remarks"
                            })],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'indicator("Simple VWAP")', "vwap = ta.vwap(open)", "plot(vwap)"]
                            }, {
                                desc: [],
                                examples: ["//@version=5", 'indicator("Advanced VWAP")', 'vwapAnchorInput = input.string("Daily", "Anchor", options = ["Daily", "Weekly", "Monthly"])', 'stdevMultiplierInput = input.float(1.0, "Standard Deviation Multiplier")', "anchorTimeframe = switch vwapAnchorInput", '\t"Daily"   => "1D"', '\t"Weekly"  => "1W"', '\t"Monthly" => "1M"', "anchor = timeframe.change(anchorTimeframe)", "[vwap, upper, lower] = ta.vwap(open, anchor, stdevMultiplierInput)", "plot(vwap)", "plot(upper, color = color.green)", "plot(lower, color = color.green)"]
                            }],
                            seeAlso: ["{@var ta.vwap} (variable)"],
                            syntax: ["ta.vwap(source) → series float", "ta.vwap(source, anchor) → series float", "ta.vwap(source, anchor, stdev_mult) → [series float, series float, series float]"]
                        },
                        "ta.swma": {
                            desc: [a("Symmetrically weighted moving average with fixed length: 4. Weights: [1/6, 2/6, 2/6, 1/6].", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Symmetrically weighted moving average.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            examples: ["//@version=5", 'indicator("ta.swma")', "plot(ta.swma(close))", "", "// same on pine, but less efficient", "pine_swma(x) =>", "    x[3] * 1 / 6 + x[2] * 2 / 6 + x[1] * 2 / 6 + x[0] * 1 / 6", "plot(pine_swma(close))"],
                            seeAlso: ["{@fun ta.sma}, {@fun ta.ema}, {@fun ta.rma}, {@fun ta.wma}, {@fun ta.vwma}, {@fun ta.alma}"],
                            syntax: ["ta.swma(source) → series float"]
                        },
                        "ta.sar": {
                            kind: "Built-in function",
                            desc: [a("Parabolic SAR (parabolic stop and reverse) is a method devised by J. Welles Wilder, Jr., to find potential reversals in the market price direction of traded goods.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Parabolic SAR.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "start",
                                info: a("Start.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }, {
                                name: "inc",
                                info: a("Increment.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }, {
                                name: "max",
                                info: a("Maximum.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }],
                            examples: ["//@version=5", 'indicator("ta.sar")', "plot(ta.sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)", "", "// The same on Pine Script™", "pine_sar(start, inc, max) =>", "\tvar float result = na", "\tvar float maxMin = na", "\tvar float acceleration = na", "\tvar bool isBelow = na", "\tbool isFirstTrendBar = false", "\t", "\tif bar_index == 1", "\t\tif close > close[1]", "\t\t\tisBelow := true", "\t\t\tmaxMin := high", "\t\t\tresult := low[1]", "\t\telse", "\t\t\tisBelow := false", "\t\t\tmaxMin := low", "\t\t\tresult := high[1]", "\t\tisFirstTrendBar := true", "\t\tacceleration := start", "\t", "\tresult := result + acceleration * (maxMin - result)", "\t", "\tif isBelow", "\t\tif result > low", "\t\t\tisFirstTrendBar := true", "\t\t\tisBelow := false", "\t\t\tresult := math.max(high, maxMin)", "\t\t\tmaxMin := low", "\t\t\tacceleration := start", "\telse", "\t\tif result < high", "\t\t\tisFirstTrendBar := true", "\t\t\tisBelow := true", "\t\t\tresult := math.min(low, maxMin)", "\t\t\tmaxMin := high", "\t\t\tacceleration := start", "\t\t\t", "\tif not isFirstTrendBar", "\t\tif isBelow", "\t\t\tif high > maxMin", "\t\t\t\tmaxMin := high", "\t\t\t\tacceleration := math.min(acceleration + inc, max)", "\t\telse", "\t\t\tif low < maxMin", "\t\t\t\tmaxMin := low", "\t\t\t\tacceleration := math.min(acceleration + inc, max)", "\t", "\tif isBelow", "\t\tresult := math.min(result, low[1])", "\t\tif bar_index > 1", "\t\t\tresult := math.min(result, low[2])", "\t\t", "\telse", "\t\tresult := math.max(result, high[1])", "\t\tif bar_index > 1", "\t\t\tresult := math.max(result, high[2])", "\t", "\tresult", "\t", "plot(pine_sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)"],
                            syntax: ["ta.sar(start, inc, max) → series float"]
                        },
                        "timeframe.change": {
                            kind: "Built-in function",
                            desc: [a("Detects changes in the specified `timeframe`.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "timeframe",
                                info: a("String formatted according to the {html_markup_1}User manual's timeframe string specifications{html_markup_2}.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Timeframes.html#timeframe-string-specifications">',
                                    html_markup_2: "</a>"
                                }),
                                type: "simple string"
                            }],
                            examples: ["//@version=5", "// Run this script on an intraday chart.", 'indicator("New day started", overlay = true)', "// Highlights the first bar of the new day.", 'isNewDay = timeframe.change("1D")', "bgcolor(isNewDay ? color.new(color.green, 80) : na)"],
                            returns: [a("Returns {@op true} on the first bar of a new `timeframe`, {@op false} otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["timeframe.change(timeframe) → series bool"]
                        },
                        "math.avg": {
                            kind: "Built-in function",
                            desc: [a("Calculates average of all given series (elementwise).", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Average.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun math.sum}, {@fun ta.cum}, {@fun ta.sma}"],
                            syntax: ["math.avg(number0, number1, ...) → simple float", "math.avg(number0, number1, ...) → series float"]
                        },
                        "request.security": {
                            kind: "Built-in function",
                            desc: [a("Request another symbol/resolution", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "symbol",
                                info: a("Symbol.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "timeframe",
                                info: a("Resolution. An empty string is interpreted as the current resolution of the chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "expression",
                                info: a("An expression can be calculated and returned from the {@fun request.security} call. It can be a series or a {html_markup_1}tuple{html_markup_2} containing elements that can be cast to series.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/language/Type_system.html#tuples">',
                                    html_markup_2: "</a>"
                                }),
                                type: "series int/float/bool/color"
                            }, {
                                name: "gaps",
                                info: a("Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). Possible values: {@var barmerge.gaps_on}, {@var barmerge.gaps_off}. {@var barmerge.gaps_on} - requested data is merged with possible gaps ({@var na} values). {@var barmerge.gaps_off} - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values. Default value is {@var barmerge.gaps_off}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "barmerge_gaps"
                            }, {
                                name: "lookahead",
                                info: a("Merge strategy for the requested data position. Possible values: {@var barmerge.lookahead_on}, {@var barmerge.lookahead_off}. Default value is {@var barmerge.lookahead_off} starting from version 3. Note that behavour is the same on real-time, and differs only on history.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "barmerge_lookahead"
                            }, {
                                name: "ignore_invalid_symbol",
                                info: a("An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue. The default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input bool"
                            }, {
                                name: "currency",
                                info: a("Currency into which the symbol's currency-related values (e.g. OHLC) are to be converted. The `expression` is then calculated based on the converted values. The conversion rates used are based on the FX_IDC pairs' daily rates of the previous day (relative to the bar where the calculation is done). Optional. The default is {@var syminfo.currency}. Possible values: a three-letter string with the {html_markup_1}currency code in the ISO 4217 format{html_markup_2} (e.g. \"USD\") or one of the constants in the currency.* namespace, e.g. {@var currency.USD}.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/ISO_4217#Active_codes" rel="nofollow">',
                                    html_markup_2: "</a>"
                                }),
                                type: "simple string"
                            }],
                            returns: [a("Requested series.", {
                                context: "pine_docs_returns"
                            })],
                            remarks: [a("PineScript code that uses this function could calculate differently on history and real-time data.", {
                                context: "pine_docs_remarks"
                            }), a("If you want to specify additional parameters for the requested symbol, e.g. session or adjustment type, you can use the ticker.new() function.", {
                                context: "pine_docs_remarks"
                            }), a("It is not possible to pass a spread to this function using the 'ticker' variable. You can use the 'ticker.new' variable or a string representation of the ticker, e.g. “AAPL+MSFT*TSLA”.", {
                                context: "pine_docs_remarks"
                            }), a("At the moment, up to 40 request.security calls can be present in a script.", {
                                context: "pine_docs_remarks"
                            }), a("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            }), a("The resolution argument allowable values are:{ul}{li}1S, 5S, 10S, 15S, 30S - for seconds intervals (chart resolution should be less than or equal to the requested resolution){li_end}{li}from 1 to 1440 for minutes{li_end}{li}from 1D to 365D for days{li_end}{li}from 1W to 52W for weeks{li_end}{li}from 1M to 12M for months{li_end}{ul_end}", {
                                context: "pine_docs_remarks"
                            }).format({
                                ul: "<ul>",
                                ul_end: "</ul>",
                                li: "<li>",
                                li_end: "</li>"
                            })],
                            examples: ["//@version=5", 'indicator("request.security")', 's = request.security("MSFT", "D", close) // 1 Day', "plot(s)", "", "expr = ta.sma(close, 10)", 's1 = request.security("AAPL", "240", expr) // 240 Minutes', "plot(s1)", "", "// To avoid difference in calculation on history/realtime you can request not latest values and use merge strategy flags as follows:", 's2=request.security(syminfo.tickerid, "D", close[1], barmerge.gaps_off, barmerge.lookahead_on)', "plot(s2)", "f() => [open, high]", '[o, h] = request.security(syminfo.tickerid, "D", f())', '[l, c] = request.security(syminfo.tickerid, "D", [low, close])', "plot((o + h + l + c) / 4)"],
                            seeAlso: ["{@var syminfo.ticker}, {@var syminfo.tickerid}, {@var timeframe.period}, {@fun ta.correlation}, {@var barmerge.lookahead_off}, {@var barmerge.lookahead_on}"],
                            syntax: ["request.security(symbol, timeframe, expression, gaps, lookahead, ignore_invalid_symbol, currency) → series float", "request.security(symbol, timeframe, expression, gaps, lookahead, ignore_invalid_symbol, currency) → series int", "request.security(symbol, timeframe, expression, gaps, lookahead, ignore_invalid_symbol, currency) → series bool", "request.security(symbol, timeframe, expression, gaps, lookahead, ignore_invalid_symbol, currency) → series color"]
                        },
                        "request.security_lower_tf": {
                            kind: "Built-in function",
                            desc: [a("Requests data from a lower timeframe than the chart's.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "symbol",
                                info: a("Symbol.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "timeframe",
                                info: a("Resolution. An empty string is interpreted as the chart's timeframe.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "expression",
                                info: a("An expression or a variable that can be calculated and returned from the lower timeframe's context.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float/bool/color"
                            }, {
                                name: "ignore_invalid_symbol",
                                info: a("Determines the behavior of the function if the specified `symbol` is not found: when {@op false}, the script will halt and return a runtime error; when {@op true}, the function will return {@var na} and execution will continue. Optional. The default is {@op false}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "currency",
                                info: a("Currency into which the symbol's currency-related values (e.g. OHLC) are to be converted. The `expression` is then calculated based on the converted values. The conversion rates used are based on the FX_IDC pairs' daily rates of the previous day (relative to the bar where the calculation is done). Possible values: a three-letter string with the {html_markup_1}currency code in the ISO 4217 format{html_markup_2} (e.g. \"USD\") or one of the constants in the currency.* namespace, e.g. {@var currency.USD}. Optional. The default is {@var syminfo.currency}.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/ISO_4217#Active_codes" rel="nofollow">',
                                    html_markup_2: "</a>"
                                }),
                                type: "simple string"
                            }],
                            returns: [a("Requested series.", {
                                context: "pine_docs_returns"
                            })],
                            remarks: [a("Pine Script™ code using this function may calculate differently on historical and real-time bars, leading to {html_markup_1}repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            }), a("If you want to specify additional parameters for the requested symbol, e.g. session or adjustment type, you can use {@fun ticker.new}.", {
                                context: "pine_docs_remarks"
                            }), a("Please note that spreads (e.g., “AAPL+MSFT*TSLA”) will not always return reliable data with this function.", {
                                context: "pine_docs_remarks"
                            }), a("A maximum of 40 function calls can be used in one script and a maximum of 100,000 intrabars can be accessed by a call. The number of chart bars for which lower timeframe data is available will thus vary with the requested lower timeframe.", {
                                context: "pine_docs_remarks"
                            }), a('The `timeframe` argument can be:{ul}{li}An empty string (interpreted as the chart\'s timeframe).{li_end}{li}from "1" to "1440" for minutes{li_end}{li}from "1D" to "365D" for days{li_end}{li}from "1W" to "52W" for weeks{li_end}{li}from "1M" to "12M" for months{li_end}{ul_end}', {
                                context: "pine_docs_remarks"
                            }).format({
                                ul: "<ul>",
                                ul_end: "</ul>",
                                li: "<li>",
                                li_end: "</li>"
                            })],
                            examples: ["//@version=5", 'indicator("`request.security_lower_tf()` Example", overlay = true)', "", "// If the current chart timeframe is set to 120 minutes, then the `arrayClose` array will contain two 'close' values from the 60 minute timeframe for each bar.", 'arrClose  = request.security_lower_tf(syminfo.tickerid, "60", close)', "", "if bar_index == last_bar_index - 1", "    label.new(bar_index, high, str.tostring(arrClose))"],
                            seeAlso: ["{@fun request.security}, {@var syminfo.ticker}, {@var syminfo.tickerid}, {@var timeframe.period}, {@fun ticker.new}, {@fun request.dividends}, {@fun request.earnings}, {@fun request.splits}, {@fun request.financial}, {@fun request.quandl}"],
                            syntax: ["request.security_lower_tf(symbol, timeframe, expression, ignore_invalid_symbol, currency) → float[]", "request.security_lower_tf(symbol, timeframe, expression, ignore_invalid_symbol, currency) → int[]", "request.security_lower_tf(symbol, timeframe, expression, ignore_invalid_symbol, currency) → bool[]", "request.security_lower_tf(symbol, timeframe, expression, ignore_invalid_symbol, currency) → color[]"]
                        },
                        "request.financial": {
                            kind: "Built-in function",
                            desc: [a("Requests financial series for symbol.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "symbol",
                                info: a('Symbol. Note that the symbol should be passed with a prefix. For example: "NASDAQ:AAPL" instead of "AAPL".', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "financial_id",
                                info: a("Financial identifier. You can find the list of available ids via our {html_markup_1}Help Center{html_markup_2}.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://www.tradingview.com/?solution=43000564727">',
                                    html_markup_2: "</a>"
                                }),
                                type: "simple string"
                            }, {
                                name: "period",
                                info: a('Reporting period. Possible values are "TTM", "FY", "FQ".', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "gaps",
                                info: a("Merge strategy for the requested data (requested data automatically merges with the main series: OHLC data). Possible values include: {@var barmerge.gaps_on}, {@var barmerge.gaps_off}. {@var barmerge.gaps_on} - requested data is merged with possible gaps ({@var na} values). {@var barmerge.gaps_off} - requested data is merged continuously without gaps, all the gaps are filled with the previous, nearest existing values. Default value is {@var barmerge.gaps_off}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "barmerge_gaps"
                            }, {
                                name: "ignore_invalid_symbol",
                                info: a("An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue. The default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input bool"
                            }, {
                                name: "currency",
                                info: a("Currency into which the symbol's financial metrics (e.g. Net Income) are to be converted. The conversion rates used are based on the FX_IDC pairs' daily rates of the previous day (relative to the bar where the calculation is done). Optional. The default is {@var syminfo.currency}. Possible values: a three-letter string with the {html_markup_1}currency code in the ISO 4217 format{html_markup_2} (e.g. \"USD\") or one of the constants in the currency.* namespace, e.g. {@var currency.USD}.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/ISO_4217#Active_codes" rel="nofollow">',
                                    html_markup_2: "</a>"
                                }),
                                type: "simple string"
                            }],
                            returns: [a("Requested series.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("request.financial")', 'f = request.financial("NASDAQ:MSFT", "ACCOUNTS_PAYABLE", "FY")', "plot(f)"],
                            seeAlso: ["{@fun request.security}, {@var syminfo.tickerid}"],
                            syntax: ["request.financial(symbol, financial_id, period, gaps, ignore_invalid_symbol, currency) → series float"]
                        },
                        "request.quandl": {
                            kind: "Built-in function",
                            desc: [a("Requests {html_markup_1}Nasdaq Data Link{html_markup_2} (formerly Quandl) data for a symbol.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://data.nasdaq.com/" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            args: [{
                                name: "ticker",
                                info: a('Symbol. Note that the name of a time series and Quandl data feed should be divided by a forward slash. For example: "CFTC/SB_FO_ALL".', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "gaps",
                                info: a("Merge strategy for the requested data (requested data automatically merges with the main series: OHLC data). Possible values include: {@var barmerge.gaps_on}, {@var barmerge.gaps_off}. {@var barmerge.gaps_on} - requested data is merged with possible gaps ({@var na} values). {@var barmerge.gaps_off} - requested data is merged continuously without gaps, all the gaps are filled with the previous, nearest existing values. Default value is {@var barmerge.gaps_off}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "barmerge_gaps"
                            }, {
                                name: "index",
                                info: a("A Quandl time-series column index.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }, {
                                name: "ignore_invalid_symbol",
                                info: a("An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue. The default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input bool"
                            }],
                            returns: [a("Requested series.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("request.quandl")', 'f = request.quandl("CFTC/SB_FO_ALL", barmerge.gaps_off, 0)', "plot(f)"],
                            remarks: [a("You can learn more about how to find ticker and index values in our {html_markup_1}Help Center{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/chart/?solution=43000568613">',
                                html_markup_2: "</a>"
                            })],
                            seeAlso: ["{@fun request.security}, {@var syminfo.tickerid}"],
                            syntax: ["request.quandl(ticker, gaps, index, ignore_invalid_symbol) → series float"]
                        },
                        "ticker.new": {
                            kind: "Built-in function",
                            desc: [a("Creates a ticker identifier for requesting additional data for the script.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "prefix",
                                info: a("Exchange prefix. For example: 'BATS', 'NYSE', 'NASDAQ'. Exchange prefix of main series is {@var syminfo.prefix}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "ticker",
                                info: a("Ticker name. For example 'AAPL', 'MSFT', 'EURUSD'. Ticker name of the main series is {@var syminfo.ticker}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "session",
                                info: a("Session type. Optional argument. Possible values: {@var session.regular}, {@var session.extended}. Session type of the current chart is {@var syminfo.session}. If session is not given, then {@var syminfo.session} value is used.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "adjustment",
                                info: a("Adjustment type. Optional argument. Possible values: {@var adjustment.none}, {@var adjustment.splits}, {@var adjustment.dividends}. If adjustment is not given, then default adjustment value is used (can be different depending on particular instrument).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }],
                            returns: [a("String value of ticker id, that can be supplied to {@fun request.security} function.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("ticker.new", overlay=true) ', "t = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)", "t2 = ticker.heikinashi(t)", "c = request.security(t2, timeframe.period, low, barmerge.gaps_on)", "plot(c, style=plot.style_linebr)"],
                            remarks: [a("You may use return value of {@fun ticker.new} function as input argument for {@fun ticker.heikinashi}, {@fun ticker.renko}, {@fun ticker.linebreak}, {@fun ticker.kagi}, {@fun ticker.pointfigure} functions.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var syminfo.tickerid} (variable), {@var syminfo.ticker}, {@var syminfo.session}, {@var session.extended}, {@var session.regular}, {@fun ticker.heikinashi}, {@var adjustment.none}, {@var adjustment.splits}, {@var adjustment.dividends}"],
                            syntax: ["ticker.new(prefix, ticker, session, adjustment) → simple string"]
                        },
                        "syminfo.prefix": {
                            kind: "Built-in function",
                            desc: [a('Returns exchange prefix of the `symbol`, e.g. "NASDAQ".', {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "symbol",
                                info: a('Symbol. Note that the symbol should be passed with a prefix. For example: "NASDAQ:AAPL" instead of "AAPL".', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            returns: [a('Returns exchange prefix of the `symbol`, e.g. "NASDAQ".', {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("syminfo.prefix fun", overlay=true) ', 'i_sym = input.symbol("NASDAQ:AAPL")', "pref = syminfo.prefix(i_sym)", "tick = syminfo.ticker(i_sym)", "t = ticker.new(pref, tick, session.extended)", 's = request.security(t, "1D", close)', "plot(s)"],
                            remarks: [a("The result of the function is used in the {@fun ticker.new}/{@fun ticker.modify} and {@fun request.security}.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var syminfo.tickerid} (variable), {@var syminfo.ticker}, {@var syminfo.prefix}, {@fun syminfo.ticker}, {@fun ticker.new}"],
                            syntax: ["syminfo.prefix(symbol) → simple string", "syminfo.prefix(symbol) → series string"]
                        },
                        "syminfo.ticker": {
                            kind: "Built-in function",
                            desc: [a('Returns `symbol` name without exchange prefix, e.g. "AAPL".', {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "symbol",
                                info: a('Symbol. Note that the symbol should be passed with a prefix. For example: "NASDAQ:AAPL" instead of "AAPL".', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            returns: [a('Returns `symbol` name without exchange prefix, e.g. "AAPL".', {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("syminfo.ticker fun", overlay=true) ', 'i_sym = input.symbol("NASDAQ:AAPL")', "pref = syminfo.prefix(i_sym)", "tick = syminfo.ticker(i_sym)", "t = ticker.new(pref, tick, session.extended)", 's = request.security(t, "1D", close)', "plot(s)"],
                            remarks: [a("The result of the function is used in the {@fun ticker.new}/{@fun ticker.modify} and {@fun request.security}.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var syminfo.tickerid} (variable), {@var syminfo.ticker}, {@var syminfo.prefix}, {@fun syminfo.prefix}, {@fun ticker.new}"],
                            syntax: ["syminfo.ticker(symbol) → simple string", "syminfo.ticker(symbol) → series string"]
                        },
                        "ticker.modify": {
                            kind: "Built-in function",
                            desc: [a("Creates a ticker identifier for requesting additional data for the script.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "tickerid",
                                info: a("Symbol name with exchange prefix, e.g. 'BATS:MSFT', 'NASDAQ:MSFT' or tickerid with session and adjustment from the {@fun ticker.new} function.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "session",
                                info: a("Session type. Optional argument. Possible values: {@var session.regular}, {@var session.extended}. Session type of the current chart is {@var syminfo.session}. If session is not given, then {@var syminfo.session} value is used.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "adjustment",
                                info: a("Adjustment type. Optional argument. Possible values: {@var adjustment.none}, {@var adjustment.splits}, {@var adjustment.dividends}. If adjustment is not given, then default adjustment value is used (can be different depending on particular instrument).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }],
                            returns: [a("String value of ticker id, that can be supplied to {@fun request.security} function.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("ticker_modify", overlay=true)', "t1 = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)", 'c1 = request.security(t1, "D", close)', "t2 = ticker.modify(t1, session.extended)", 'c2 = request.security(t2, "2D", close)', "plot(c1)", "plot(c2)"],
                            seeAlso: ["{@var syminfo.tickerid} (variable), {@var syminfo.ticker}, {@var syminfo.session}, {@var session.extended}, {@var session.regular}, {@fun ticker.heikinashi}, {@var adjustment.none}, {@var adjustment.splits}, {@var adjustment.dividends}"],
                            syntax: ["ticker.modify(tickerid, session, adjustment) → simple string"]
                        },
                        "ticker.heikinashi": {
                            kind: "Built-in function",
                            desc: [a("Creates a ticker identifier for requesting Heikin Ashi bar values.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "symbol",
                                info: a("Symbol ticker identifier.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }],
                            returns: [a("String value of ticker id, that can be supplied to {@fun request.security} function.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("ticker.heikinashi", overlay=true) ', "heikinashi_close = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close)", "", 'heikinashi_aapl_60_close = request.security(ticker.heikinashi("AAPL"), "60", close)', "plot(heikinashi_close)", "plot(heikinashi_aapl_60_close)"],
                            seeAlso: ["{@var syminfo.tickerid}, {@var syminfo.ticker}, {@fun request.security}, {@fun ticker.renko}, {@fun ticker.linebreak}, {@fun ticker.kagi}, {@fun ticker.pointfigure}"],
                            syntax: ["ticker.heikinashi(symbol) → simple string"]
                        },
                        "ticker.renko": {
                            kind: "Built-in function",
                            desc: [a("Creates a ticker identifier for requesting Renko values.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "symbol",
                                info: a("Symbol ticker identifier.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "style",
                                info: a("Box Size Assignment Method: 'ATR', 'Traditional'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "param",
                                info: a("ATR Length if `style` is equal to 'ATR', or Box Size if `style` is equal to 'Traditional'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }],
                            returns: [a("String value of ticker id, that can be supplied to {@fun request.security} function.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("ticker.renko", overlay=true) ', 'renko_tickerid = ticker.renko(syminfo.tickerid, "ATR", 10)', "renko_close = request.security(renko_tickerid, timeframe.period, close)", "plot(renko_close)"],
                            seeAlso: ["{@var syminfo.tickerid}, {@var syminfo.ticker}, {@fun request.security}, {@fun ticker.heikinashi}, {@fun ticker.linebreak}, {@fun ticker.kagi}, {@fun ticker.pointfigure}"],
                            syntax: ["ticker.renko(symbol, style, param) → simple string"]
                        },
                        "ticker.linebreak": {
                            kind: "Built-in function",
                            desc: [a("Creates a ticker identifier for requesting Line Break values.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "symbol",
                                info: a("Symbol ticker identifier.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "number_of_lines",
                                info: a("Number of line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }],
                            returns: [a("String value of ticker id, that can be supplied to {@fun request.security} function.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("ticker.linebreak", overlay=true) ', "linebreak_tickerid = ticker.linebreak(syminfo.tickerid, 3)", "linebreak_close = request.security(linebreak_tickerid, timeframe.period, close)", "plot(linebreak_close)"],
                            seeAlso: ["{@var syminfo.tickerid}, {@var syminfo.ticker}, {@fun request.security}, {@fun ticker.heikinashi}, {@fun ticker.renko}, {@fun ticker.kagi}, {@fun ticker.pointfigure}"],
                            syntax: ["ticker.linebreak(symbol, number_of_lines) → simple string"]
                        },
                        "ticker.kagi": {
                            kind: "Built-in function",
                            desc: [a("Creates a ticker identifier for requesting Kagi values.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "symbol",
                                info: a("Symbol ticker identifier.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "reversal",
                                info: a("Reversal amount (absolute price value).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }],
                            returns: [a("String value of ticker id, that can be supplied to {@fun request.security} function.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("ticker.kagi", overlay=true) ', "kagi_tickerid = ticker.kagi(syminfo.tickerid, 3)", "kagi_close = request.security(kagi_tickerid, timeframe.period, close)", "plot(kagi_close)"],
                            seeAlso: ["{@var syminfo.tickerid}, {@var syminfo.ticker}, {@fun request.security}, {@fun ticker.heikinashi}, {@fun ticker.renko}, {@fun ticker.linebreak}, {@fun ticker.pointfigure}"],
                            syntax: ["ticker.kagi(symbol, reversal) → simple string"]
                        },
                        "ticker.pointfigure": {
                            kind: "Built-in function",
                            desc: [a("Creates a ticker identifier for requesting Point & Figure values.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "symbol",
                                info: a("Symbol ticker identifier.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "source",
                                info: a("The source for calculating Point & Figure. Possible values are: 'hl', 'close'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "style",
                                info: a("Box Size Assignment Method: 'ATR', 'Traditional'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "param",
                                info: a("ATR Length if `style` is equal to 'ATR', or Box Size if `style` is equal to 'Traditional'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }, {
                                name: "reversal",
                                info: a("Reversal amount.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }],
                            returns: [a("String value of ticker id, that can be supplied to {@fun request.security} function.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("ticker.pointfigure", overlay=true) ', 'pnf_tickerid = ticker.pointfigure(syminfo.tickerid, "hl", "Traditional", 1, 3)', "pnf_close = request.security(pnf_tickerid, timeframe.period, close)", "plot(pnf_close)"],
                            seeAlso: ["{@var syminfo.tickerid}, {@var syminfo.ticker}, {@fun request.security}, {@fun ticker.heikinashi}, {@fun ticker.renko}, {@fun ticker.linebreak}, {@fun ticker.kagi}"],
                            syntax: ["ticker.pointfigure(symbol, source, style, param, reversal) → simple string"]
                        },
                        time: {
                            kind: "Built-in function",
                            desc: [a("The time function returns the UNIX time of the current bar for the specified timeframe and session or NaN if the time point is out of session.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("UNIX time.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "timeframe",
                                info: a("Timeframe. An empty string is interpreted as the current timeframe of the chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "session",
                                info: a("Session specification. Optional argument, session of the symbol is used by default. An empty string is interpreted as the session of the symbol.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "timezone",
                                info: a('Timezone of the `session` argument. Can only be used when a `session` is specified. Optional. The default is {@var syminfo.timezone}. Can be specified in GMT notation (e.g. "GMT-5") or as an {html_markup_1}IANA time zone database name{html_markup_2} (e.g. "America/New_York").', {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" rel="nofollow">',
                                    html_markup_2: "</a>"
                                }),
                                type: "simple string"
                            }],
                            remarks: [a("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_remarks"
                            })],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'indicator("Time", overlay=true)', "// Try this on chart AAPL,1", 'timeinrange(res, sess) => not na(time(res, sess, "America/New_York")) ? 1 : 0', 'plot(timeinrange("1", "1300-1400"), color=color.red)', "", "// This plots 1.0 at every start of 10 minute bar on a 1 minute chart:", "newbar(res) => ta.change(time(res)) == 0 ? 0 : 1", 'plot(newbar("10"))']
                            }, {
                                desc: [a("While setting up a session you can specify not just the hours and minutes but also the days of the week that will be included in that session.", {
                                    context: "pine_docs_desc"
                                }), a('If the days aren\'t specified, the session is considered to have been set from Sunday (1) to Saturday (7), i.e. "1100-2000" is the same as "1100-1200:1234567".', {
                                    context: "pine_docs_desc"
                                }), a("", {
                                    context: "pine_docs_desc"
                                }), a("You can change that by specifying the days. For example, on a symbol that is traded seven days a week with the 24-hour trading session the following script will not color Saturdays and Sundays:", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("Time", overlay=true)', 't1 = time(timeframe.period, "0000-0000:23456")', "bgcolor(t1 ? color.new(color.blue, 90) : na)"]
                            }, {
                                desc: [a("One `session` argument can include several different sessions, separated by commas. For example, the following script will highlight the bars from 10:00 to 11:00 and from 14:00 to 15:00 (workdays only):", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("Time", overlay=true)', 't1 = time(timeframe.period, "1000-1100,1400-1500:23456")', "bgcolor(t1 ? color.new(color.blue, 90) : na)"]
                            }],
                            seeAlso: ["{@var time} (variable)"],
                            syntax: ["time(timeframe, session, timezone) → series int", "time(timeframe, session) → series int", "time(timeframe) → series int"]
                        },
                        time_close: {
                            kind: "Built-in function",
                            desc: [a("The time_close function returns the UNIX time of the close of the current bar for the specified resolution and session or NaN if the time point is out of session.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("UNIX time.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "timeframe",
                                info: a("Resolution. An empty string is interpreted as the current resolution of the chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "session",
                                info: a("Session specification. Optional argument, session of the symbol is used by default. An empty string is interpreted as the session of the symbol.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "timezone",
                                info: a('Timezone of the `session` argument. Can only be used when a `session` is specified. Optional. The default is {@var syminfo.timezone}. Can be specified in GMT notation (e.g. "GMT-5") or as an {html_markup_1}IANA time zone database name{html_markup_2} (e.g. "America/New_York").', {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" rel="nofollow">',
                                    html_markup_2: "</a>"
                                }),
                                type: "simple string"
                            }],
                            remarks: [a("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_remarks"
                            })],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'indicator("Time", overlay=true)', 't1 = time_close(timeframe.period, "1200-1300", "America/New_York")', "bgcolor(t1 ? color.new(color.blue, 90) : na)"]
                            }],
                            seeAlso: ["{@var time_close} (variable)"],
                            syntax: ["time_close(timeframe, session, timezone) → series int", "time_close(timeframe, session) → series int", "time_close(timeframe) → series int"]
                        },
                        timestamp: {
                            kind: "Built-in function",
                            desc: [a("Function timestamp returns UNIX time of specified date and time.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("UNIX time.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "timezone",
                                info: a('Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., "UTC-5", "GMT+0530") or as an IANA time zone database name (e.g., "America/New_York"). Optional. The default is {@var syminfo.timezone}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "year",
                                info: a("Year.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "month",
                                info: a("Month.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "day",
                                info: a("Day.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "hour",
                                info: a("(Optional argument) Hour. Default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "minute",
                                info: a("(Optional argument) Minute. Default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "second",
                                info: a("(Optional argument) Second. Default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "dateString",
                                info: a('A string containing the date and, optionally, the time and time zone. Its format must comply with either the {html_markup_1}IETF RFC 2822{html_markup_2} or {html_markup_3}ISO 8601{html_markup_4} standards ("DD MMM YYYY hh:mm:ss ±hhmm" or "YYYY-MM-DDThh:mm:ss±hh:mm", so "20 Feb 2020" or "2020-02-20"). If no time is supplied, "00:00" is used. If no time zone is supplied, GMT+0 will be used. Note that this diverges from the usual behavior of the function where it returns time in the exchange\'s timezone.', {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://tools.ietf.org/html/rfc2822#section-3.3" rel="nofollow">',
                                    html_markup_2: "</a>",
                                    html_markup_3: '<a target="blank" href="https://en.wikipedia.org/wiki/ISO_8601" rel="nofollow">',
                                    html_markup_4: "</a>"
                                }),
                                type: "const string"
                            }],
                            remarks: [a("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("timestamp")', "plot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)", "plot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)", "plot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)", 'plot(timestamp("GMT+6", 2016, 01, 19, 09, 30))', "plot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)", 'plot(timestamp("GMT+3", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)', 'plot(timestamp("Feb 01 2020 22:10:05"))', 'plot(timestamp("2011-10-10T14:48:00"))', 'plot(timestamp("04 Dec 1995 00:12:00 GMT+5"))'],
                            seeAlso: ["{@fun time} (function) {@var time} (variable) {@var timenow} (variable) {@var syminfo.timezone} (variable)"],
                            syntax: ["timestamp(dateString) → const int", "timestamp(year, month, day, hour, minute, second) → simple int", "timestamp(timezone, year, month, day, hour, minute, second) → simple int", "timestamp(year, month, day, hour, minute, second) → series int", "timestamp(timezone, year, month, day, hour, minute, second) → series int"]
                        },
                        year: {
                            kind: "Built-in function",
                            returns: [a("Year (in exchange timezone) for provided UNIX time.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "time",
                                info: a("UNIX time in milliseconds.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "timezone",
                                info: a('Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., "UTC-5", "GMT+0530") or as an IANA time zone database name (e.g., "America/New_York"). Optional. The default is {@var syminfo.timezone}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            remarks: [a("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_remarks"
                            }), a("Note that this function returns the year based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the year of the trading day.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var year} (variable), {@fun time}, {@fun month}, {@fun dayofmonth}, {@fun dayofweek}, {@fun hour}, {@fun minute}, {@fun second}"],
                            syntax: ["year(time) → series int", "year(time, timezone) → series int"]
                        },
                        month: {
                            kind: "Built-in function",
                            returns: [a("Month (in exchange timezone) for provided UNIX time.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "time",
                                info: a("UNIX time in milliseconds.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "timezone",
                                info: a('Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., "UTC-5", "GMT+0530") or as an IANA time zone database name (e.g., "America/New_York"). Optional. The default is {@var syminfo.timezone}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            remarks: [a("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_remarks"
                            }), a("Note that this function returns the month based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the month of the trading day.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var month} (variable), {@fun time}, {@fun year}, {@fun dayofmonth}, {@fun dayofweek}, {@fun hour}, {@fun minute}, {@fun second}"],
                            syntax: ["month(time) → series int", "month(time, timezone) → series int"]
                        },
                        weekofyear: {
                            kind: "Built-in function",
                            returns: [a("Week of year (in exchange timezone) for provided UNIX time.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "time",
                                info: a("UNIX time in milliseconds.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "timezone",
                                info: a('Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., "UTC-5", "GMT+0530") or as an IANA time zone database name (e.g., "America/New_York"). Optional. The default is {@var syminfo.timezone}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            remarks: [a("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_remarks"
                            }), a("Note that this function returns the week based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the week of the trading day.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var weekofyear} (variable), {@fun time}, {@fun year}, {@fun month}, {@fun dayofmonth}, {@fun dayofweek}, {@fun hour}, {@fun minute}, {@fun second}"],
                            syntax: ["weekofyear(time) → series int", "weekofyear(time, timezone) → series int"]
                        },
                        dayofmonth: {
                            kind: "Built-in function",
                            returns: [a("Day of month (in exchange timezone) for provided UNIX time.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "time",
                                info: a("UNIX time in milliseconds.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "timezone",
                                info: a('Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., "UTC-5", "GMT+0530") or as an IANA time zone database name (e.g., "America/New_York"). Optional. The default is {@var syminfo.timezone}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            remarks: [a("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_remarks"
                            }), a("Note that this function returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the day of the trading day.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var dayofmonth} (variable), {@fun time}, {@fun year}, {@fun month}, {@fun dayofweek}, {@fun hour}, {@fun minute}, {@fun second}"],
                            syntax: ["dayofmonth(time) → series int", "dayofmonth(time, timezone) → series int"]
                        },
                        dayofweek: {
                            kind: "Built-in function",
                            returns: [a("Day of week (in exchange timezone) for provided UNIX time.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "time",
                                info: a("UNIX time in milliseconds.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "timezone",
                                info: a('Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., "UTC-5", "GMT+0530") or as an IANA time zone database name (e.g., "America/New_York"). Optional. The default is {@var syminfo.timezone}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            remarks: [a("Note that this function returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.", {
                                context: "pine_docs_remarks"
                            }), a("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var dayofweek} (variable), {@fun time}, {@fun year}, {@fun month}, {@fun dayofmonth}, {@fun hour}, {@fun minute}, {@fun second}"],
                            syntax: ["dayofweek(time) → series int", "dayofweek(time, timezone) → series int"]
                        },
                        hour: {
                            kind: "Built-in function",
                            returns: [a("Hour (in exchange timezone) for provided UNIX time.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "time",
                                info: a("UNIX time in milliseconds.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "timezone",
                                info: a('Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., "UTC-5", "GMT+0530") or as an IANA time zone database name (e.g., "America/New_York"). Optional. The default is {@var syminfo.timezone}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            remarks: [a("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var hour} (variable), {@fun time}, {@fun year}, {@fun month}, {@fun dayofmonth}, {@fun dayofweek}, {@fun minute}, {@fun second}"],
                            syntax: ["hour(time) → series int", "hour(time, timezone) → series int"]
                        },
                        minute: {
                            kind: "Built-in function",
                            returns: [a("Minute (in exchange timezone) for provided UNIX time.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "time",
                                info: a("UNIX time in milliseconds.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "timezone",
                                info: a('Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., "UTC-5", "GMT+0530") or as an IANA time zone database name (e.g., "America/New_York"). Optional. The default is {@var syminfo.timezone}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            remarks: [a("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var minute} (variable), {@fun time}, {@fun year}, {@fun month}, {@fun dayofmonth}, {@fun dayofweek}, {@fun hour}, {@fun second}"],
                            syntax: ["minute(time) → series int", "minute(time, timezone) → series int"]
                        },
                        second: {
                            kind: "Built-in function",
                            returns: [a("Second (in exchange timezone) for provided UNIX time.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "time",
                                info: a("UNIX time in milliseconds.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "timezone",
                                info: a('Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., "UTC-5", "GMT+0530") or as an IANA time zone database name (e.g., "America/New_York"). Optional. The default is {@var syminfo.timezone}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            remarks: [a("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@var second} (variable), {@fun time}, {@fun year}, {@fun month}, {@fun dayofmonth}, {@fun dayofweek}, {@fun hour}, {@fun minute}"],
                            syntax: ["second(time) → series int", "second(time, timezone) → series int"]
                        },
                        "ta.cross": {
                            kind: "Built-in function",
                            returns: [a("true if two series have crossed each other, otherwise false.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source1",
                                info: a("First data series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "source2",
                                info: a("Second data series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun ta.change}"],
                            syntax: ["ta.cross(source1, source2) → series bool"]
                        },
                        "ta.cog": {
                            kind: "Built-in function",
                            desc: [a("The cog (center of gravity) is an indicator based on statistics and the Fibonacci golden ratio.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Center of Gravity.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("ta.cog", overlay=true) ', "plot(ta.cog(close, 10))", "", "// the same on pine", "pine_cog(source, length) =>", "    sum = math.sum(source, length)", "    num = 0.0", "    for i = 0 to length - 1", "        price = source[i]", "        num := num + price * (i + 1)", "    -num / sum", "", "plot(pine_cog(close, 10))"],
                            seeAlso: ["{@fun ta.stoch}"],
                            syntax: ["ta.cog(source, length) → series float"]
                        },
                        "ta.alma": {
                            desc: [a("Arnaud Legoux Moving Average. It uses Gaussian distribution as weights for moving average.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Arnaud Legoux Moving Average.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "series",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "offset",
                                info: a("Controls tradeoff between smoothness (closer to 1) and responsiveness (closer to 0).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }, {
                                name: "sigma",
                                info: a("Changes the smoothness of ALMA. The larger sigma the smoother ALMA.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }, {
                                name: "floor",
                                info: a("An optional parameter. Specifies whether the offset calculation is floored before ALMA is calculated. Default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple bool"
                            }],
                            examples: ["//@version=5", 'indicator("ta.alma", overlay=true) ', "plot(ta.alma(close, 9, 0.85, 6))", "", "// same on pine, but much less efficient", "pine_alma(series, windowsize, offset, sigma) =>", "    m = offset * (windowsize - 1)", "    //m = math.floor(offset * (windowsize - 1)) // Used as m when math.floor=true", "    s = windowsize / sigma", "    norm = 0.0", "    sum = 0.0", "    for i = 0 to windowsize - 1", "        weight = math.exp(-1 * math.pow(i - m, 2) / (2 * math.pow(s, 2)))", "        norm := norm + weight", "        sum := sum + series[windowsize - i - 1] * weight", "    sum / norm", "plot(pine_alma(close, 9, 0.85, 6))"],
                            seeAlso: ["{@fun ta.sma}, {@fun ta.ema}, {@fun ta.rma}, {@fun ta.wma}, {@fun ta.vwma}, {@fun ta.swma}"],
                            syntax: ["ta.alma(series, length, offset, sigma) → series float", "ta.alma(series, length, offset, sigma, floor) → series float"]
                        },
                        "ta.cmo": {
                            desc: [a("Chande Momentum Oscillator. Calculates the difference between the sum of recent gains and the sum of recent losses and then divides the result by the sum of all price movement over the same period.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Chande Momentum Oscillator.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "series",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("ta.cmo")', "plot(ta.cmo(close, 5), color=color.yellow)", "", "// the same on pine", "f_cmo(src, length) =>", "    float mom = ta.change(src)", "    float sm1 = math.sum((mom >= 0) ? mom : 0.0, length)", "    float sm2 = math.sum((mom >= 0) ? 0.0 : -mom, length)", "    100 * (sm1 - sm2) / (sm1 + sm2)", "", "plot(f_cmo(close, 5))"],
                            seeAlso: ["{@fun ta.rsi}, {@fun ta.stoch}, {@fun math.sum}"],
                            syntax: ["ta.cmo(series, length) → series float"]
                        },
                        "ta.mfi": {
                            desc: [a("Money Flow Index. The Money Flow Index (MFI) is a technical oscillator that uses price and volume for identifying overbought or oversold conditions in an asset.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Money Flow Index.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "series",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("Money Flow Index")', "", "plot(ta.mfi(hlc3, 14), color=color.yellow)", "", "// the same on pine", "pine_mfi(src, length) =>", "    float upper = math.sum(volume * (ta.change(src) <= 0.0 ? 0.0 : src), length)", "    float lower = math.sum(volume * (ta.change(src) >= 0.0 ? 0.0 : src), length)", "    mfi = 100.0 - (100.0 / (1.0 + upper / lower))", "    mfi", "", "plot(pine_mfi(hlc3, 14))"],
                            seeAlso: ["{@fun ta.rsi}, {@fun math.sum}"],
                            syntax: ["ta.mfi(series, length) → series float"]
                        },
                        "ta.wpr": {
                            desc: [a("Williams %R. The oscillator shows the current closing price in relation to the high and low of the past 'length' bars.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Williams %R.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "length",
                                info: a("Number of bars.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("Williams %R", shorttitle="%R", format=format.price, precision=2)', 'plot(ta.wpr(14), title="%R", color=color.new(#ff6d00, 0))'],
                            seeAlso: ["{@fun ta.mfi}, {@fun ta.cmo}"],
                            syntax: ["ta.wpr(length) → series float"]
                        },
                        "ta.bb": {
                            desc: [a("Bollinger Bands. A Bollinger Band is a technical analysis tool defined by a set of lines plotted two standard deviations (positively and negatively) away from a simple moving average (SMA) of the security's price, but can be adjusted to user preferences.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Bollinger Bands.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "series",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "mult",
                                info: a("Standard deviation factor.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }],
                            examples: ["//@version=5", 'indicator("ta.bb")', "", "[middle, upper, lower] = ta.bb(close, 5, 4)", "plot(middle, color=color.yellow)", "plot(upper, color=color.yellow)", "plot(lower, color=color.yellow)", "", "// the same on pine", "f_bb(src, length, mult) =>", "    float basis = ta.sma(src, length)", "    float dev = mult * ta.stdev(src, length)", "    [basis, basis + dev, basis - dev]", "", "[pineMiddle, pineUpper, pineLower] = f_bb(close, 5, 4)", "", "plot(pineMiddle)", "plot(pineUpper)", "plot(pineLower)"],
                            seeAlso: ["{@fun ta.sma}, {@fun ta.stdev}, {@fun ta.kc}"],
                            syntax: ["ta.bb(series, length, mult) → [series float, series float, series float]"]
                        },
                        "ta.bbw": {
                            desc: [a("Bollinger Bands Width. The Bollinger Band Width is the difference between the upper and the lower Bollinger Bands divided by the middle band.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Bollinger Bands Width.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "series",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "mult",
                                info: a("Standard deviation factor.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }],
                            examples: ["//@version=5", 'indicator("ta.bbw")', "", "plot(ta.bbw(close, 5, 4), color=color.yellow)", "", "// the same on pine", "f_bbw(src, length, mult) =>", "    float basis = ta.sma(src, length)", "    float dev = mult * ta.stdev(src, length)", "    ((basis + dev) - (basis - dev)) / basis", "", "plot(f_bbw(close, 5, 4))"],
                            seeAlso: ["{@fun ta.bb}, {@fun ta.sma}, {@fun ta.stdev}"],
                            syntax: ["ta.bbw(series, length, mult) → series float"]
                        },
                        "ta.kc": {
                            desc: [a("Keltner Channels. Keltner channel is a technical analysis indicator showing a central moving average line plus channel lines at a distance above and below.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Keltner Channels.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "series",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }, {
                                name: "mult",
                                info: a("Standard deviation factor.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }, {
                                name: "useTrueRange",
                                info: a("An optional parameter. Specifies if True Range is used; default is true. If the value is false, the range will be calculated with the expression (high - low).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple bool"
                            }],
                            examples: ["//@version=5", 'indicator("ta.kc")', "", "[middle, upper, lower] = ta.kc(close, 5, 4)", "plot(middle, color=color.yellow)", "plot(upper, color=color.yellow)", "plot(lower, color=color.yellow)", "", "", "// the same on pine", "f_kc(src, length, mult, useTrueRange) =>", "    float basis = ta.ema(src, length)", "    float span = (useTrueRange) ? ta.tr : (high - low)", "    float rangeEma = ta.ema(span, length)", "    [basis, basis + rangeEma * mult, basis - rangeEma * mult]", "    ", "[pineMiddle, pineUpper, pineLower] = f_kc(close, 5, 4, true)", "", "plot(pineMiddle)", "plot(pineUpper)", "plot(pineLower)"],
                            seeAlso: ["{@fun ta.ema}, {@fun ta.atr}, {@fun ta.bb}"],
                            syntax: ["ta.kc(series, length, mult) → [series float, series float, series float]", "ta.kc(series, length, mult, useTrueRange) → [series float, series float, series float]"]
                        },
                        "ta.kcw": {
                            desc: [a("Keltner Channels Width. The Keltner Channels Width is the difference between the upper and the lower Keltner Channels divided by the middle channel.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("Keltner Channels Width.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "series",
                                info: a("Series of values to process.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }, {
                                name: "mult",
                                info: a("Standard deviation factor.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }, {
                                name: "useTrueRange",
                                info: a("An optional parameter. Specifies if True Range is used; default is true. If the value is false, the range will be calculated with the expression (high - low).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple bool"
                            }],
                            examples: ["//@version=5", 'indicator("ta.kcw")', "", "plot(ta.kcw(close, 5, 4), color=color.yellow)", "", "// the same on pine", "f_kcw(src, length, mult, useTrueRange) =>", "    float basis = ta.ema(src, length)", "    float span = (useTrueRange) ? ta.tr : (high - low)", "    float rangeEma = ta.ema(span, length)", "    ", "    ((basis + rangeEma * mult) - (basis - rangeEma * mult)) / basis", "", "plot(f_kcw(close, 5, 4, true))"],
                            seeAlso: ["{@fun ta.kc}, {@fun ta.ema}, {@fun ta.atr}, {@fun ta.bb}"],
                            syntax: ["ta.kcw(series, length, mult) → series float", "ta.kcw(series, length, mult, useTrueRange) → series float"]
                        },
                        float: {
                            desc: [a("Casts na to float", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The value of the argument after casting to float.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun int}, {@fun bool}, {@fun color}, {@fun string}, {@fun line}, {@fun label}"],
                            syntax: ["float(x) → const float", "float(x) → input float", "float(x) → simple float", "float(x) → series float"]
                        },
                        int: {
                            desc: [a("Casts na or truncates float value to int", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The value of the argument after casting to int.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun float}, {@fun bool}, {@fun color}, {@fun string}, {@fun line}, {@fun label}"],
                            syntax: ["int(x) → simple int", "int(x) → input int", "int(x) → const int", "int(x) → series int"]
                        },
                        bool: {
                            desc: [a("Casts na to bool", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The value of the argument after casting to bool.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun float}, {@fun int}, {@fun color}, {@fun string}, {@fun line}, {@fun label}"],
                            syntax: ["bool(x) → const bool", "bool(x) → input bool", "bool(x) → simple bool", "bool(x) → series bool"]
                        },
                        color: {
                            desc: [a("Casts na to color", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The value of the argument after casting to color.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun float}, {@fun int}, {@fun bool}, {@fun string}, {@fun line}, {@fun label}"],
                            syntax: ["color(x) → const color", "color(x) → input color", "color(x) → simple color", "color(x) → series color"]
                        },
                        string: {
                            desc: [a("Casts na to string", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The value of the argument after casting to string.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun float}, {@fun int}, {@fun bool}, {@fun color}, {@fun line}, {@fun label}"],
                            syntax: ["string(x) → const string", "string(x) → input string", "string(x) → simple string", "string(x) → series string"]
                        },
                        line: {
                            desc: [a("Casts na to line", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The value of the argument after casting to line.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun float}, {@fun int}, {@fun bool}, {@fun color}, {@fun string}, {@fun label}"],
                            syntax: ["line(x) → series line"]
                        },
                        label: {
                            desc: [a("Casts na to label", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The value of the argument after casting to label.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun float}, {@fun int}, {@fun bool}, {@fun color}, {@fun string}, {@fun line}"],
                            syntax: ["label(x) → series label"]
                        },
                        table: {
                            desc: [a("Casts na to table", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The value of the argument after casting to table.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun float}, {@fun int}, {@fun bool}, {@fun color}, {@fun string}, {@fun line}, {@fun label}"],
                            syntax: ["table(x) → series table"]
                        },
                        box: {
                            desc: [a("Casts na to box.", {
                                context: "pine_docs_desc"
                            })],
                            kind: "Built-in function",
                            returns: [a("The value of the argument after casting to box.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun float}, {@fun int}, {@fun bool}, {@fun color}, {@fun string}, {@fun line}, {@fun label}"],
                            syntax: ["box(x) → series box"]
                        },
                        linefill: {
                            kind: "Built-in function",
                            desc: [a("Casts na to linefill.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The value of the argument after casting to linefill.", {
                                context: "pine_docs_returns"
                            })],
                            seeAlso: ["{@fun float}, {@fun int}, {@fun bool}, {@fun color}, {@fun string}, {@fun line}, {@fun label}"],
                            syntax: ["linefill(x) → series linefill"]
                        },
                        "str.tostring": {
                            kind: "Built-in function",
                            returns: [a("The string representation of the `value` argument.", {
                                context: "pine_docs_returns"
                            }), a("If the `value` argument is a string, it is returned as is.", {
                                context: "pine_docs_returns"
                            }), a('When the `value` is na, the function returns the string "NaN".', {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "value",
                                info: a("Value or array ID whose elements are converted to a string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float/bool/string/matrix<float>/matrix<int>/matrix<string>/matrix<bool>/int[]/float[]/bool[]/string[]"
                            }, {
                                name: "format",
                                info: a("Format string. Accepts these format.* constants: {@var format.mintick}, {@var format.percent}, {@var format.volume}. Optional. The default value is '#.##########'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            remarks: [a("The formatting of float values will also round those values when necessary, e.g. str.tostring(3.99, '#') will return \"4\".", {
                                context: "pine_docs_remarks"
                            }), a("To display trailing zeros, use '0' instead of '#'. For example, '#.000'.", {
                                context: "pine_docs_remarks"
                            }), a("When using {@var format.mintick}, the value will be rounded to the nearest number that can be divided by {@var syminfo.mintick} without the remainder. The string is returned with trailing zeroes.", {
                                context: "pine_docs_remarks"
                            }), a("If the x argument is a string, the same string value will be returned.", {
                                context: "pine_docs_remarks"
                            }), a('Bool type arguments return "true" or "false".', {
                                context: "pine_docs_remarks"
                            }), a('When x is na, the function returns "NaN".', {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["str.tostring(value) → series string", "str.tostring(value, format) → series string", "str.tostring(value) → simple string", "str.tostring(value, format) → simple string"]
                        },
                        "str.tonumber": {
                            kind: "Built-in function",
                            returns: [a("A float version of the string if it contains a valid number, na otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "string",
                                info: a("String representation of an int or float.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            syntax: ["str.tonumber(string) → series float"]
                        },
                        "str.replace_all": {
                            kind: "Built-in function",
                            desc: [a("Replaces each occurrence of the target string in the source string with the replacement string.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Processed string.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "target",
                                info: a("String to be replaced.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "replacement",
                                info: a("String to be substituted for each occurrence of target string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            syntax: ["str.replace_all(source, target, replacement) → simple string", "str.replace_all(source, target, replacement) → series string"]
                        },
                        "str.contains": {
                            kind: "Built-in function",
                            desc: [a("Returns true if the `source` string contains the `str` substring, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("True if the `str` was found in the `source` string, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "str",
                                info: a("The substring to search for.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            examples: ["//@version=5", 'indicator("str.contains")', "// If the current chart is a continuous futures chart, e.g “BTC1!”, then the function will return true, false otherwise.", 'var isFutures = str.contains(syminfo.tickerid, "!")', "plot(isFutures ? 1 : 0)"],
                            seeAlso: ["{@fun str.pos}", "{@fun str.match}"],
                            syntax: ["str.contains(source, str) → const bool", "str.contains(source, str) → simple bool", "str.contains(source, str) → series bool"]
                        },
                        "str.substring": {
                            kind: "Built-in function",
                            desc: [a("Returns a new string that is a substring of the `source` string. The substring begins with the character at the index specified by `begin_pos` and extends to 'end_pos - 1' of the `source` string.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The substring extracted from the source string.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source string from which to extract the substring.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "begin_pos",
                                info: a("The beginning position of the extracted substring. It is inclusive (the extracted substring includes the character at that position).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "end_pos",
                                info: a("The ending position. It is exclusive (the extracted string does NOT include that position's character). Optional. The default is the length of the `source` string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            remarks: a("Strings indexing starts from 0. If `begin_pos` is equal to `end_pos`, the function returns an empty string.", {
                                context: "pine_docs_remarks"
                            }),
                            examples: ["//@version=5", 'indicator("str.substring", overlay = true)', 'sym= input.symbol("NASDAQ:AAPL")', 'pos = str.pos(sym, ":")  // Get position of ":" character', 'tkr= str.substring(sym, pos+1) // "AAPL"', "if barstate.islastconfirmedhistory", "\tlabel.new(bar_index, high, text = tkr)"],
                            seeAlso: ["{@fun str.contains}", "{@fun str.pos}", "{@fun str.match}"],
                            syntax: ["str.substring(source, begin_pos) → const string", "str.substring(source, begin_pos) → simple string", "str.substring(source, begin_pos) → series string", "str.substring(source, begin_pos, end_pos) → const string", "str.substring(source, begin_pos, end_pos) → simple string", "str.substring(source, begin_pos, end_pos) → series string"]
                        },
                        "str.replace": {
                            kind: "Built-in function",
                            desc: [a("Returns a new string with the Nth occurrence of the `target` string replaced by the `replacement` string, where N is specified in `occurrence`.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Processed string.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "target",
                                info: a("String to be replaced.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "replacement",
                                info: a("String to be inserted instead of the target string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "occurrence",
                                info: a("N-th occurrence of the target string to replace. Indexing starts at 0 for the first match. Optional. Default value is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("str.replace")', 'var source = "FTX:BTCUSD / FTX:BTCEUR"', "", '// Replace first occurrence of "FTX" with "BINANCE" replacement string', 'var newSource = str.replace(source, "FTX",  "BINANCE", 0)', "", "if barstate.islastconfirmedhistory", '\t// Display "BINANCE:BTCUSD / FTX:BTCEUR"', "\tlabel.new(bar_index, high, text = newSource)"],
                            seeAlso: ["{@fun str.replace_all}", "{@fun str.match}"],
                            syntax: ["str.replace(source, target, replacement, occurrence) → const string", "str.replace(source, target, replacement, occurrence) → simple string", "str.replace(source, target, replacement, occurrence) → series string"]
                        },
                        "str.lower": {
                            kind: "Built-in function",
                            desc: [a("Returns a new string with all letters converted to lowercase.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("A new string with all letters converted to lowercase.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("String to be converted.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun str.upper}"],
                            syntax: ["str.lower(source) → const string", "str.lower(source) → simple string", "str.lower(source) → series string"]
                        },
                        "str.upper": {
                            kind: "Built-in function",
                            desc: [a("Returns a new string with all letters converted to uppercase.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("A new string with all letters converted to uppercase.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("String to be converted.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun str.lower}"],
                            syntax: ["str.upper(source) → const string", "str.upper(source) → simple string", "str.upper(source) → series string"]
                        },
                        "str.startswith": {
                            kind: "Built-in function",
                            desc: [a("Returns true if the `source` string starts with the substring specified in `str`, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("True if the `source` string starts with the substring specified in `str`, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "str",
                                info: a("The substring to search for.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun str.endswith}"],
                            syntax: ["str.startswith(source, str) → const bool", "str.startswith(source, str) → simple bool", "str.startswith(source, str) → series bool"]
                        },
                        "str.endswith": {
                            kind: "Built-in function",
                            desc: [a("Returns true if the `source` string ends with the substring specified in `str`, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("True if the `source` string ends with the substring specified in `str`, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "str",
                                info: a("The substring to search for.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun str.startswith}"],
                            syntax: ["str.endswith(source, str) → const bool", "str.endswith(source, str) → simple bool", "str.endswith(source, str) → series bool"]
                        },
                        "str.match": {
                            kind: "Built-in function",
                            desc: [a("Returns the new substring of the `source` string if it matches a `regex` regular expression, 'na' otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The new substring of the `source` string if it matches a `regex` regular expression, 'na' otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "regex",
                                info: a("The regular expression to which this string is to be matched.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            examples: ["//@version=5", 'indicator("str.match")', "", 's = input.string("It\'s time to sell some NASDAQ:AAPL!")', "", '// finding first substring that matches regular expression "[\\w]+:[\\w]+"', 'var string tickerid = str.match(s, "[\\\\w]+:[\\\\w]+")', "", "if barstate.islastconfirmedhistory", '\tlabel.new(bar_index, high, text = tickerid) // "NASDAQ:AAPL"'],
                            remarks: [a("Function returns first occurrence of the {html_markup_1}regular expression{html_markup_2} in the `source` string.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Regular_expression#Perl_and_PCRE" rel="nofollow">',
                                html_markup_2: "</a>"
                            }), a('The backslash "\\" symbol in the`regex` string needs to be escaped with additional backslash, e.g. "\\\\d" stands for regular expression "\\d".', {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun str.contains}", "{@fun str.substring}"],
                            syntax: ["str.match(source, regex) → simple string", "str.match(source, regex) → series string"]
                        },
                        "str.pos": {
                            kind: "Built-in function",
                            desc: [a("Returns the position of the first occurrence of the `str` string in the `source` string, 'na' otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Position of the `str` string in the `source` string.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Source string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "str",
                                info: a("The substring to search for.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            remarks: a("Strings indexing starts at 0.", {
                                context: "pine_docs_remarks"
                            }),
                            seeAlso: ["{@fun str.contains}", "{@fun str.match}", "{@fun str.substring}"],
                            syntax: ["str.pos(source, str) → const int", "str.pos(source, str) → simple int", "str.pos(source, str) → series int"]
                        },
                        "str.split": {
                            kind: "Built-in function",
                            desc: [a("Divides a string into an array of substrings and returns its array id.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The id of an array of strings.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "string",
                                info: a("Source string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "separator",
                                info: a("The string separating each substring.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            syntax: ["str.split(string, separator) → string[]"]
                        },
                        "str.length": {
                            kind: "Built-in function",
                            desc: [a("Returns an integer corresponding to the amount of chars in that string.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The number of chars in source string.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "string",
                                info: a("Source string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            syntax: ["str.length(string) → const int", "str.length(string) → simple int", "str.length(string) → series int"]
                        },
                        "ta.percentile_nearest_rank": {
                            kind: "Built-in function",
                            desc: [a("Calculates percentile using method of Nearest Rank.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("P-th percentile of `source` series for `length` bars back.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process (source).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars back (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "percentage",
                                info: a("Percentage, a number from range 0..100.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }],
                            remarks: [a("Using the Nearest Rank method on lengths less than 100 bars back can result in the same number being used for more than one percentile.", {
                                context: "pine_docs_remarks"
                            }), a("A percentile calculated using the Nearest Rank method will always be a member of the input data set.", {
                                context: "pine_docs_remarks"
                            }), a("The 100th percentile is defined to be the largest value in the input data set.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun ta.percentile_linear_interpolation}", "http://en.wikipedia.org/wiki/Percentile#The_Nearest_Rank_method"],
                            syntax: ["ta.percentile_nearest_rank(source, length, percentage) → series float"]
                        },
                        "ta.percentile_linear_interpolation": {
                            kind: "Built-in function",
                            desc: [a("Calculates percentile using method of linear interpolation between the two nearest ranks.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("P-th percentile of `source` series for `length` bars back.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("Series of values to process (source).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "length",
                                info: a("Number of bars back (length).", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "percentage",
                                info: a("Percentage, a number from range 0..100.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }],
                            remarks: [a("Note that a percentile calculated using this method will NOT always be a member of the input data set.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun ta.percentile_nearest_rank}"],
                            syntax: ["ta.percentile_linear_interpolation(source, length, percentage) → series float"]
                        },
                        "ta.crossover": {
                            kind: "Built-in function",
                            returns: [a("true if `source1` crossed over `source2` otherwise false.", {
                                context: "pine_docs_returns"
                            })],
                            desc: [a("The `source1`-series is defined as having crossed over `source2`-series if, on the current bar, the value of `source1` is greater than the value of `source2`, and on the previous bar, the value of `source1` was less than or equal to the value of `source2`.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "source1",
                                info: a("First data series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "source2",
                                info: a("Second data series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            syntax: ["ta.crossover(source1, source2) → series bool"]
                        },
                        "ta.crossunder": {
                            kind: "Built-in function",
                            returns: [a("true if `source1` crossed under `source2` otherwise false.", {
                                context: "pine_docs_returns"
                            })],
                            desc: [a("The `source1`-series is defined as having crossed under `source2`-series if, on the current bar, the value of `source1` is less than the value of `source2`, and on the previous bar, the value of `source1` was greater than or equal to the value of `source2`.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "source1",
                                info: a("First data series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "source2",
                                info: a("Second data series.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            syntax: ["ta.crossunder(source1, source2) → series bool"]
                        },
                        strategy: {
                            kind: "Built-in annotation function",
                            desc: [a("This declaration statement designates the script as a strategy and sets a number of strategy-related properties.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "title",
                                info: a("The title of the script. It is displayed on the chart when no `shorttitle` argument is used, and becomes the publication's default title when publishing the script.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "shorttitle",
                                info: a("The script's display name on charts. If specified, it will replace the `title` argument in most chart-related windows. Optional. The default is the argument used for `title`.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "overlay",
                                info: a("If {@op true}, the strategy will be displayed over the chart. If {@op false}, it will be added in a separate pane. Strategy-specific labels that display entries and exits will be displayed over the main chart regardless of this setting. Optional. The default is {@op false}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "format",
                                info: a("Specifies the formatting of the script's displayed values. Possible values: {@var format.inherit}, {@var format.price}, {@var format.volume}. Optional. The default is {@var format.inherit}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "precision",
                                info: a("Specifies the number of digits after the floating point of the script's displayed values. Must be a non-negative integer no greater than 16. If `format` is set to {@var format.inherit} and `precision` is specified, the format will instead be set to {@var format.price}. Optional. The default is inherited from the precision of the chart's symbol.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "scale",
                                info: a("The price scale used. Possible values: {@var scale.right}, {@var scale.left}, {@var scale.none}. The {@var scale.none} value can only be applied in combination with `overlay = true`. Optional. By default, the script uses the same scale as the chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "scale_type"
                            }, {
                                name: "pyramiding",
                                info: a('The maximum number of entries allowed in the same direction. If the value is 0, only one entry order in the same direction can be opened, and additional entry orders are rejected. This setting can also be changed in the strategy\'s "Settings/Properties" tab. Optional. The default is 0.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "calc_on_order_fills",
                                info: a('Specifies whether the strategy should be recalculated after an order is filled. If {@op true}, the strategy recalculates after an order is filled, as opposed to recalculating only when the bar closes. This setting can also be changed in the strategy\'s "Settings/Properties" tab. Optional. The default is {@op false}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "calc_on_every_tick",
                                info: a('Specifies whether the strategy should be recalculated on each realtime tick. If {@op true}, when the strategy is running on a realtime bar, it will recalculate on each chart update. If {@op false}, the strategy only calculates when the realtime bar closes. The argument used does not affect strategy calculation on historical data. This setting can also be changed in the strategy\'s "Settings/Properties" tab. Optional. The default is {@op false}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "max_bars_back",
                                info: a("The length of the historical buffer the script keeps for every variable and function, which determines how many past values can be referenced using the `[]` history-referencing operator. The required buffer size is automatically detected by the Pine Script™ runtime. Using this parameter is only necessary when a runtime error occurs because automatic detection fails. More information on the underlying mechanics of the historical buffer can be found {html_markup_1}in our Help Center{html_markup_2}. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://www.tradingview.com/chart/?solution=43000587849">',
                                    html_markup_2: "</a>"
                                }),
                                type: "const int"
                            }, {
                                name: "backtest_fill_limits_assumption",
                                info: a("Limit order execution threshold in ticks. When it is used, limit orders are only filled if the market price exceeds the order's limit level by the specified number of ticks. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "default_qty_type",
                                info: a('Specifies the units used for `default_qty_value`. Possible values are: {@var strategy.fixed} for contracts/shares/lots, {@var strategy.cash} for currency amounts, or {@var strategy.percent_of_equity} for a percentage of available equity. This setting can also be changed in the strategy\'s "Settings/Properties" tab. Optional. The default is {@var strategy.fixed}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "default_qty_value",
                                info: a('The default quantity to trade, in units determined by the argument used with the `default_qty_type` parameter. This setting can also be changed in the strategy\'s "Settings/Properties" tab. Optional. The default is 1.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int/float"
                            }, {
                                name: "initial_capital",
                                info: a("The amount of funds initially available for the strategy to trade, in units of `currency`. Optional. The default is 1000000.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int/float"
                            }, {
                                name: "currency",
                                info: a("Currency used by the strategy in currency-related calculations. Market positions are still opened by converting `currency` into the chart symbol's currency. The conversion rates used are based on the FX_IDC pairs' daily rates of the previous day (relative to the bar where the calculation is done). This setting can also be changed in the strategy's \"Settings/Properties\" tab. Optional. The default is {@var currency.NONE}, in which case the chart's currency is used. Possible values: one of the constants in the `currency.*` namespace, e.g. {@var currency.USD}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "slippage",
                                info: a('Slippage expressed in ticks. This value is added to or subtracted from the fill price of market/stop orders to make the fill price less favorable for the strategy. E.g., if {@var syminfo.mintick} is 0.01 and `slippage` is set to 5, a long market order will enter at 5 * 0.01 = 0.05 points above the actual price. This setting can also be changed in the strategy\'s "Settings/Properties" tab. Optional. The default is 0.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "commission_type",
                                info: a('Determines what the number passed to the `commission_value` expresses: {@var strategy.commission.percent} for a percentage of the cash volume of the order, {@var strategy.commission.cash_per_contract} for currency per contract, {@var strategy.commission.cash_per_order} for currency per order. This setting can also be changed in the strategy\'s "Settings/Properties" tab. Optional. The default is {@var strategy.commission.percent}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "commission_value",
                                info: a("Commission applied to the strategy's orders in units determined by the argument passed to the `commission_type` parameter. This setting can also be changed in the strategy's \"Settings/Properties\" tab. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int/float"
                            }, {
                                name: "process_orders_on_close",
                                info: a("When set to {@op true}, generates an additional attempt to execute orders after a bar closes and strategy calculations are completed. If the orders are market orders, the broker emulator executes them before the next bar's open. If the orders are price-dependent, they will only be filled if the price conditions are met. This option is useful if you wish to close positions on the current bar. The default is {@op false}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "close_entries_rule",
                                info: a('Determines the order in which trades are closed. Possible values are: "FIFO" (First-In, First-Out) if the earliest exit order must close the earliest entry order, or "ANY" if the orders are closed based on the `from_entry` parameter of the {@fun strategy.exit} function. "FIFO" can only be used with stocks, futures and US forex (NFA Compliance Rule 2-43b), while "ANY" is allowed in non-US forex. Optional. The default is "FIFO".', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "max_lines_count",
                                info: a("The number of last {@op line} drawings displayed. Possible values: 1-500. Optional. The default is 50.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "max_labels_count",
                                info: a("The number of last {@op label} drawings displayed. Possible values: 1-500. Optional. The default is 50.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "max_boxes_count",
                                info: a("The number of last {@op box} drawings displayed. Possible values: 1-500. Optional. The default is 50.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }, {
                                name: "margin_long",
                                info: a('Margin long is the percentage of the purchase price of a security that must be covered by cash or collateral for long positions. Must be a non-negative number. The logic used to simulate margin calls is explained in the {html_markup_1}Help Center{html_markup_2}. This setting can also be changed in the strategy\'s "Settings/Properties" tab. Optional. The default is 0, in which case the strategy does not enforce any limits on position size.', {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://www.tradingview.com/chart/?solution=43000628599">',
                                    html_markup_2: "</a>"
                                }),
                                type: "const int/float"
                            }, {
                                name: "margin_short",
                                info: a('Margin short is the percentage of the purchase price of a security that must be covered by cash or collateral for short positions. Must be a non-negative number. The logic used to simulate margin calls is explained in the {html_markup_1}Help Center{html_markup_2}. This setting can also be changed in the strategy\'s "Settings/Properties" tab. Optional. The default is 0, in which case the strategy does not enforce any limits on position size.', {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://www.tradingview.com/chart/?solution=43000628599">',
                                    html_markup_2: "</a>"
                                }),
                                type: "const int/float"
                            }, {
                                name: "explicit_plot_zorder",
                                info: a("Specifies the order in which the script's plots, fills, and hlines are rendered. If {@op true}, plots are drawn in the order in which they appear in the script's code, each newer plot being drawn above the previous ones. This only applies to `plot*()` functions, {@fun fill}, and {@fun hline}. Optional. The default is {@op false}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }, {
                                name: "risk_free_rate",
                                info: a("The risk-free rate of return is the annual percentage change in the value of an investment with minimal or zero risk. It is used to calculate the {html_markup_1}Sharpe and Sortino ratios{html_markup_2}. Optional. The default is 2.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://www.tradingview.com/chart/?solution=43000561856">',
                                    html_markup_2: "</a>"
                                }),
                                type: "const int/float"
                            }, {
                                name: "use_bar_magnifier",
                                info: a("When true, the {html_markup_1}Broker Emulator{html_markup_2} uses lower timeframe data during history backtesting to achieve more realistic results. Optional. The default is {@op false}. Only {html_markup_3}Premium{html_markup_4} accounts have access to this feature.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Strategies.html#broker-emulator">',
                                    html_markup_2: "</a>",
                                    html_markup_3: '<a target="blank" href="https://www.tradingview.com/gopro/">',
                                    html_markup_4: "</a>"
                                }),
                                type: "const bool"
                            }],
                            remarks: [a("You can learn more about strategies in our {html_markup_1}User Manual{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Strategies.html">',
                                html_markup_2: "</a>"
                            }), a("Every strategy script must have one {@fun strategy} call.", {
                                context: "pine_docs_remarks"
                            }), a("Strategies using `calc_on_every_tick = true` parameter may calculate differently on historical and realtime bars, which causes {html_markup_1}repainting{html_markup_2}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html">',
                                html_markup_2: "</a>"
                            }), a("Strategies always use the chart's prices to enter and exit positions. Using them on non-standard chart types (Heikin Ashi, Renko, etc.) will produce misleading results, as their prices are synthetic. Backtesting on non-standard charts is thus not recommended.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'strategy("Strategy", overlay = true)', "", "// Enter long by market if current open is greater than previous high.", "if open > high[1]", '\tstrategy.entry("Long", strategy.long, 1)', '// Generate a full exit bracket (profit 10 points, loss 5 points per contract) from the entry named "Long".', 'strategy.exit("Exit", "Long", profit = 10, loss = 5)'],
                            seeAlso: ["{@fun indicator}", "{@fun library}"],
                            syntax: ["strategy(title, shorttitle, overlay, format, precision, scale, pyramiding, calc_on_order_fills, calc_on_every_tick, max_bars_back, backtest_fill_limits_assumption, default_qty_type, default_qty_value, initial_capital, currency, slippage, commission_type, commission_value, process_orders_on_close, close_entries_rule, margin_long, margin_short, explicit_plot_zorder, max_lines_count, max_labels_count, max_boxes_count, risk_free_rate, use_bar_magnifier) → void"]
                        },
                        "strategy.entry": {
                            kind: "Built-in function",
                            desc: [a("It is a command to enter market position. If an order with the same ID is already pending, it is possible to modify the order. If there is no order with the specified ID, a new order is placed. To deactivate an entry order, the command {@fun strategy.cancel} or {@fun strategy.cancel_all} should be used. In comparison to the function {@fun strategy.order}, the function {@fun strategy.entry} is affected by pyramiding and it can reverse market position correctly. If both 'limit' and 'stop' parameters are 'NaN', the order type is market order.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A required parameter. The order identifier. It is possible to cancel or modify an order by referencing its identifier.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "direction",
                                info: a("A required parameter. Market position direction: 'strategy.long' is for long, 'strategy.short' is for short.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "strategy_direction"
                            }, {
                                name: "qty",
                                info: a("An optional parameter. Number of contracts/shares/lots/units to trade. The default value is 'NaN'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "limit",
                                info: a("An optional parameter. Limit price of the order. If it is specified, the order type is either 'limit', or 'stop-limit'. 'NaN' should be specified for any other order type.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "stop",
                                info: a("An optional parameter. Stop price of the order. If it is specified, the order type is either 'stop', or 'stop-limit'. 'NaN' should be specified for any other order type.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "oca_name",
                                info: a("An optional parameter. Name of the OCA group the order belongs to. If the order should not belong to any particular OCA group, there should be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "oca_type",
                                info: a("An optional parameter. Type of the OCA group. The allowed values are: {@var strategy.oca.none} - the order should not belong to any particular OCA group; {@var strategy.oca.cancel} - the order should belong to an OCA group, where as soon as an order is filled, all other orders of the same group are cancelled; {@var strategy.oca.reduce} - the order should belong to an OCA group, where if X number of contracts of an order is filled, number of contracts for each other order of the same OCA group is decreased by X.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input string"
                            }, {
                                name: "comment",
                                info: a("An optional parameter. Additional notes on the order.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "alert_message",
                                info: a('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            examples: ["//@version=5", 'strategy(title = "simple strategy entry example")', "if open > high[1]", '\tstrategy.entry("enter long", strategy.long, 1) // enter long by market if current open great then previous high', "if open < low[1]", '\tstrategy.entry("enter short", strategy.short, 1) // enter short by market if current open less then previous low'],
                            syntax: ["strategy.entry(id, direction, qty, limit, stop, oca_name, oca_type, comment, alert_message) → void"]
                        },
                        "strategy.order": {
                            kind: "Built-in function",
                            desc: [a("It is a command to place order. If an order with the same ID is already pending, it is possible to modify the order. If there is no order with the specified ID, a new order is placed. To deactivate order, the command {@fun strategy.cancel} or {@fun strategy.cancel_all} should be used. In comparison to the function {@fun strategy.entry}, the function {@fun strategy.order} is not affected by pyramiding. If both 'limit' and 'stop' parameters are 'NaN', the order type is market order.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A required parameter. The order identifier. It is possible to cancel or modify an order by referencing its identifier.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "direction",
                                info: a("A required parameter. Order direction: 'strategy.long' is for buy, 'strategy.short' is for sell.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "strategy_direction"
                            }, {
                                name: "qty",
                                info: a("An optional parameter. Number of contracts/shares/lots/units to trade. The default value is 'NaN'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "limit",
                                info: a("An optional parameter. Limit price of the order. If it is specified, the order type is either 'limit', or 'stop-limit'. 'NaN' should be specified for any other order type.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "stop",
                                info: a("An optional parameter. Stop price of the order. If it is specified, the order type is either 'stop', or 'stop-limit'. 'NaN' should be specified for any other order type.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "oca_name",
                                info: a("An optional parameter. Name of the OCA group the order belongs to. If the order should not belong to any particular OCA group, there should be an empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "oca_type",
                                info: a("An optional parameter. Type of the OCA group. The allowed values are: {@var strategy.oca.none} - the order should not belong to any particular OCA group; {@var strategy.oca.cancel} - the order should belong to an OCA group, where as soon as an order is filled, all other orders of the same group are cancelled; {@var strategy.oca.reduce} - the order should belong to an OCA group, where if X number of contracts of an order is filled, number of contracts for each other order of the same OCA group is decreased by X.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input string"
                            }, {
                                name: "comment",
                                info: a("An optional parameter. Additional notes on the order.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "alert_message",
                                info: a('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            examples: ["//@version=5", 'strategy(title = "simple strategy order example")', "if open > high[1]", '\tstrategy.order("buy", strategy.long, 1) // buy by market if current open great then previous high', "if open < low[1]", '\tstrategy.order("sell", strategy.short, 1) // sell by market if current open less then previous low'],
                            syntax: ["strategy.order(id, direction, qty, limit, stop, oca_name, oca_type, comment, alert_message) → void"]
                        },
                        "strategy.exit": {
                            kind: "Built-in function",
                            desc: [a("It is a command to exit either a specific entry, or whole market position. If an order with the same ID is already pending, it is possible to modify the order. If an entry order was not filled, but an exit order is generated, the exit order will wait till entry order is filled and then the exit order is placed. To deactivate an exit order, the command {@fun strategy.cancel} or {@fun strategy.cancel_all} should be used. If the function {@fun strategy.exit} is called once, it exits a position only once. If you want to exit multiple times, the command {@fun strategy.exit} should be called multiple times. If you use a stop loss and a trailing stop, their order type is 'stop', so only one of them is placed (the one that is supposed to be filled first). If all the following parameters 'profit', 'limit', 'loss', 'stop', 'trail_points', 'trail_offset' are 'NaN', the command will fail. To use market order to exit, the command {@fun strategy.close} or {@fun strategy.close_all} should be used.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A required parameter. The order identifier. It is possible to cancel or modify an order by referencing its identifier.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "from_entry",
                                info: a("An optional parameter. The identifier of a specific entry order to exit from it. To exit all entries an empty string should be used. The default values is empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "qty",
                                info: a("An optional parameter. Number of contracts/shares/lots/units to exit a trade with. The default value is 'NaN'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "qty_percent",
                                info: a("Defines the percentage of (0-100) the position to close. Its priority is lower than that of the 'qty' parameter. Optional. The default is 100.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "profit",
                                info: a("An optional parameter. Profit target (specified in ticks). If it is specified, a limit order is placed to exit market position when the specified amount of profit (in ticks) is reached. The default value is 'NaN'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "limit",
                                info: a("An optional parameter. Profit target (requires a specific price). If it is specified, a limit order is placed to exit market position at the specified price (or better). Priority of the parameter 'limit' is higher than priority of the parameter 'profit' ('limit' is used instead of 'profit', if its value is not 'NaN'). The default value is 'NaN'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "loss",
                                info: a("An optional parameter. Stop loss (specified in ticks). If it is specified, a stop order is placed to exit market position when the specified amount of loss (in ticks) is reached. The default value is 'NaN'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "stop",
                                info: a("An optional parameter. Stop loss (requires a specific price). If it is specified, a stop order is placed to exit market position at the specified price (or worse). Priority of the parameter 'stop' is higher than priority of the parameter 'loss' ('stop' is used instead of 'loss', if its value is not 'NaN'). The default value is 'NaN'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "trail_price",
                                info: a("An optional parameter. Trailing stop activation level (requires a specific price). If it is specified, a trailing stop order will be placed when the specified price level is reached. The offset (in ticks) to determine initial price of the trailing stop order is specified in the 'trail_offset' parameter: X ticks lower than activation level to exit long position; X ticks higher than activation level to exit short position. The default value is 'NaN'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "trail_points",
                                info: a("An optional parameter. Trailing stop activation level (profit specified in ticks). If it is specified, a trailing stop order will be placed when the calculated price level (specified amount of profit) is reached. The offset (in ticks) to determine initial price of the trailing stop order is specified in the 'trail_offset' parameter: X ticks lower than activation level to exit long position; X ticks higher than activation level to exit short position. The default value is 'NaN'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "trail_offset",
                                info: a("An optional parameter. Trailing stop price (specified in ticks). The offset in ticks to determine initial price of the trailing stop order: X ticks lower than 'trail_price' or 'trail_points' to exit long position; X ticks higher than 'trail_price' or 'trail_points' to exit short position. The default value is 'NaN'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "oca_name",
                                info: a("An optional parameter. Name of the OCA group (oca_type = {@var strategy.oca.reduce}) the profit target, the stop loss / the trailing stop orders belong to. If the name is not specified, it will be generated automatically.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "comment",
                                info: a("Additional notes on the order. If specified, displays near the order marker on the chart. Optional. The default is {@var na}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "comment_profit",
                                info: a("Additional notes on the order if the exit was triggered by crossing `profit` or `limit` specifically. If specified, supercedes the `comment` parameter and displays near the order marker on the chart. Optional. The default is {@var na}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "comment_loss",
                                info: a("Additional notes on the order if the exit was triggered by crossing `stop` or `loss` specifically. If specified, supercedes the `comment` parameter and displays near the order marker on the chart. Optional. The default is {@var na}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "comment_trailing",
                                info: a("Additional notes on the order if the exit was triggered by crossing `trail_offset` specifically. If specified, supercedes the `comment` parameter and displays near the order marker on the chart. Optional. The default is {@var na}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "alert_message",
                                info: a('Text that will replace the \'{{strategy.order.alert_message}}\' placeholder when one is used in the "Message" field of the "Create Alert" dialog. Optional. The default is {@var na}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "alert_profit",
                                info: a('Text that will replace the \'{{strategy.order.alert_message}}\' placeholder when one is used in the "Message" field of the "Create Alert" dialog. Only replaces the text if the exit was triggered by crossing `profit` or `limit` specifically. Optional. The default is {@var na}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "alert_loss",
                                info: a('Text that will replace the \'{{strategy.order.alert_message}}\' placeholder when one is used in the "Message" field of the "Create Alert" dialog. Only replaces the text if the exit was triggered by crossing `stop` or `loss` specifically. Optional. The default is {@var na}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "alert_trailing",
                                info: a('Text that will replace the \'{{strategy.order.alert_message}}\' placeholder when one is used in the "Message" field of the "Create Alert" dialog. Only replaces the text if the exit was triggered by crossing `trail_offset` specifically. Optional. The default is {@var na}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            examples: ["//@version=5", 'strategy(title = "simple strategy exit example")', "if open > high[1]", '\tstrategy.entry("long", strategy.long, 1) // enter long by market if current open great then previous high', 'strategy.exit("exit", "long", profit = 10, loss = 5) // generate full exit bracket (profit 10 points, loss 5 points per contract) from entry with name "long"'],
                            syntax: ["strategy.exit(id, from_entry, qty, qty_percent, profit, limit, loss, stop, trail_price, trail_points, trail_offset, oca_name, comment, comment_profit, comment_loss, comment_trailing, alert_message, alert_profit, alert_loss, alert_trailing) → void"]
                        },
                        "strategy.cancel": {
                            kind: "Built-in function",
                            desc: [a("It is a command to cancel/deactivate pending orders by referencing their names, which were generated by the functions: {@fun strategy.order}, {@fun strategy.entry} and {@fun strategy.exit}.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A required parameter. The order identifier. It is possible to cancel an order by referencing its identifier.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            examples: ["//@version=5", 'strategy(title = "simple order cancellation example")', "conditionForBuy = open > high[1]", "if conditionForBuy", '\tstrategy.entry("long", strategy.long, 1, limit = low) // enter long using limit order at low price of current bar if conditionForBuy is true', "if not conditionForBuy", '\tstrategy.cancel("long") // cancel the entry order with name "long" if conditionForBuy is false'],
                            syntax: ["strategy.cancel(id) → void"]
                        },
                        "strategy.cancel_all": {
                            kind: "Built-in function",
                            desc: [a("It is a command to cancel/deactivate all pending orders, which were generated by the functions: {@fun strategy.order}, {@fun strategy.entry} and {@fun strategy.exit}.", {
                                context: "pine_docs_desc"
                            })],
                            examples: ["//@version=5", 'strategy(title = "simple all orders cancellation example")', "conditionForBuy1 = open > high[1]", "if conditionForBuy1", '\tstrategy.entry("long entry 1", strategy.long, 1, limit = low) // enter long by limit if conditionForBuy1 is true', "conditionForBuy2 = conditionForBuy1 and open[1] > high[2]", "if conditionForBuy2", '\tstrategy.entry("long entry 2", strategy.long, 1, limit = ta.lowest(low, 2)) // enter long by limit if conditionForBuy2 is true', "conditionForStopTrading = open < ta.lowest(low, 2)", "if conditionForStopTrading", "\tstrategy.cancel_all() // cancel both limit orders if the conditon conditionForStopTrading is true"],
                            syntax: ["strategy.cancel_all() → void"]
                        },
                        "ta.pivothigh": {
                            kind: "Built-in function",
                            desc: [a("This function returns price of the pivot high point. It returns 'NaN', if there was no pivot high point.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Price of the point or 'NaN'.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("An optional parameter. Data series to calculate the value. 'High' by default.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "leftbars",
                                info: a("Left strength.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "rightbars",
                                info: a("Right strength.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            remarks: [a("If parameters 'leftbars' or 'rightbars' are series you should use {@fun max_bars_back} function for the 'source' variable.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("PivotHigh", overlay=true)', "leftBars = input(2)", "rightBars=input(2)", "ph = ta.pivothigh(leftBars, rightBars)", "plot(ph, style=plot.style_cross, linewidth=3, color= color.red, offset=-rightBars)"],
                            syntax: ["ta.pivothigh(source, leftbars, rightbars) → series float", "ta.pivothigh(leftbars, rightbars) → series float"]
                        },
                        "ta.pivotlow": {
                            kind: "Built-in function",
                            desc: [a("This function returns price of the pivot low point. It returns 'NaN', if there was no pivot low point.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Price of the point or 'NaN'.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "source",
                                info: a("An optional parameter. Data series to calculate the value. 'Low' by default.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "leftbars",
                                info: a("Left strength.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "rightbars",
                                info: a("Right strength.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            remarks: [a("If parameters 'leftbars' or 'rightbars' are series you should use {@fun max_bars_back} function for the 'source' variable.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("PivotLow", overlay=true)', "leftBars = input(2)", "rightBars=input(2)", "pl = ta.pivotlow(close, leftBars, rightBars)", "plot(pl, style=plot.style_cross, linewidth=3, color= color.blue, offset=-rightBars)"],
                            syntax: ["ta.pivotlow(source, leftbars, rightbars) → series float", "ta.pivotlow(leftbars, rightbars) → series float"]
                        },
                        "strategy.close_all": {
                            kind: "Built-in function",
                            desc: [a("Exits the current market position, making it flat.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "comment",
                                info: a("An optional parameter. Additional notes on the order.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "alert_message",
                                info: a('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "immediately",
                                info: a("An optional parameter. If {@op true}, the closing order will be executed on the tick where it has been placed, ignoring the strategy parameters that restrict the order execution to the open of the next bar. The default is {@op false}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }],
                            examples: ["//@version=5", 'strategy("closeAll Demo", overlay=false)', "if open > close", '\tstrategy.entry("buy", strategy.long)', "if open < close", '\tstrategy.close_all(comment = "close all entries")', "plot(strategy.position_size)"],
                            syntax: ["strategy.close_all(comment, alert_message, immediately) → void"]
                        },
                        "strategy.close": {
                            kind: "Built-in function",
                            desc: [a("It is a command to exit from the entry with the specified ID. If there were multiple entry orders with the same ID, all of them are exited at once. If there are no open entries with the specified ID by the moment the command is triggered, the command will not come into effect. The command uses market order. Every entry is closed by a separate market order.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A required parameter. The order identifier. It is possible to close an order by referencing its identifier.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "qty",
                                info: a("An optional parameter. Number of contracts/shares/lots/units to exit a trade with. The default value is 'NaN'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "qty_percent",
                                info: a("Defines the percentage (0-100) of the position to close. Its priority is lower than that of the 'qty' parameter. Optional. The default is 100.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "comment",
                                info: a("An optional parameter. Additional notes on the order.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "alert_message",
                                info: a('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "immediately",
                                info: a("An optional parameter. If {@op true}, the closing order will be executed on the tick where it has been placed, ignoring the strategy parameters that restrict the order execution to the open of the next bar. The default is {@op false}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }],
                            examples: ["//@version=5", 'strategy("closeEntry Demo", overlay=false)', "if open > close", '\tstrategy.entry("buy", strategy.long)', "if open < close", '\tstrategy.close("buy", qty_percent = 50, comment = "close buy entry for 50%")', "plot(strategy.position_size)"],
                            syntax: ["strategy.close(id, comment, qty, qty_percent, alert_message, immediately) → void"]
                        },
                        "strategy.risk.max_position_size": {
                            kind: "Built-in function",
                            desc: [a("The purpose of this rule is to determine maximum size of a market position. The rule affects the following function: {@fun strategy.entry}. The 'entry' quantity can be reduced (if needed) to such number of contracts/shares/lots/units, so the total position size doesn't exceed the value specified in 'strategy.risk.max_position_size'. If minimum possible quantity still violates the rule, the order will not be placed.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "contracts",
                                info: a("A required parameter. Maximum number of contracts/shares/lots/units in a position.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }],
                            examples: ["//@version=5", 'strategy("risk.max_position_size Demo", default_qty_value = 100)', "strategy.risk.max_position_size(10)", "if open > close", '\tstrategy.entry("buy", strategy.long)', "plot(strategy.position_size)  // max plot value will be 10"],
                            syntax: ["strategy.risk.max_position_size(contracts) → void"]
                        },
                        "strategy.risk.max_intraday_loss": {
                            kind: "Built-in function",
                            desc: [a("The maximum loss value allowed during a day. It is specified either in money (base currency), or in percentage of maximum intraday equity (0 -100).", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "value",
                                info: a("A required parameter. The maximum loss value. It is specified either in money (base currency), or in percentage of maximum intraday equity. For % of equity the range of allowed values is from 0 to 100.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }, {
                                name: "type",
                                info: a("A required parameter. The type of the value. Please specify one of the following values: {@var strategy.percent_of_equity} or {@var strategy.cash}. Note: if equity drops down to zero or to a negative and the {@var strategy.percent_of_equity} is specified, all pending orders are cancelled, all open positions are closed and no new orders can be placed for good.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "alert_message",
                                info: a('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }],
                            detailedDesc: [{
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Sets the maximum intraday loss using the strategy's equity value.", "//@version=5", 'strategy("strategy.risk.max_intraday_loss Example 1", overlay = false, default_qty_type = strategy.percent_of_equity, default_qty_value = 100)', "", "// Input for maximum intraday loss %. ", "lossPct = input.float(10)", "", "// Set maximum intraday loss to our lossPct input", "strategy.risk.max_intraday_loss(lossPct, strategy.percent_of_equity)", "", "// Enter Short at bar_index zero.", "if bar_index == 0", '\tstrategy.entry("Short", strategy.short)', "", "// Store equity value from the beginning of the day", "eqFromDayStart = ta.valuewhen(ta.change(dayofweek) > 0, strategy.equity, 0)", "", "// Calculate change of the current equity from the beginning of the current day.", "eqChgPct = 100 * ((strategy.equity - eqFromDayStart) / strategy.equity)", "", "// Plot it", "plot(eqChgPct) ", "hline(-lossPct)"]
                            }, {
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Sets the maximum intraday loss using the strategy's cash value.", "//@version=5", 'strategy("strategy.risk.max_intraday_loss Example 2", overlay = false)', "", "// Input for maximum intraday loss in absolute cash value of the symbol. ", "absCashLoss = input.float(5)", "", "// Set maximum intraday loss to `absCashLoss` in account currency.", "strategy.risk.max_intraday_loss(absCashLoss, strategy.cash)", "", "// Enter Short at bar_index zero.", "if bar_index == 0", '\tstrategy.entry("Short", strategy.short)', "", "// Store the open price value from the beginning of the day.", "beginPrice = ta.valuewhen(ta.change(dayofweek) > 0, open, 0)", "", "// Calculate the absolute price change for the current period.", "priceChg = (close - beginPrice)", "", "hline(absCashLoss)", "plot(priceChg)"]
                            }],
                            seeAlso: ["{@fun strategy}", "{@var strategy.percent_of_equity}", "{@var strategy.cash}"],
                            syntax: ["strategy.risk.max_intraday_loss(value, type, alert_message) → void"]
                        },
                        "strategy.risk.max_intraday_filled_orders": {
                            kind: "Built-in function",
                            desc: [a("The purpose of this rule is to determine maximum number of filled orders per 1 day (per 1 bar, if chart resolution is higher than 1 day). The rule affects the whole strategy. Once the maximum number of filled orders is reached, all pending orders are cancelled, all open positions are closed and no new orders can be placed till the end of the current trading session.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "count",
                                info: a("A required parameter. The maximum number of filled orders per 1 day.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }, {
                                name: "alert_message",
                                info: a('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }],
                            examples: ["//@version=5", 'strategy("risk.max_intraday_filled_orders Demo")', "strategy.risk.max_intraday_filled_orders(10) // After 10 orders are filled, no more strategy orders will be placed (except for a market order to exit current open market position, if there is any).", "if open > close", '\tstrategy.entry("buy", strategy.long)', "if open < close", '\tstrategy.entry("sell", strategy.short)'],
                            syntax: ["strategy.risk.max_intraday_filled_orders(count, alert_message) → void"]
                        },
                        "strategy.risk.allow_entry_in": {
                            kind: "Built-in function",
                            desc: [a("This function can be used to specify in which market direction the {@fun strategy.entry} function is allowed to open positions.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "value",
                                info: a("The allowed direction. Possible values: {@var strategy.direction.all}, {@var strategy.direction.long}, {@var strategy.direction.short}", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }],
                            examples: ["//@version=5", 'strategy("strategy.risk.allow_entry_in")', "", "strategy.risk.allow_entry_in(strategy.direction.long)", "if open > close", '\tstrategy.entry("Long", strategy.long)', "// Instead of opening a short position with 10 contracts, this command will close long entries.", "if open < close", '\tstrategy.entry("Short", strategy.short, qty = 10)'],
                            syntax: ["strategy.risk.allow_entry_in(value) → void"]
                        },
                        "strategy.risk.max_cons_loss_days": {
                            kind: "Built-in function",
                            desc: [a("The purpose of this rule is to cancel all pending orders, close all open positions and stop placing orders after a specified number of consecutive days with losses. The rule affects the whole strategy.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "count",
                                info: a("A required parameter. The allowed number of consecutive days with losses.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int"
                            }, {
                                name: "alert_message",
                                info: a('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }],
                            examples: ["//@version=5", 'strategy("risk.max_cons_loss_days Demo 1")', "strategy.risk.max_cons_loss_days(3) // No orders will be placed after 3 days, if each day is with loss.", "plot(strategy.position_size)"],
                            syntax: ["strategy.risk.max_cons_loss_days(count, alert_message) → void"]
                        },
                        "strategy.risk.max_drawdown": {
                            kind: "Built-in function",
                            desc: [a("The purpose of this rule is to determine maximum drawdown. The rule affects the whole strategy. Once the maximum drawdown value is reached, all pending orders are cancelled, all open positions are closed and no new orders can be placed.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "value",
                                info: a("A required parameter. The maximum drawdown value. It is specified either in money (base currency), or in percentage of maximum equity. For % of equity the range of allowed values is from 0 to 100.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple int/float"
                            }, {
                                name: "type",
                                info: a("A required parameter. The type of the value. Please specify one of the following values: {@var strategy.percent_of_equity} or {@var strategy.cash}. Note: if equity drops down to zero or to a negative and the 'strategy.percent_of_equity' is specified, all pending orders are cancelled, all open positions are closed and no new orders can be placed for good.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "alert_message",
                                info: a('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'strategy("risk.max_drawdown Demo 1")', "strategy.risk.max_drawdown(50, strategy.percent_of_equity) // set maximum drawdown to 50% of maximum equity", "plot(strategy.position_size)"]
                            }, {
                                desc: [],
                                examples: ["//@version=5", 'strategy("risk.max_drawdown Demo 2", currency = "EUR")', "strategy.risk.max_drawdown(2000, strategy.cash)  // set maximum drawdown to 2000 EUR from maximum equity", "plot(strategy.position_size)"]
                            }],
                            syntax: ["strategy.risk.max_drawdown(value, type, alert_message) → void"]
                        },
                        "box.copy": {
                            kind: "Built-in function",
                            desc: [a("Clones the box object.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }],
                            examples: ["//@version=5", "indicator('Last 50 bars price ranges', overlay = true)", "LOOKBACK = 50", "highest = ta.highest(LOOKBACK)", "lowest = ta.lowest(LOOKBACK)", "if barstate.islastconfirmedhistory", "\tvar BoxLast = box.new(bar_index[LOOKBACK], highest, bar_index, lowest, bgcolor = color.new(color.green, 80))", "\tvar BoxPrev = box.copy(BoxLast)", "\tbox.set_lefttop(BoxPrev, bar_index[LOOKBACK * 2], highest[50])", "\tbox.set_rightbottom(BoxPrev, bar_index[LOOKBACK], lowest[50])", "\tbox.set_bgcolor(BoxPrev, color.new(color.red, 80))"],
                            seeAlso: ["{@fun box.new}, {@fun box.delete}"],
                            syntax: ["box.copy(id) → series box"]
                        },
                        "box.new": {
                            kind: "Built-in function",
                            desc: [a("Creates a new box object.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of a box object which may be used in box.set_*() and box.get_*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "left",
                                info: a("Bar index (if xloc = {@var xloc.bar_index}) or UNIX time (if xloc = {@var xloc.bar_time}) of the left border of the box. Note that objects positioned using {@var xloc.bar_index} cannot be drawn further than 500 bars into the future.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "top",
                                info: a("Price of the top border of the box.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "right",
                                info: a("Bar index (if xloc = {@var xloc.bar_index}) or UNIX time (if xloc = {@var xloc.bar_time}) of the right border of the box. Note that objects positioned using {@var xloc.bar_index} cannot be drawn further than 500 bars into the future.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "bottom",
                                info: a("Price of the bottom border of the box.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "border_color",
                                info: a("Color of the four borders. Optional. The default is {@var color.blue}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "border_width",
                                info: a("Width of the four borders, in pixels. Optional. The default is 1 pixel.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "border_style",
                                info: a("Style of the four borders. Possible values: {@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}. Optional. The default value is {@var line.style_solid}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "extend",
                                info: a("When {@var extend.none} is used, the horizontal borders start at the left border and end at the right border. With {@var extend.left} or {@var extend.right}, the horizontal borders are extended indefinitely to the left or right of the box, respectively. With {@var extend.both}, the horizontal borders are extended on both sides. Optional. The default value is {@var extend.none}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "xloc",
                                info: a("Determines whether the arguments to 'left' and 'right' are a bar index or a time value. If xloc = {@var xloc.bar_index}, the arguments must be a bar index. If xloc = {@var xloc.bar_time}, the arguments must be a UNIX time. Possible values: {@var xloc.bar_index} and {@var xloc.bar_time}. Optional. The default is {@var xloc.bar_index}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "bgcolor",
                                info: a("Background color of the box. Optional. The default is {@var color.blue}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "text",
                                info: a("The text to be displayed inside the box. Optional. The default is empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "text_size",
                                info: a("The size of the text. An optional parameter, the default value is {@var size.auto}. Possible values: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "text_color",
                                info: a("The color of the text. Optional. The default is {@var color.black}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "text_halign",
                                info: a("The horizontal alignment of the box's text. Optional. The default value is {@var text.align_center}. Possible values: {@var text.align_left}, {@var text.align_center}, {@var text.align_right}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "text_valign",
                                info: a("The vertical alignment of the box's text. Optional. The default value is {@var text.align_center}. Possible values: {@var text.align_top}, {@var text.align_center}, {@var text.align_bottom}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "text_wrap",
                                info: a("Defines whether the text is presented in a single line, extending past the width of the box if necessary, or wrapped so every line is no wider than the box itself (and clipped by the bottom border of the box if the height of the resulting wrapped text is higher than the height of the box). Optional. The default value is {@var text.wrap_none}. Possible values: {@var text.wrap_none}, {@var text.wrap_auto}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            examples: ["//@version=5", 'indicator("box.new")', "var b = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)", "box.set_lefttop(b, time, 100)", "box.set_rightbottom(b, time + 60 * 60 * 24, 500)", "box.set_bgcolor(b, color.green)"],
                            seeAlso: ["{@fun box.delete}, {@fun box.get_left}, {@fun box.get_top}, {@fun box.get_right}, {@fun box.get_bottom}, {@fun box.set_top_left}, {@fun box.set_left}, {@fun box.set_top}, {@fun box.set_bottom_right}, {@fun box.set_right}, {@fun box.set_bottom}, {@fun box.set_border_color}, {@fun box.set_bgcolor}, {@fun box.set_border_width}, {@fun box.set_border_style}, {@fun box.set_extend}"],
                            syntax: ["box.new(left, top, right, bottom, border_color, border_width, border_style, extend, xloc, bgcolor, text, text_size, text_color, text_halign, text_valign, text_wrap) → series box"]
                        },
                        "box.delete": {
                            kind: "Built-in function",
                            desc: [a("Deletes the specified box object. If it has already been deleted, does nothing.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object to delete.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }],
                            seeAlso: ["{@fun box.new}"],
                            syntax: ["box.delete(id) → void"]
                        },
                        "box.get_left": {
                            kind: "Built-in function",
                            desc: [a("Returns the bar index or the UNIX time (depending on the last value used for 'xloc') of the left border of the box.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("A bar index or a UNIX timestamp (in milliseconds).", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }],
                            seeAlso: ["{@fun box.new}, {@fun box.set_left}"],
                            syntax: ["box.get_left(id) → series int"]
                        },
                        "box.get_right": {
                            kind: "Built-in function",
                            desc: [a("Returns the bar index or the UNIX time (depending on the last value used for 'xloc') of the right border of the box.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("A bar index or a UNIX timestamp (in milliseconds).", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }],
                            seeAlso: ["{@fun box.new}, {@fun box.set_right}"],
                            syntax: ["box.get_right(id) → series int"]
                        },
                        "box.get_top": {
                            kind: "Built-in function",
                            desc: [a("Returns the price value of the top border of the box.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The price value.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }],
                            seeAlso: ["{@fun box.new}, {@fun box.set_top}"],
                            syntax: ["box.get_top(id) → series float"]
                        },
                        "box.get_bottom": {
                            kind: "Built-in function",
                            desc: [a("Returns the price value of the bottom border of the box.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The price value.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }],
                            seeAlso: ["{@fun box.new}, {@fun box.set_bottom}"],
                            syntax: ["box.get_bottom(id) → series float"]
                        },
                        "box.set_left": {
                            kind: "Built-in function",
                            desc: [a("Sets the left coordinate of the box.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "left",
                                info: a("Bar index or bar time of the left border. Note that objects positioned using {@var xloc.bar_index} cannot be drawn further than 500 bars into the future.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun box.new}, {@fun box.get_left}"],
                            syntax: ["box.set_left(id, left) → void"]
                        },
                        "box.set_lefttop": {
                            kind: "Built-in function",
                            desc: [a("Sets the left and top coordinates of the box.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "left",
                                info: a("Bar index or bar time of the left border.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "top",
                                info: a("Price value of the top border.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun box.new}, {@fun box.get_left}, {@fun box.get_top}"],
                            syntax: ["box.set_lefttop(id, left, top) → void"]
                        },
                        "box.set_right": {
                            kind: "Built-in function",
                            desc: [a("Sets the right coordinate of the box.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "right",
                                info: a("Bar index or bar time of the right border. Note that objects positioned using {@var xloc.bar_index} cannot be drawn further than 500 bars into the future.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun box.new}, {@fun box.get_right}"],
                            syntax: ["box.set_right(id, right) → void"]
                        },
                        "box.set_rightbottom": {
                            kind: "Built-in function",
                            desc: [a("Sets the right and bottom coordinates of the box.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "right",
                                info: a("Bar index or bar time of the right border.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "bottom",
                                info: a("Price value of the bottom border.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun box.new}, {@fun box.get_right}, {@fun box.get_bottom}"],
                            syntax: ["box.set_rightbottom(id, right, bottom) → void"]
                        },
                        "box.set_top": {
                            kind: "Built-in function",
                            desc: [a("Sets the top coordinate of the box.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "top",
                                info: a("Price value of the top border.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun box.new}, {@fun box.get_top}"],
                            syntax: ["box.set_top(id, top) → void"]
                        },
                        "box.set_bottom": {
                            kind: "Built-in function",
                            desc: [a("Sets the bottom coordinate of the box.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "bottom",
                                info: a("Price value of the bottom border.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun box.new}, {@fun box.get_bottom}"],
                            syntax: ["box.set_bottom(id, bottom) → void"]
                        },
                        "box.set_border_color": {
                            kind: "Built-in function",
                            desc: [a("Sets the border color of the box.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "color",
                                info: a("New border color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            seeAlso: ["{@fun box.new}"],
                            syntax: ["box.set_border_color(id, color) → void"]
                        },
                        "box.set_bgcolor": {
                            kind: "Built-in function",
                            desc: [a("Sets the background color of the box.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "color",
                                info: a("New background color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            seeAlso: ["{@fun box.new}"],
                            syntax: ["box.set_bgcolor(id, color) → void"]
                        },
                        "box.set_border_width": {
                            kind: "Built-in function",
                            desc: [a("Sets the border width of the box.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "width",
                                info: a("Width of the four borders, in pixels.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun box.new}"],
                            syntax: ["box.set_border_width(id, width) → void"]
                        },
                        "box.set_border_style": {
                            kind: "Built-in function",
                            desc: [a("Sets the border style of the box.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "style",
                                info: a("New border style.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun box.new}", "{@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}"],
                            syntax: ["box.set_border_style(id, style) → void"]
                        },
                        "box.set_extend": {
                            kind: "Built-in function",
                            desc: [a("Sets extending type of the border of this box object. When {@var extend.none} is used, the horizontal borders start at the left border and end at the right border. With {@var extend.left} or {@var extend.right}, the horizontal borders are extended indefinitely to the left or right of the box, respectively. With {@var extend.both}, the horizontal borders are extended on both sides.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "extend",
                                info: a("New extending type.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun box.new}", "{@var extend.none}, {@var extend.right}, {@var extend.left}, {@var extend.both}"],
                            syntax: ["box.set_extend(id, extend) → void"]
                        },
                        "box.set_text_halign": {
                            kind: "Built-in function",
                            desc: [a("The function sets the horizontal alignment of the box's text.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "text_halign",
                                info: a("The horizontal alignment of a box's text. Possible values: {@var text.align_left}, {@var text.align_center}, {@var text.align_right}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun box.set_text}, {@fun box.set_text_size}, {@fun box.set_text_valign}, {@fun box.set_text_color}"],
                            syntax: ["box.set_text_halign(id, text_halign) → void"]
                        },
                        "box.set_text_valign": {
                            kind: "Built-in function",
                            desc: [a("The function sets the vertical alignment of a box's text.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "text_valign",
                                info: a("The vertical alignment of the box's text. Possible values: {@var text.align_top}, {@var text.align_center}, {@var text.align_bottom}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun box.set_text}, {@fun box.set_text_size}, {@fun box.set_text_color}, {@fun box.set_text_halign}"],
                            syntax: ["box.set_text_valign(id, text_valign) → void"]
                        },
                        "box.set_text_size": {
                            kind: "Built-in function",
                            desc: [a("The function sets the size of the box's text.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "text_size",
                                info: a("The size of the text. Possible values: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun box.set_text}, {@fun box.set_text_color}, {@fun box.set_text_valign}, {@fun box.set_text_halign}"],
                            syntax: ["box.set_text_size(id, text_size) → void"]
                        },
                        "box.set_text": {
                            kind: "Built-in function",
                            desc: [a("The function sets the text in the box.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "text",
                                info: a("The text to be displayed inside the box.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun box.set_text_color}, {@fun box.set_text_size}, {@fun box.set_text_valign}, {@fun box.set_text_halign}"],
                            syntax: ["box.set_text(id, text) → void"]
                        },
                        "box.set_text_color": {
                            kind: "Built-in function",
                            desc: [a("The function sets the color of the text inside the box.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "text_color",
                                info: a("The color of the text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            seeAlso: ["{@fun box.set_text}, {@fun box.set_text_size}, {@fun box.set_text_valign}, {@fun box.set_text_halign}"],
                            syntax: ["box.set_text_color(id, text_color) → void"]
                        },
                        "line.copy": {
                            kind: "Built-in function",
                            desc: [a("Clones the line object.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("New line ID object which may be passed to line.setXXX and line.getXXX functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }],
                            examples: ["//@version=5", "indicator('Last 100 bars price range', overlay = true)", "LOOKBACK = 100", "highest = ta.highest(LOOKBACK)", "lowest = ta.lowest(LOOKBACK)", "if barstate.islastconfirmedhistory", "\tvar lineTop = line.new(bar_index[LOOKBACK], highest, bar_index, highest, color = color.green)", "\tvar lineBottom = line.copy(lineTop)", "\tline.set_y1(lineBottom, lowest)", "\tline.set_y2(lineBottom, lowest)", "\tline.set_color(lineBottom, color.red)"],
                            seeAlso: ["{@fun line.new}, {@fun line.delete}"],
                            syntax: ["line.copy(id) → series line"]
                        },
                        "box.set_text_wrap": {
                            kind: "Built-in function",
                            desc: [a("The function sets the mode of wrapping of the text inside the box.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A box object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }, {
                                name: "text_wrap",
                                info: a("The mode of the wrapping. Possible values: {@var text.wrap_auto}, {@var text.wrap_none}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun box.set_text}, {@fun box.set_text_size}, {@fun box.set_text_valign}, {@fun box.set_text_halign}, {@fun box.set_text_color}"],
                            syntax: ["box.set_text_wrap(id, text_wrap) → void"]
                        },
                        "line.new": {
                            kind: "Built-in function",
                            desc: [a("Creates new line object.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Line ID object which may be passed to line.setXXX and line.getXXX functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "x1",
                                info: a("Bar index (if xloc = {@var xloc.bar_index}) or bar UNIX time (if xloc = {@var xloc.bar_time}) of the first point of the line. Note that objects positioned using {@var xloc.bar_index} cannot be drawn further than 500 bars into the future.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "y1",
                                info: a("Price of the first point of the line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "x2",
                                info: a("Bar index (if xloc = {@var xloc.bar_index}) or bar UNIX time (if xloc = {@var xloc.bar_time}) of the second point of the line. Note that objects positioned using {@var xloc.bar_index} cannot be drawn further than 500 bars into the future.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "y2",
                                info: a("Price of the second point of the line.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "xloc",
                                info: a("See description of {b_on}x1{b_off} argument. Possible values: {@var xloc.bar_index} and {@var xloc.bar_time}. Default is {@var xloc.bar_index}.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }),
                                type: "series string"
                            }, {
                                name: "extend",
                                info: a("If extend={@var extend.none}, draws segment starting at point (x1, y1) and ending at point (x2, y2). If extend is equal to {@var extend.right} or {@var extend.left}, draws a ray starting at point (x1, y1) or (x2, y2), respectively. If extend={@var extend.both}, draws a straight line that goes through these points. Default value is {@var extend.none}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "color",
                                info: a("Line color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "style",
                                info: a("Line style. Possible values: {@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}, {@var line.style_arrow_left}, {@var line.style_arrow_right}, {@var line.style_arrow_both}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "width",
                                info: a("Line width in pixels.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("line.new")', "var line1 = line.new(0, low, bar_index, high, extend=extend.right)", "var line2 = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, style=line.style_dashed)", "line.set_x2(line1, 0)", "line.set_xloc(line1, time, time + 60 * 60 * 24, xloc.bar_time)", "line.set_color(line2, color.green)", "line.set_width(line2, 5)"],
                            seeAlso: ["{@fun line.delete}, {@fun line.set_x1}, {@fun line.set_y1}, {@fun line.set_xy1}, {@fun line.set_x2}, {@fun line.set_y2}, {@fun line.set_xy2}, {@fun line.set_xloc}, {@fun line.set_color}, {@fun line.set_extend}, {@fun line.set_style}, {@fun line.set_width}"],
                            syntax: ["line.new(x1, y1, x2, y2, xloc, extend, color, style, width) → series line"]
                        },
                        "line.set_x1": {
                            kind: "Built-in function",
                            desc: [a("Sets bar index or bar time (depending on the xloc) of the first point.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "x",
                                info: a("Bar index or bar time. Note that objects positioned using {@var xloc.bar_index} cannot be drawn further than 500 bars into the future.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.set_x1(id, x) → void"]
                        },
                        "line.set_y1": {
                            kind: "Built-in function",
                            desc: [a("Sets price of the first point", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "y",
                                info: a("Price.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.set_y1(id, y) → void"]
                        },
                        "line.set_xy1": {
                            kind: "Built-in function",
                            desc: [a("Sets bar index/time and price of the first point.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "x",
                                info: a("Bar index or bar time. Note that objects positioned using {@var xloc.bar_index} cannot be drawn further than 500 bars into the future.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "y",
                                info: a("Price.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.set_xy1(id, x, y) → void"]
                        },
                        "line.set_x2": {
                            kind: "Built-in function",
                            desc: [a("Sets bar index or bar time (depending on the xloc) of the second point.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "x",
                                info: a("Bar index or bar time. Note that objects positioned using {@var xloc.bar_index} cannot be drawn further than 500 bars into the future.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.set_x2(id, x) → void"]
                        },
                        "line.set_y2": {
                            kind: "Built-in function",
                            desc: [a("Sets price of the second point.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "y",
                                info: a("Price.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.set_y2(id, y) → void"]
                        },
                        "line.set_xy2": {
                            kind: "Built-in function",
                            desc: [a("Sets bar index/time and price of the second point", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "x",
                                info: a("Bar index or bar time.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "y",
                                info: a("Price.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.set_xy2(id, x, y) → void"]
                        },
                        "line.set_xloc": {
                            kind: "Built-in function",
                            desc: [a("Sets x-location and new bar index/time values.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "x1",
                                info: a("Bar index or bar time of the first point.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "x2",
                                info: a("Bar index or bar time of the second point.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "xloc",
                                info: a("New x-location value.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@var xloc.bar_index}, {@var xloc.bar_time}, {@fun line.new}"],
                            syntax: ["line.set_xloc(id, x1, x2, xloc) → void"]
                        },
                        "line.set_extend": {
                            kind: "Built-in function",
                            desc: [a("Sets extending type of this line object. If extend={@var extend.none}, draws segment starting at point (x1, y1) and ending at point (x2, y2). If extend is equal to {@var extend.right} or {@var extend.left}, draws a ray starting at point (x1, y1) or (x2, y2), respectively. If extend={@var extend.both}, draws a straight line that goes through these points.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "extend",
                                info: a("New extending type.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@var extend.none}, {@var extend.right}, {@var extend.left}, {@var extend.both}, {@fun line.new}"],
                            syntax: ["line.set_extend(id, extend) → void"]
                        },
                        "line.set_color": {
                            kind: "Built-in function",
                            desc: [a("Sets the line color", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "color",
                                info: a("New line color", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.set_color(id, color) → void"]
                        },
                        "line.set_style": {
                            kind: "Built-in function",
                            desc: [a("Sets the line style", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "style",
                                info: a("New line style.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}, {@var line.style_arrow_left}, {@var line.style_arrow_right}, {@var line.style_arrow_both}, {@fun line.new}"],
                            syntax: ["line.set_style(id, style) → void"]
                        },
                        "line.set_width": {
                            kind: "Built-in function",
                            desc: [a("Sets the line width.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "width",
                                info: a("New line width in pixels.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.set_width(id, width) → void"]
                        },
                        "line.delete": {
                            kind: "Built-in function",
                            desc: [a("Deletes the specified line object. If it has already been deleted, does nothing.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object to delete.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.delete(id) → void"]
                        },
                        "line.get_x1": {
                            kind: "Built-in function",
                            desc: [a("Returns UNIX time or bar index (depending on the last xloc value set) of the first point of the line.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("UNIX timestamp (in milliseconds) or bar index.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }],
                            examples: ["//@version=5", 'indicator("line.get_x1")', "my_line = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)", "a = line.get_x1(my_line)", "plot(time - line.get_x1(my_line)) //draws zero plot"],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.get_x1(id) → series int"]
                        },
                        "line.get_y1": {
                            kind: "Built-in function",
                            desc: [a("Returns price of the first point of the line.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Price value.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.get_y1(id) → series float"]
                        },
                        "line.get_x2": {
                            kind: "Built-in function",
                            desc: [a("Returns UNIX time or bar index (depending on the last xloc value set) of the second point of the line.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("UNIX timestamp (in milliseconds) or bar index.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.get_x2(id) → series int"]
                        },
                        "line.get_y2": {
                            kind: "Built-in function",
                            desc: [a("Returns price of the second point of the line.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Price value.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.get_y2(id) → series float"]
                        },
                        "line.get_price": {
                            kind: "Built-in function",
                            desc: [a("Returns the price level of a line at a given bar index.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Price value of line 'id' at bar index 'x'.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "x",
                                info: a("Bar index for which price is required.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            remarks: [a("The line is considered to have been created using 'extend=extend.both'.", {
                                context: "pine_docs_remarks"
                            }), a("This function can only be called for lines created using 'xloc.bar_index'. If you try to call it for a line created with 'xloc.bar_time', it will generate an error.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("GetPrice", overlay=true)', "var line l = na", "if bar_index == 10", "    l := line.new(0, high[5], bar_index, high)", "plot(line.get_price(l, bar_index), color=color.green)"],
                            seeAlso: ["{@fun line.new}"],
                            syntax: ["line.get_price(id, x) → series float"]
                        },
                        "label.copy": {
                            kind: "Built-in function",
                            desc: [a("Clones the label object.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("New label ID object which may be passed to label.setXXX and label.getXXX functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }],
                            examples: ["//@version=5", "indicator('Last 100 bars highest/lowest', overlay = true)", "LOOKBACK = 100", "highest = ta.highest(LOOKBACK)", "highestBars = ta.highestbars(LOOKBACK)", "lowest = ta.lowest(LOOKBACK)", "lowestBars = ta.lowestbars(LOOKBACK)", "if barstate.islastconfirmedhistory", "\tvar labelHigh = label.new(bar_index + highestBars, highest, str.tostring(highest), color = color.green)", "\tvar labelLow = label.copy(labelHigh)", "\tlabel.set_xy(labelLow, bar_index + lowestBars, lowest)", "\tlabel.set_text(labelLow, str.tostring(lowest))", "\tlabel.set_color(labelLow, color.red)", "\tlabel.set_style(labelLow, label.style_label_up)"],
                            seeAlso: ["{@fun label.new}, {@fun label.delete}"],
                            syntax: ["label.copy(id) → series label"]
                        },
                        "linefill.new": {
                            kind: "Built-in function",
                            desc: [a("Creates a new linefill object and displays it on the chart, filling the space between `line1` and `line2` with the color specified in `color`.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of a linefill object that can be passed to other linefill.*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "line1",
                                info: a("First line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "line2",
                                info: a("Second line object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }, {
                                name: "color",
                                info: a("The color used to fill the space between the lines.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            remarks: [a("If any line of the two is deleted, the linefill object is also deleted. If the lines are moved (e.g. via {@fun line.set_xy} functions), the linefill object is also moved.", {
                                context: "pine_docs_remarks"
                            }), a("If both lines are extended in the same direction relative to the lines themselves (e.g. both have {@var extend.right} as the value of their `extend=` parameter), the space between line extensions will also be filled.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["linefill.new(line1, line2, color) → series linefill"]
                        },
                        "linefill.delete": {
                            kind: "Built-in function",
                            desc: [a("Deletes the specified linefill object. If it has already been deleted, does nothing.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A linefill object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series linefill"
                            }],
                            syntax: ["linefill.delete(id) → void"]
                        },
                        "linefill.set_color": {
                            kind: "Built-in function",
                            desc: [a("The function sets the color of the linefill object passed to it.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A linefill object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series linefill"
                            }, {
                                name: "color",
                                info: a("The color of the linefill object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            syntax: ["linefill.set_color(id, color) → void"]
                        },
                        "linefill.get_line1": {
                            kind: "Built-in function",
                            desc: [a("Returns the ID of the first line used in the `id` linefill.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A linefill object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series linefill"
                            }],
                            syntax: ["linefill.get_line1(id) → series line"]
                        },
                        "linefill.get_line2": {
                            kind: "Built-in function",
                            desc: [a("Returns the ID of the second line used in the `id` linefill.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A linefill object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series linefill"
                            }],
                            syntax: ["linefill.get_line2(id) → series line"]
                        },
                        "array.new_linefill": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new array object of linefill type elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of an array object which may be used in other array.*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "size",
                                info: a("Initial size of an array.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "initial_value",
                                info: a("Initial value of all array elements.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series linefill"
                            }],
                            remarks: [a("An array index starts from 0.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["array.new_linefill(size, initial_value) → linefill[]"]
                        },
                        "label.new": {
                            kind: "Built-in function",
                            desc: [a("Creates new label object.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Label ID object which may be passed to label.setXXX and label.getXXX functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "x",
                                info: a("Bar index (if xloc = {@var xloc.bar_index}) or bar UNIX time (if xloc = {@var xloc.bar_time}) of the label position. Note that objects positioned using {@var xloc.bar_index} cannot be drawn further than 500 bars into the future.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "y",
                                info: a("Price of the label position. It is taken into account only if yloc={@var yloc.price}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "text",
                                info: a("Label text. Default is empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "xloc",
                                info: a("See description of {b_on}x{b_off} argument. Possible values: {@var xloc.bar_index} and {@var xloc.bar_time}. Default is {@var xloc.bar_index}.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }),
                                type: "series string"
                            }, {
                                name: "yloc",
                                info: a("Possible values are {@var yloc.price}, {@var yloc.abovebar}, {@var yloc.belowbar}. If yloc={@var yloc.price}, {b_on}y{b_off} argument specifies the price of the label position. If yloc={@var yloc.abovebar}, label is located above bar. If yloc={@var yloc.belowbar}, label is located below bar. Default is {@var yloc.price}.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    b_on: "<b>",
                                    b_off: "</b>"
                                }),
                                type: "series string"
                            }, {
                                name: "color",
                                info: a("Color of the label border and arrow", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "style",
                                info: a("Label style. Possible values: {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}. Default is {@var label.style_label_down}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "textcolor",
                                info: a("Text color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "size",
                                info: a("Label size. Possible values: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}. Default value is {@var size.normal}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "textalign",
                                info: a("Label text alignment. Possible values: {@var text.align_left}, {@var text.align_center}, {@var text.align_right}. Default value is {@var text.align_center}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "tooltip",
                                info: a("Hover to see tooltip label.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            examples: ["//@version=5", 'indicator("label.new")', 'var label1 = label.new(bar_index, low, text="Hello, world!", style=label.style_circle)', "label.set_x(label1, 0)", "label.set_xloc(label1, time, xloc.bar_time)", "label.set_color(label1, color.red)", "label.set_size(label1, size.large)"],
                            seeAlso: ["{@fun label.delete}, {@fun label.set_x}, {@fun label.set_y}, {@fun label.set_xy}, {@fun label.set_xloc}, {@fun label.set_yloc}, {@fun label.set_color}, {@fun label.set_textcolor}, {@fun label.set_style}, {@fun label.set_size}, {@fun label.set_textalign}, {@fun label.set_tooltip}"],
                            syntax: ["label.new(x, y, text, xloc, yloc, color, style, textcolor, size, textalign, tooltip) → series label"]
                        },
                        "label.set_x": {
                            kind: "Built-in function",
                            desc: [a("Sets bar index or bar time (depending on the xloc) of the label position.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }, {
                                name: "x",
                                info: a("New bar index or bar time of the label position. Note that objects positioned using {@var xloc.bar_index} cannot be drawn further than 500 bars into the future.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun label.new}"],
                            syntax: ["label.set_x(id, x) → void"]
                        },
                        "label.set_y": {
                            kind: "Built-in function",
                            desc: [a("Sets price of the label position", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }, {
                                name: "y",
                                info: a("New price of the label position.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun label.new}"],
                            syntax: ["label.set_y(id, y) → void"]
                        },
                        "label.set_xy": {
                            kind: "Built-in function",
                            desc: [a("Sets bar index/time and price of the label position.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }, {
                                name: "x",
                                info: a("New bar index or bar time of the label position. Note that objects positioned using {@var xloc.bar_index} cannot be drawn further than 500 bars into the future.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "y",
                                info: a("New price of the label position.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun label.new}"],
                            syntax: ["label.set_xy(id, x, y) → void"]
                        },
                        "label.set_xloc": {
                            kind: "Built-in function",
                            desc: [a("Sets x-location and new bar index/time value.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }, {
                                name: "x",
                                info: a("New bar index or bar time of the label position.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "xloc",
                                info: a("New x-location value.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@var xloc.bar_index}, {@var xloc.bar_time}, {@fun label.new}"],
                            syntax: ["label.set_xloc(id, x, xloc) → void"]
                        },
                        "label.set_yloc": {
                            kind: "Built-in function",
                            desc: [a("Sets new y-location calculation algorithm.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }, {
                                name: "yloc",
                                info: a("New y-location value.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@var yloc.price}, {@var yloc.abovebar}, {@var yloc.belowbar}, {@fun label.new}"],
                            syntax: ["label.set_yloc(id, yloc) → void"]
                        },
                        "label.set_text": {
                            kind: "Built-in function",
                            desc: [a("Sets label text", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }, {
                                name: "text",
                                info: a("New label text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun label.new}"],
                            syntax: ["label.set_text(id, text) → void"]
                        },
                        "label.set_color": {
                            kind: "Built-in function",
                            desc: [a("Sets label border and arrow color.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }, {
                                name: "color",
                                info: a("New label border and arrow color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            seeAlso: ["{@fun label.new}"],
                            syntax: ["label.set_color(id, color) → void"]
                        },
                        "label.set_style": {
                            kind: "Built-in function",
                            desc: [a("Sets label style.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }, {
                                name: "style",
                                info: a("New label style. Possible values: {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun label.new}"],
                            syntax: ["label.set_style(id, style) → void"]
                        },
                        "label.set_textcolor": {
                            kind: "Built-in function",
                            desc: [a("Sets color of the label text.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }, {
                                name: "textcolor",
                                info: a("New text color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            seeAlso: ["{@fun label.new}"],
                            syntax: ["label.set_textcolor(id, textcolor) → void"]
                        },
                        "label.set_size": {
                            kind: "Built-in function",
                            desc: [a("Sets arrow and text size of the specified label object.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }, {
                                name: "size",
                                info: a("Possible values: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}. Default value is {@var size.auto}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}, {@fun label.new}"],
                            syntax: ["label.set_size(id, size) → void"]
                        },
                        "label.set_textalign": {
                            kind: "Built-in function",
                            desc: [a("Sets the alignment for the label text.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }, {
                                name: "textalign",
                                info: a("Label text alignment. Possible values: {@var text.align_left}, {@var text.align_center}, {@var text.align_right}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@var text.align_left}, {@var text.align_center}, {@var text.align_right}, {@fun label.new}"],
                            syntax: ["label.set_textalign(id, textalign) → void"]
                        },
                        "label.set_tooltip": {
                            kind: "Built-in function",
                            desc: [a("Sets the tooltip text.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }, {
                                name: "tooltip",
                                info: a("Tooltip text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun label.new}"],
                            syntax: ["label.set_tooltip(id, tooltip) → void"]
                        },
                        "label.delete": {
                            kind: "Built-in function",
                            desc: [a("Deletes the specified label object. If it has already been deleted, does nothing.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object to delete.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }],
                            seeAlso: ["{@fun label.new}"],
                            syntax: ["label.delete(id) → void"]
                        },
                        "label.get_x": {
                            kind: "Built-in function",
                            desc: [a("Returns UNIX time or bar index (depending on the last xloc value set) of this label's position.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("UNIX timestamp (in milliseconds) or bar index.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }],
                            examples: ["//@version=5", 'indicator("label.get_x")', 'my_label = label.new(time, open, text="Open bar text", xloc=xloc.bar_time)', "a = label.get_x(my_label)", "plot(time - label.get_x(my_label)) //draws zero plot"],
                            seeAlso: ["{@fun label.new}"],
                            syntax: ["label.get_x(id) → series int"]
                        },
                        "label.get_y": {
                            kind: "Built-in function",
                            desc: [a("Returns price of this label's position.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Floating point value representing price.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }],
                            seeAlso: ["{@fun label.new}"],
                            syntax: ["label.get_y(id) → series float"]
                        },
                        "label.get_text": {
                            kind: "Built-in function",
                            desc: [a("Returns the text of this label object.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("String object containing the text of this label.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Label object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }],
                            examples: ["//@version=5", 'indicator("label.get_text")', 'my_label = label.new(time, open, text="Open bar text", xloc=xloc.bar_time)', "a = label.get_text(my_label)", 'label.new(time, close, text = a + " new", xloc=xloc.bar_time)'],
                            seeAlso: ["{@fun label.new}"],
                            syntax: ["label.get_text(id) → series string"]
                        },
                        max_bars_back: {
                            kind: "Built-in function",
                            desc: [a("Function sets the maximum number of bars that is available for historical reference of a given built-in or user variable. When operator '[]' is applied to a variable - it is a reference to a historical value of that variable.", {
                                context: "pine_docs_desc"
                            }), a("", {
                                context: "pine_docs_desc"
                            }), a("If an argument of an operator '[]' is a compile time constant value (e.g. 'v[10]', 'close[500]') then there is no need to use 'max_bars_back' function for that variable. Pine Script™ compiler will use that constant value as history buffer size.", {
                                context: "pine_docs_desc"
                            }), a("", {
                                context: "pine_docs_desc"
                            }), a("If an argument of an operator '[]' is a value, calculated at runtime (e.g. 'v[i]' where 'i' - is a series variable) then Pine Script™ attempts to autodetect the history buffer size at runtime. Sometimes it fails and the script crashes at runtime because it eventually refers to historical values that are out of the buffer. In that case you should use 'max_bars_back' to fix that problem manually.", {
                                context: "pine_docs_desc"
                            })],
                            returns: ["void"],
                            args: [{
                                name: "var",
                                info: a("Series variable identifier for which history buffer should be resized. Possible values are: 'open', 'high', 'low', 'close', 'volume', 'time', or any user defined variable id.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float/bool/color/label/line"
                            }, {
                                name: "num",
                                info: a("History buffer size which is the number of bars that could be referenced for variable 'var'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const int"
                            }],
                            remarks: [a("At the moment 'max_bars_back' cannot be applied to built-ins like 'hl2', 'hlc3', 'ohlc4'. Please use multiple 'max_bars_back' calls as workaround here (e.g. instead of a single ‘max_bars_back(hl2, 100)’ call you should call the function twice: ‘max_bars_back(high, 100), max_bars_back(low, 100)’).", {
                                context: "pine_docs_remarks"
                            }), a("", {
                                context: "pine_docs_remarks"
                            }), a("If the {@fun indicator} or {@fun strategy} 'max_bars_back' parameter is used, all variables in the indicator are affected. This may result in excessive memory usage and cause runtime problems. When possible (i.e. when the cause is a variable rather than a function), please use the {@fun max_bars_back} function instead.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("max_bars_back")', "close_() => close", "depth() => 400", "d = depth()", "v = close_()", "max_bars_back(v, 500)", "out = if bar_index > 0", "\tv[d]", "else", "\tv", "plot(out)"],
                            seeAlso: ["Param 'max_bars_back' of {@fun indicator} and {@fun strategy} functions."],
                            syntax: ["max_bars_back(var, num) → void"]
                        },
                        "array.new<type>": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new array object of &lt;type&gt; elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of an array object which may be used in other array.*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["array.new&lt;int&gt;(size, initial_value) → int[]", "array.new&lt;float&gt;(size, initial_value) → float[]", "array.new&lt;bool&gt;(size, initial_value) → bool[]", "array.new&lt;string&gt;(size, initial_value) → string[]", "array.new&lt;color&gt;(size, initial_value) → color[]", "array.new&lt;line&gt;(size, initial_value) → line[]", "array.new&lt;label&gt;(size, initial_value) → label[]", "array.new&lt;box&gt;(size, initial_value) → box[]", "array.new&lt;table&gt;(size, initial_value) → table[]", "array.new&lt;linefill&gt;(size, initial_value) → linefill[]"],
                            args: [{
                                name: "size",
                                info: a("Initial size of an array. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "initial_value",
                                type: "series &lt;type&gt;",
                                info: a("Initial value of all array elements. Optional. The default is 'na'.", {
                                    context: "pine_docs_args_info"
                                })
                            }],
                            examples: ["//@version=5", 'indicator("array.new&lt;string&gt; example")', 'a = array.new&lt;string&gt;(1, "Hello, World!")', "label.new(bar_index, close, array.get(a, 0))"],
                            remarks: [a("An array index starts from 0.", {
                                context: "pine_docs_remarks"
                            }), a("If you want to initialize an array and specify all its elements at the same time, then use the function array.from.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun array.from}, {@fun array.push}, {@fun array.get}, {@fun array.size}, {@fun array.remove}, {@fun array.shift}, {@fun array.sum}"],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'indicator("array.new&lt;color&gt; example")', "a = array.new&lt;color&gt;()", "array.push(a, color.red)", "array.push(a, color.green)", "plot(close, color = array.get(a, close > open ? 1 : 0))"]
                            }, {
                                desc: [],
                                examples: ["//@version=5", 'indicator("array.new&lt;float&gt; example")', "length = 5", "var a = array.new&lt;float&gt;(length, close)", "if array.size(a) == length", "\tarray.remove(a, 0)", "\tarray.push(a, close)", 'plot(array.sum(a) / length, "SMA")']
                            }, {
                                desc: [],
                                examples: ["//@version=5", 'indicator("array.new&lt;line&gt; example")', "// draw last 15 lines", "var a = array.new&lt;line&gt;()", "array.push(a, line.new(bar_index - 1, close[1], bar_index, close))", "if array.size(a) > 15", "    ln = array.shift(a)", "    line.delete(ln)"]
                            }]
                        },
                        "array.new_float": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new array object of float type elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of an array object which may be used in other array.*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "size",
                                info: a("Initial size of an array. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "initial_value",
                                info: a("Initial value of all array elements. Optional. The default is 'na'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            examples: ["//@version=5", 'indicator("array.new_float example")', "length = 5", "a = array.new_float(length, close)", "plot(array.sum(a) / length)"],
                            remarks: [a("An array index starts from 0.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun array.new_color}, {@fun array.new_bool}, {@fun array.get}, {@fun array.slice}, {@fun array.sort}"],
                            syntax: ["array.new_float(size, initial_value) → float[]"]
                        },
                        "array.new_int": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new array object of int type elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of an array object which may be used in other array.*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "size",
                                info: a("Initial size of an array. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "initial_value",
                                info: a("Initial value of all array elements. Optional. The default is 'na'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("array.new_int example")', "length = 5", "a = array.new_int(length, int(close))", "plot(array.sum(a) / length)"],
                            remarks: [a("An array index starts from 0.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}, {@fun array.sort}"],
                            syntax: ["array.new_int(size, initial_value) → int[]"]
                        },
                        "array.new_color": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new array object of color type elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of an array object which may be used in other array.*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "size",
                                info: a("Initial size of an array. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "initial_value",
                                info: a("Initial value of all array elements. Optional. The default is 'na'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            examples: ["//@version=5", 'indicator("array.new_color example")', "length = 5", "a = array.new_color(length, color.red)", "plot(close, color = array.get(a, 0))"],
                            remarks: [a("An array index starts from 0.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}, {@fun array.sort}"],
                            syntax: ["array.new_color(size, initial_value) → color[]"]
                        },
                        "array.new_bool": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new array object of bool type elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of an array object which may be used in other array.*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "size",
                                info: a("Initial size of an array. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "initial_value",
                                info: a("Initial value of all array elements. Optional. The default is 'na'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }],
                            examples: ["//@version=5", 'indicator("array.new_bool example")', "length = 5", "a = array.new_bool(length, close > open)", "plot(array.get(a, 0) ? close : open)"],
                            remarks: [a("An array index starts from 0.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}, {@fun array.sort}"],
                            syntax: ["array.new_bool(size, initial_value) → bool[]"]
                        },
                        "array.new_string": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new array object of string type elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of an array object which may be used in other array.*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "size",
                                info: a("Initial size of an array. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "initial_value",
                                info: a("Initial value of all array elements. Optional. The default is 'na'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            examples: ["//@version=5", 'indicator("array.new_string example")', "length = 5", 'a = array.new_string(length, "text")', "label.new(bar_index, close, array.get(a, 0))"],
                            remarks: [a("An array index starts from 0.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}"],
                            syntax: ["array.new_string(size, initial_value) → string[]"]
                        },
                        "array.new_line": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new array object of line type elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of an array object which may be used in other array.*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "size",
                                info: a("Initial size of an array. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "initial_value",
                                info: a("Initial value of all array elements. Optional. The default is 'na'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series line"
                            }],
                            examples: ["//@version=5", 'indicator("array.new_line example")', "// draw last 15 lines", "var a = array.new_line()", "array.push(a, line.new(bar_index - 1, close[1], bar_index, close))", "if array.size(a) > 15", "\tln = array.shift(a)", "\tline.delete(ln)"],
                            remarks: [a("An array index starts from 0.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}"],
                            syntax: ["array.new_line(size, initial_value) → line[]"]
                        },
                        "array.new_box": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new array object of box type elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of an array object which may be used in other array.*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "size",
                                info: a("Initial size of an array. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "initial_value",
                                info: a("Initial value of all array elements. Optional. The default is 'na'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series box"
                            }],
                            examples: ["//@version=5", 'indicator("array.new_box example")', "box[] boxes = array.new_box()", "array.push(boxes, box.new(time, close, time+2, low, xloc=xloc.bar_time))", "plot(1)"],
                            remarks: [a("An array index starts from 0.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}"],
                            syntax: ["array.new_box(size, initial_value) → box[]"]
                        },
                        "array.new_table": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new array object of table type elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of an array object which may be used in other array.*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "size",
                                info: a("Initial size of an array. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "initial_value",
                                info: a("Initial value of all array elements. Optional. The default is 'na'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }],
                            examples: ["//@version=5", 'indicator("table array")', "table[] tables = array.new_table()", "array.push(tables, table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1))", "plot(1)"],
                            remarks: [a("An array index starts from 0.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}"],
                            syntax: ["array.new_table(size, initial_value) → table[]"]
                        },
                        "array.new_label": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new array object of label type elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of an array object which may be used in other array.*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "size",
                                info: a("Initial size of an array. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "initial_value",
                                info: a("Initial value of all array elements. Optional. The default is 'na'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series label"
                            }],
                            examples: ["//@version=5", 'indicator("array.new_label example")', "var a = array.new_label()", 'l = label.new(bar_index, close, "some text")', "array.push(a, l)", "if close > close[1] and close[1] > close[2]", "\t// remove all labels", "\tsize = array.size(a) - 1", "\tfor i = 0 to size", "\t\tlb = array.get(a, i)", "\t\tlabel.delete(lb)"],
                            remarks: [a("An array index starts from 0.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}"],
                            syntax: ["array.new_label(size, initial_value) → label[]"]
                        },
                        "array.copy": {
                            kind: "Built-in function",
                            desc: [a("The function creates a copy of an existing array.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("A copy of an array.", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["array.copy(id) → array"],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }],
                            examples: ["//@version=5", 'indicator("array.copy example")', "length = 5", "a = array.new_float(length, close)", "b = array.copy(a)", "a := array.new_float(length, open)", "plot(array.sum(a) / length)", "plot(array.sum(b) / length)"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}, {@fun array.sort}"]
                        },
                        "array.slice": {
                            kind: "Built-in function",
                            desc: [a("The function creates a slice from an existing array. If an object from the slice changes, the changes are applied to both the new and the original arrays.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("A shallow copy of an array's slice.", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["array.slice(id, index_from, index_to) → array"],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }, {
                                name: "index_from",
                                info: a("Zero-based index at which to begin extraction.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "index_to",
                                info: a("Zero-based index before which to end extraction. The function extracts up to but not including the element with this index.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("array.slice example")', "a = array.new_float(0)", "for i = 0 to 9", "\tarray.push(a, close[i])", "// take elements from 0 to 4", "// *note that changes in slice also modify original array ", "slice = array.slice(a, 0, 5)", "plot(array.sum(a) / 10)", "plot(array.sum(slice) / 5)"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}, {@fun array.sort}"]
                        },
                        "array.size": {
                            kind: "Built-in function",
                            desc: [a("The function returns the number of elements in an array.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The number of elements in the array.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }],
                            examples: ["//@version=5", 'indicator("array.size example")', "a = array.new_float(0)", "for i = 0 to 9", "\tarray.push(a, close[i])", "// note that changes in slice also modify original array", "slice = array.slice(a, 0, 5)", "array.push(slice, open)", "// size was changed in slice and in original array", "plot(array.size(a))", "plot(array.size(slice))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.sum}, {@fun array.slice}, {@fun array.sort}"],
                            syntax: ["array.size(id) → series int"]
                        },
                        "array.get": {
                            kind: "Built-in function",
                            desc: [a("The function returns the value of the element at the specified index.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The array element's value.", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["array.get(id, index) → series &lt;type of the array's elements&gt;"],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }, {
                                name: "index",
                                info: a("The index of the element whose value is to be returned.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("array.get example")', "a = array.new_float(0)", "for i = 0 to 9", "\tarray.push(a, close[i] - open[i])", "plot(array.get(a, 9))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.set}, {@fun array.slice}, {@fun array.sort}"]
                        },
                        "array.min": {
                            kind: "Built-in function",
                            desc: [a("The function returns the smallest value, or the nth smallest value in a given array.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The smallest or the nth smallest value in the array.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }, {
                                name: "nth",
                                info: a("The nth smallest value to return, where zero is the smallest. Optional. The default is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("array.min")', "a = array.from(5, -2, 0, 9, 1)", "secondLowest = array.min(a, 1) // 0", "plot(secondLowest)"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.max}, {@fun array.sum}"],
                            syntax: ["array.min(id) → series float", "array.min(id) → series int", "array.min(id, nth) → series float", "array.min(id, nth) → series int"]
                        },
                        "array.max": {
                            kind: "Built-in function",
                            desc: [a("The function returns the greatest value, or the nth greatest value in a given array.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The greatest or the nth greatest value in the array.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }, {
                                name: "nth",
                                info: a("The nth greatest value to return, where zero is the greatest. Optional. The default is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("array.max")', "a = array.from(5, -2, 0, 9, 1)", "secondHighest = array.max(a, 2) // 1", "plot(secondHighest)"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.min}, {@fun array.sum}"],
                            syntax: ["array.max(id) → series float", "array.max(id) → series int", "array.max(id, nth) → series float", "array.max(id, nth) → series int"]
                        },
                        "array.range": {
                            kind: "Built-in function",
                            desc: [a("The function returns the difference between the min and max values from a given array.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The difference between the min and max values in the array.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }],
                            examples: ["//@version=5", 'indicator("array.range example")', "a = array.new_float(0)", "for i = 0 to 9", "\tarray.push(a, close[i])", "plot(array.range(a))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.min}, {@fun array.max}, {@fun array.sum}"],
                            syntax: ["array.range(id) → series float", "array.range(id) → series int"]
                        },
                        "array.sum": {
                            kind: "Built-in function",
                            desc: [a("The function returns the sum of an array's elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The sum of the array's elements.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }],
                            examples: ["//@version=5", 'indicator("array.sum example")', "a = array.new_float(0)", "for i = 0 to 9", "\tarray.push(a, close[i])", "plot(array.sum(a))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.max}, {@fun array.min}"],
                            syntax: ["array.sum(id) → series float", "array.sum(id) → series int"]
                        },
                        "array.set": {
                            kind: "Built-in function",
                            desc: [a("The function sets the value of the element at the specified index.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }, {
                                name: "index",
                                info: a("The index of the element to be modified.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "value",
                                info: a("The new value to be set.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series <type of the array's elements>"
                            }],
                            examples: ["//@version=5", 'indicator("array.set example")', "a = array.new_float(10)", "for i = 0 to 9", "\tarray.set(a, i, close[i])", "plot(array.sum(a) / 10)"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}"],
                            syntax: ["array.set(id, index, value) → void"]
                        },
                        "array.from": {
                            kind: "Built-in function",
                            desc: [a("The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "arg0, arg1, ...",
                                info: a("Array arguments.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float/bool/color/string/label/line/box/table/linefill"
                            }],
                            returns: [a("The array element's value.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("array.from_example", overlay = false)', 'arr = array.from("Hello", "World!") // arr (string[]) will contain 2 elements: {Hello}, {World!}.', "plot(close)"],
                            syntax: ["array.from(arg0, arg1, ...) → type[]", "array.from(arg0, arg1, ...) → int[]", "array.from(arg0, arg1, ...) → float[]", "array.from(arg0, arg1, ...) → bool[]", "array.from(arg0, arg1, ...) → string[]", "array.from(arg0, arg1, ...) → label[]", "array.from(arg0, arg1, ...) → line[]", "array.from(arg0, arg1, ...) → color[]", "array.from(arg0, arg1, ...) → box[]", "array.from(arg0, arg1, ...) → table[]", "array.from(arg0, arg1, ...) → linefill[]"]
                        },
                        "array.fill": {
                            kind: "Built-in function",
                            desc: [a("The function sets elements of an array to a single value. If no index is specified, all elements are set. If only a start index (default 0) is supplied, the elements starting at that index are set. If both index parameters are used, the elements from the starting index up to but not including the end index (default na) are set.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }, {
                                name: "value",
                                info: a("Value to fill the array with.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series <type of the array's elements>"
                            }, {
                                name: "index_from",
                                info: a("Start index, default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "index_to",
                                info: a("End index, default is na. Must be one greater than the index of the last element to set.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("array.fill example")', "a = array.new_float(10)", "array.fill(a, close)", "plot(array.sum(a))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.set}, {@fun array.slice}"],
                            syntax: ["array.fill(id, value, index_from, index_to) → void"]
                        },
                        "array.insert": {
                            kind: "Built-in function",
                            desc: [a("The function changes the contents of an array by adding new elements in place.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }, {
                                name: "index",
                                info: a("The index at which to insert the value.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "value",
                                info: a("The value to add to the array.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series <type of the array's elements>"
                            }],
                            examples: ["//@version=5", 'indicator("array.insert example")', "a = array.new_float(5, close)", "array.insert(a, 0, open)", "plot(array.get(a, 5))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.set}, {@fun array.push}, {@fun array.remove}, {@fun array.pop}, {@fun array.unshift}"],
                            syntax: ["array.insert(id, index, value) → void"]
                        },
                        "array.join": {
                            kind: "Built-in function",
                            desc: [a("The function creates and returns a new string by concatenating all the elements of an array, separated by the specified separator string.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]/string[]"
                            }, {
                                name: "separator",
                                info: a("The string used to separate each array element.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            examples: ["//@version=5", 'indicator("array.join example")', "a = array.new_float(5, 5)", 'label.new(bar_index, close, array.join(a, ","))'],
                            seeAlso: ["{@fun array.new_float}, {@fun array.set}, {@fun array.insert}, {@fun array.remove}, {@fun array.pop}, {@fun array.unshift}"],
                            syntax: ["array.join(id, separator) → series string"]
                        },
                        "array.push": {
                            kind: "Built-in function",
                            desc: [a("The function appends a value to an array.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }, {
                                name: "value",
                                info: a("The value of the element added to the end of the array.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series <type of the array's elements>"
                            }],
                            examples: ["//@version=5", 'indicator("array.push example")', "a = array.new_float(5, 0)", "array.push(a, open)", "plot(array.get(a, 5))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.set}, {@fun array.insert}, {@fun array.remove}, {@fun array.pop}, {@fun array.unshift}"],
                            syntax: ["array.push(id, value) → void"]
                        },
                        "array.remove": {
                            kind: "Built-in function",
                            desc: [a("The function changes the contents of an array by removing the element with the specified index.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The value of the removed element.", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["array.remove(id, index) → series &lt;type of the array's elements&gt;"],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }, {
                                name: "index",
                                info: a("The index of the element to remove.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("array.remove example")', "a = array.new_float(5,high)", "removedEl = array.remove(a, 0)", "plot(array.size(a))", "plot(removedEl)"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.set}, {@fun array.push}, {@fun array.insert}, {@fun array.pop}, {@fun array.shift}"]
                        },
                        "array.pop": {
                            kind: "Built-in function",
                            desc: [a("The function removes the last element from an array and returns its value.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The value of the removed element.", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["array.pop(id) → series &lt;type of the array's elements&gt;"],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }],
                            examples: ["//@version=5", 'indicator("array.pop example")', "a = array.new_float(5,high)", "removedEl = array.pop(a)", "plot(array.size(a))", "plot(removedEl)"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.set}, {@fun array.push}, {@fun array.remove}, {@fun array.insert}, {@fun array.shift}"]
                        },
                        "array.clear": {
                            kind: "Built-in function",
                            desc: [a("The function removes all elements from an array.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }],
                            examples: ["//@version=5", 'indicator("array.clear example")', "a = array.new_float(5,high)", "array.clear(a)", "array.push(a, close)", "plot(array.get(a,0))", "plot(array.size(a))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.insert}, {@fun array.push}, {@fun array.remove}, {@fun array.pop}"],
                            syntax: ["array.clear(id) → void"]
                        },
                        "array.sort": {
                            kind: "Built-in function",
                            desc: [a("The function sorts the elements of an array.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]/string[]"
                            }, {
                                name: "order",
                                info: a("The sort order: order.ascending (default) or order.descending.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "sort_order"
                            }],
                            examples: ["//@version=5", 'indicator("array.sort example")', "a = array.new_float(0,0)", "for i = 0 to 5", "\tarray.push(a, high[i])", "array.sort(a, order.descending)", "if barstate.islast", "\tlabel.new(bar_index, close, str.tostring(a))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.insert}, {@fun array.slice}, {@fun array.reverse}, {@var order.ascending}, {@var order.descending}"],
                            syntax: ["array.sort(id, order) → void"]
                        },
                        "array.sort_indices": {
                            kind: "Built-in function",
                            desc: [a("Returns an array of indices which, when used to index the original array, will access its elements in their sorted order. It does not modify the original array.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]/string[]"
                            }, {
                                name: "order",
                                info: a("The sort order: order.ascending or order.descending. Optional. The default is order.ascending.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "sort_order"
                            }],
                            examples: ["//@version=5", 'indicator("array.sort_indices")', "a = array.from(5, -2, 0, 9, 1)", "sortedIndices = array.sort_indices(a) // [1, 2, 4, 0, 3]", "indexOfSmallestValue = array.get(sortedIndices, 0) // 1", "smallestValue = array.get(a, indexOfSmallestValue) // -2", "plot(smallestValue)"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.insert}, {@fun array.slice}, {@fun array.reverse}, {@var order.ascending}, {@var order.descending}"],
                            syntax: ["array.sort_indices(id, order) → int[]"]
                        },
                        "array.percentrank": {
                            kind: "Built-in function",
                            desc: [a("Returns the percentile rank of a value in the array.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("Percentile rank is the percentage of how many elements in the array are less than or equal to the reference value.", {
                                context: "pine_docs_remarks"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }, {
                                name: "index",
                                info: a("The value for which to calculate its percentile rank.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun array.new_float}, {@fun array.insert}, {@fun array.slice}, {@fun array.reverse}, {@var order.ascending}, {@var order.descending}"],
                            syntax: ["array.percentrank(id, index) → series float", "array.percentrank(id, index) → series int"]
                        },
                        "array.percentile_nearest_rank": {
                            kind: "Built-in function",
                            desc: [a("Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using the nearest-rank method.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("In statistics, the percentile is the percent of ranking items that appear at or below a certain score. This measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring.", {
                                context: "pine_docs_remarks"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }, {
                                name: "percentage",
                                info: a("The percentage of values that must be equal or less than the returned value.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun array.new_float}, {@fun array.insert}, {@fun array.slice}, {@fun array.reverse}, {@var order.ascending}, {@var order.descending}"],
                            syntax: ["array.percentile_nearest_rank(id, percentage) → series float", "array.percentile_nearest_rank(id, percentage) → series int"]
                        },
                        "array.percentile_linear_interpolation": {
                            kind: "Built-in function",
                            desc: [a("Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using linear interpolation.", {
                                context: "pine_docs_desc"
                            })],
                            remarks: [a("In statistics, the percentile is the percent of ranking items that appear at or below a certain score. This measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring. Linear interpolation estimates the value between two ranks.", {
                                context: "pine_docs_remarks"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }, {
                                name: "percentage",
                                info: a("The percentage of values that must be equal or less than the returned value.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun array.new_float}, {@fun array.insert}, {@fun array.slice}, {@fun array.reverse}, {@var order.ascending}, {@var order.descending}"],
                            syntax: ["array.percentile_linear_interpolation(id, percentage) → series float", "array.percentile_linear_interpolation(id, percentage) → series int"]
                        },
                        "array.abs": {
                            kind: "Built-in function",
                            desc: [a("Returns an array containing the absolute value of each element in the original array.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }],
                            seeAlso: ["{@fun array.new_float}, {@fun array.insert}, {@fun array.slice}, {@fun array.reverse}, {@var order.ascending}, {@var order.descending}"],
                            syntax: ["array.abs(id) → float[]", "array.abs(id) → int[]"]
                        },
                        "array.binary_search": {
                            kind: "Built-in function",
                            desc: [a("The function returns the index of the value, or -1 if the value is not found. The array to search must be sorted in ascending order.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }, {
                                name: "val",
                                info: a("The value to search for in the array.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            examples: ["//@version=5", 'indicator("array.binary_search")', "a = array.from(5, -2, 0, 9, 1)", "array.sort(a) // [-2, 0, 1, 5, 9]", "position = array.binary_search(a, 0) // 1", "plot(position)"],
                            remarks: [a("A binary search works on arrays pre-sorted in ascending order. It begins by comparing an element in the middle of the array with the target value. If the element matches the target value, its position in the array is returned. If the element's value is greater than the target value, the search continues in the lower half of the array. If the element's value is less than the target value, the search continues in the upper half of the array. By doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun array.new_float}, {@fun array.insert}, {@fun array.slice}, {@fun array.reverse}, {@var order.ascending}, {@var order.descending}"],
                            syntax: ["array.binary_search(id, val) → series int"]
                        },
                        "array.binary_search_leftmost": {
                            kind: "Built-in function",
                            desc: [a("The function returns the index of the value if it is found. When the value is not found, the function returns the index of the next smallest element to the left of where the value would lie if it was in the array. The array to search must be sorted in ascending order.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }, {
                                name: "val",
                                info: a("The value to search for in the array.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            remarks: [a("A binary search works on arrays pre-sorted in ascending order. It begins by comparing an element in the middle of the array with the target value. If the element matches the target value, its position in the array is returned. If the element's value is greater than the target value, the search continues in the lower half of the array. If the element's value is less than the target value, the search continues in the upper half of the array. By doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("array.binary_search_leftmost")', "a = array.from(5, -2, 0, 9, 1)", "array.sort(a) // [-2, 0, 1, 5, 9]", "position = array.binary_search_leftmost(a, 3) // 2", "plot(position)"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.insert}, {@fun array.slice}, {@fun array.reverse}, {@var order.ascending}, {@var order.descending}"],
                            syntax: ["array.binary_search_leftmost(id, val) → series int"]
                        },
                        "array.binary_search_rightmost": {
                            kind: "Built-in function",
                            desc: [a("The function returns the index of the value if it is found. When the value is not found, the function returns the index of the element to the right of where the value would lie if it was in the array. The array must be sorted in ascending order.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }, {
                                name: "val",
                                info: a("The value to search for in the array.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            remarks: [a("A binary search works on sorted arrays in ascending order. It begins by comparing an element in the middle of the array with the target value. If the element matches the target value, its position in the array is returned. If the element's value is greater than the target value, the search continues in the lower half of the array. If the element's value is less than the target value, the search continues in the upper half of the array. By doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("array.binary_search_rightmost")', "a = array.from(5, -2, 0, 9, 1)", "array.sort(a) // [-2, 0, 1, 5, 9]", "position = array.binary_search_rightmost(a, 3) // 3", "plot(position)"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.insert}, {@fun array.slice}, {@fun array.reverse}, {@var order.ascending}, {@var order.descending}"],
                            syntax: ["array.binary_search_rightmost(id, val) → series int"]
                        },
                        "array.concat": {
                            kind: "Built-in function",
                            desc: [a("The function is used to merge two arrays. It pushes all elements from the second array to the first array, and returns the first array.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The first array with merged elements from the second array.", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["array.concat(id1, id2) → id1"],
                            args: [{
                                name: "id1",
                                info: a("The first array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }, {
                                name: "id2",
                                info: a("The second array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }],
                            examples: ["//@version=5", 'indicator("array.concat example")', "a = array.new_float(0,0)", "b = array.new_float(0,0)", "for i = 0 to 4", "    array.push(a, high[i])", "    array.push(b, low[i])", "c = array.concat(a,b)", "plot(array.size(a))", "plot(array.size(b))", "plot(array.size(c))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.insert}, {@fun array.slice},"]
                        },
                        "array.avg": {
                            kind: "Built-in function",
                            desc: [a("The function returns the mean of an array's elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Mean of array's elements.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }],
                            examples: ["//@version=5", 'indicator("array.avg example")', "a = array.new_float(0)", "for i = 0 to 9", "\tarray.push(a, close[i])", "plot(array.avg(a))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.max}, {@fun array.min}, {@fun array.stdev}"],
                            syntax: ["array.avg(id) → series float", "array.avg(id) → series int"]
                        },
                        "array.stdev": {
                            kind: "Built-in function",
                            desc: [a("The function returns the standard deviation of an array's elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The standard deviation of the array's elements.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }, {
                                name: "biased",
                                info: a("Determines which estimate should be used. Optional. The default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }],
                            remarks: [a("If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("array.stdev example")', "a = array.new_float(0)", "for i = 0 to 9", "\tarray.push(a, close[i])", "plot(array.stdev(a))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.max}, {@fun array.min}, {@fun array.avg}"],
                            syntax: ["array.stdev(id, biased) → series float", "array.stdev(id, biased) → series int"]
                        },
                        "array.variance": {
                            kind: "Built-in function",
                            desc: [a("The function returns the variance of an array's elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The variance of the array's elements.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }, {
                                name: "biased",
                                info: a("Determines which estimate should be used. Optional. The default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }],
                            remarks: [a("If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("array.variance example")', "a = array.new_float(0)", "for i = 0 to 9", "\tarray.push(a, close[i])", "plot(array.variance(a))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.stdev}, {@fun array.min}, {@fun array.avg}, {@fun array.covariance}"],
                            syntax: ["array.variance(id, biased) → series float", "array.variance(id, biased) → series int"]
                        },
                        "array.covariance": {
                            kind: "Built-in function",
                            desc: [a("The function returns the covariance of two arrays.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The covariance of two arrays.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id1",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }, {
                                name: "id2",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }, {
                                name: "biased",
                                info: a("Determines which estimate should be used. Optional. The default is true.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series bool"
                            }],
                            remarks: [a("If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("array.covariance example")', "a = array.new_float(0)", "b = array.new_float(0)", "for i = 0 to 9", "\tarray.push(a, close[i])", "\tarray.push(a, open[i])", "plot(array.covariance(a, b))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.max}, {@fun array.stdev}, {@fun array.avg}, {@fun array.variance}"],
                            syntax: ["array.covariance(id1, id2, biased) → series float"]
                        },
                        "array.mode": {
                            kind: "Built-in function",
                            desc: [a("The function returns the mode of an array's elements. If there are several values with the same frequency, it returns the smallest value.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The mode of the array's elements.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }],
                            examples: ["//@version=5", 'indicator("array.mode example")', "a = array.new_float(0)", "for i = 0 to 9", "\tarray.push(a, close[i])", "plot(array.mode(a))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.mode}, {@fun array.avg}, {@fun array.variance}, {@fun array.min}"],
                            syntax: ["array.mode(id) → series float", "array.mode(id) → series int"]
                        },
                        "array.median": {
                            kind: "Built-in function",
                            desc: [a("The function returns the median of an array's elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The median of the array's elements.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }],
                            examples: ["//@version=5", 'indicator("array.median example")', "a = array.new_float(0)", "for i = 0 to 9", "\tarray.push(a, close[i])", "plot(array.median(a))"],
                            seeAlso: ["{@fun array.median}, {@fun array.avg}, {@fun array.variance}, {@fun array.min}"],
                            syntax: ["array.median(id) → series float", "array.median(id) → series int"]
                        },
                        "array.standardize": {
                            kind: "Built-in function",
                            desc: [a("The function returns the array of standardized elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The array of standardized elements.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "int[]/float[]"
                            }],
                            examples: ["//@version=5", 'indicator("array.standardize example")', "a = array.new_float(0)", "for i = 0 to 9", "\tarray.push(a, close[i])", "b = array.standardize(a)", "plot(array.min(b))", "plot(array.max(b))"],
                            seeAlso: ["{@fun array.max}, {@fun array.min}, {@fun array.mode}, {@fun array.avg}, {@fun array.variance}, {@fun array.stdev}"],
                            syntax: ["array.standardize(id) → float[]", "array.standardize(id) → int[]"]
                        },
                        "array.indexof": {
                            kind: "Built-in function",
                            desc: [a("The function returns the index of the first occurrence of the value, or -1 if the value is not found.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The index of an element.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }, {
                                name: "value",
                                info: a("The value to search in the array.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series <type of the array's elements>"
                            }],
                            examples: ["//@version=5", 'indicator("array.indexof example")', "a = array.new_float(5,high)", "index = array.indexof(a, high)", "plot(index)"],
                            seeAlso: ["{@fun array.lastindexof}, {@fun array.get}, {@fun array.lastindexof}, {@fun array.remove}, {@fun array.insert}"],
                            syntax: ["array.indexof(id, value) → series int"]
                        },
                        "array.lastindexof": {
                            kind: "Built-in function",
                            desc: [a("The function returns the index of the last occurrence of the value, or -1 if the value is not found.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The index of an element.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }, {
                                name: "value",
                                info: a("The value to search in the array.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series <type of the array's elements>"
                            }],
                            examples: ["//@version=5", 'indicator("array.lastindexof example")', "a = array.new_float(5,high)", "index = array.lastindexof(a, high)", "plot(index)"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.set}, {@fun array.push}, {@fun array.remove}, {@fun array.insert}"],
                            syntax: ["array.lastindexof(id, value) → series int"]
                        },
                        "array.includes": {
                            kind: "Built-in function",
                            desc: [a("The function returns true if the value was found in an array, false otherwise.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("True if the value was found in the array, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }, {
                                name: "value",
                                info: a("The value to search in the array.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series <type of the array's elements>"
                            }],
                            examples: ["//@version=5", 'indicator("array.includes example")', "a = array.new_float(5,high)", "p = close", "if array.includes(a, high)", "\tp := open", "plot(p)"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.indexof}, {@fun array.shift}, {@fun array.remove}, {@fun array.insert}"],
                            syntax: ["array.includes(id, value) → series bool"]
                        },
                        "array.shift": {
                            kind: "Built-in function",
                            desc: [a("The function removes an array's first element and returns its value.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The value of the removed element.", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["array.shift(id) → series &lt;type of the array's elements&gt;"],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }],
                            examples: ["//@version=5", 'indicator("array.shift example")', "a = array.new_float(5,high)", "removedEl = array.shift(a)", "plot(array.size(a))", "plot(removedEl)"],
                            seeAlso: ["{@fun array.unshift}, {@fun array.set}, {@fun array.push}, {@fun array.remove}, {@fun array.includes}"]
                        },
                        "array.unshift": {
                            kind: "Built-in function",
                            desc: [a("The function inserts the value at the beginning of the array.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }, {
                                name: "value",
                                info: a("The value to add to the start of the array.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series <type of the array's elements>"
                            }],
                            examples: ["//@version=5", 'indicator("array.unshift example")', "a = array.new_float(5, 0)", "array.unshift(a, open)", "plot(array.get(a, 0))"],
                            seeAlso: ["{@fun array.shift}, {@fun array.set}, {@fun array.insert}, {@fun array.remove}, {@fun array.indexof}"],
                            syntax: ["array.unshift(id, value) → void"]
                        },
                        "array.reverse": {
                            kind: "Built-in function",
                            desc: [a("The function reverses an array. The first array element becomes the last, and the last array element becomes the first.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("An array object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }],
                            examples: ["//@version=5", 'indicator("array.reverse example")', "a = array.new_float(0)", "for i = 0 to 9", "\tarray.push(a, close[i])", "plot(array.get(a, 0))", "array.reverse(a)", "plot(array.get(a, 0))"],
                            seeAlso: ["{@fun array.new_float}, {@fun array.sort}, {@fun array.push}, {@fun array.set}, {@fun array.avg}"],
                            syntax: ["array.reverse(id) → void"]
                        },
                        alert: {
                            kind: "Built-in function",
                            desc: [a('Creates an alert event when called during the real-time bar, which will trigger a script alert based on "alert function events" if one was previously created for the indicator or strategy through the "Create Alert" dialog box.', {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "message",
                                info: a("Message sent when the alert triggers. Required argument.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "freq",
                                info: a("The triggering frequency. Possible values are: {@var alert.freq_all} (all function calls trigger the alert), {@var alert.freq_once_per_bar} (the first function call during the bar triggers the alert), {@var alert.freq_once_per_bar_close} (the function call triggers the alert only when it occurs during the last script iteration of the real-time bar, when it closes). The default is {@var alert.freq_once_per_bar}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input string"
                            }],
                            examples: ["//@version=5", 'indicator("`alert()` example", "", true)', "ma = ta.sma(close, 14)", "xUp = ta.crossover(close, ma)", "if xUp", "    // Trigger the alert the first time a cross occurs during the real-time bar.", '    alert("Price (" + str.tostring(close) + ") crossed over MA (" + str.tostring(ma) +  ").", alert.freq_once_per_bar)', "plot(ma)", 'plotchar(xUp, "xUp", "▲", location.top, size = size.tiny)'],
                            remarks: [a("The {html_markup_1}Help Center{html_markup_2} explains how to create such alerts.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/chart/?solution=43000597494">',
                                html_markup_2: "</a>"
                            }), a("Contrary to {@fun alertcondition}, {@fun alert} calls do NOT count as an additional plot.", {
                                context: "pine_docs_remarks"
                            }), a("Function calls can be located in both global and local scopes.", {
                                context: "pine_docs_remarks"
                            }), a("Function calls do not display anything on the chart.", {
                                context: "pine_docs_remarks"
                            }), a("The 'freq' argument only affects the triggering frequency of the function call where it is used.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun alertcondition}"],
                            syntax: ["alert(message, freq) → void"]
                        },
                        "request.earnings": {
                            kind: "Built-in function",
                            desc: [a("Requests earnings data for the specified symbol.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "ticker",
                                info: a('Symbol. Note that the symbol should be passed with a prefix. For example: "NASDAQ:AAPL" instead of "AAPL". Using {@var syminfo.ticker} will cause an error. Use {@var syminfo.tickerid} instead.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "field",
                                info: a("Input string. Possible values include: {@var earnings.actual}, {@var earnings.estimate}, {@var earnings.standardized}. Default value is {@var earnings.actual}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "gaps",
                                info: a("Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). Possible values: {@var barmerge.gaps_on}, {@var barmerge.gaps_off}. {@var barmerge.gaps_on} - requested data is merged with possible gaps ({@var na} values). {@var barmerge.gaps_off} - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values. Default value is {@var barmerge.gaps_off}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "barmerge_gaps"
                            }, {
                                name: "lookahead",
                                info: a("Merge strategy for the requested data position. Possible values: {@var barmerge.lookahead_on}, {@var barmerge.lookahead_off}. Default value is {@var barmerge.lookahead_off} starting from version 3. Note that behavour is the same on real-time, and differs only on history.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "barmerge_lookahead"
                            }, {
                                name: "ignore_invalid_symbol",
                                info: a("An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue. The default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input bool"
                            }, {
                                name: "currency",
                                info: a("Currency into which the symbol's currency-related earnings values (e.g. {@var earnings.actual}) are to be converted. The conversion rates used are based on the FX_IDC pairs' daily rates of the previous day (relative to the bar where the calculation is done). Optional. The default is {@var syminfo.currency}. Possible values: a three-letter string with the {html_markup_1}currency code in the ISO 4217 format{html_markup_2} (e.g. \"USD\") or one of the constants in the currency.* namespace, e.g. {@var currency.USD}.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/ISO_4217#Active_codes" rel="nofollow">',
                                    html_markup_2: "</a>"
                                }),
                                type: "simple string"
                            }],
                            returns: [a("Requested series, or n/a if there is no earnings data for the specified symbol.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("request.earnings")', 's1 = request.earnings("NASDAQ:BELFA")', "plot(s1)", 's2 = request.earnings("NASDAQ:BELFA", earnings.actual, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)', "plot(s2)"],
                            seeAlso: ["{@fun request.dividends}, {@fun request.splits}, {@fun request.security}, {@var syminfo.tickerid}"],
                            syntax: ["request.earnings(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float"]
                        },
                        "request.dividends": {
                            kind: "Built-in function",
                            desc: [a("Requests dividends data for the specified symbol.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "ticker",
                                info: a('Symbol. Note that the symbol should be passed with a prefix. For example: "NASDAQ:AAPL" instead of "AAPL". Using {@var syminfo.ticker} will cause an error. Use {@var syminfo.tickerid} instead.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "field",
                                info: a("Input string. Possible values include: {@var dividends.net}, {@var dividends.gross}. Default value is {@var dividends.gross}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "gaps",
                                info: a("Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). Possible values: {@var barmerge.gaps_on}, {@var barmerge.gaps_off}. {@var barmerge.gaps_on} - requested data is merged with possible gaps ({@var na} values). {@var barmerge.gaps_off} - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values. Default value is {@var barmerge.gaps_off}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "barmerge_gaps"
                            }, {
                                name: "lookahead",
                                info: a("Merge strategy for the requested data position. Possible values: {@var barmerge.lookahead_on}, {@var barmerge.lookahead_off}. Default value is {@var barmerge.lookahead_off} starting from version 3. Note that behavour is the same on real-time, and differs only on history.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "barmerge_lookahead"
                            }, {
                                name: "ignore_invalid_symbol",
                                info: a("An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue. The default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input bool"
                            }, {
                                name: "currency",
                                info: a("Currency into which the symbol's currency-related dividends values (e.g. {@var dividends.gross}) are to be converted. The conversion rates used are based on the FX_IDC pairs' daily rates of the previous day (relative to the bar where the calculation is done). Optional. The default is {@var syminfo.currency}. Possible values: a three-letter string with the {html_markup_1}currency code in the ISO 4217 format{html_markup_2} (e.g. \"USD\") or one of the constants in the currency.* namespace, e.g. {@var currency.USD}.", {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/ISO_4217#Active_codes" rel="nofollow">',
                                    html_markup_2: "</a>"
                                }),
                                type: "simple string"
                            }],
                            returns: [a("Requested series, or n/a if there is no dividends data for the specified symbol.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("request.dividends")', 's1 = request.dividends("NASDAQ:BELFA")', "plot(s1)", 's2 = request.dividends("NASDAQ:BELFA", dividends.net, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)', "plot(s2)"],
                            seeAlso: ["{@fun request.earnings}, {@fun request.splits}, {@fun request.security}, {@var syminfo.tickerid}"],
                            syntax: ["request.dividends(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float"]
                        },
                        "request.splits": {
                            kind: "Built-in function",
                            desc: [a("Requests splits data for the specified symbol.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "ticker",
                                info: a('Symbol. Note that the symbol should be passed with a prefix. For example: "NASDAQ:AAPL" instead of "AAPL". Using {@var syminfo.ticker} will cause an error. Use {@var syminfo.tickerid} instead.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "field",
                                info: a("Input string. Possible values include: {@var splits.denominator}, {@var splits.numerator}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "simple string"
                            }, {
                                name: "gaps",
                                info: a("Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). Possible values: {@var barmerge.gaps_on}, {@var barmerge.gaps_off}. {@var barmerge.gaps_on} - requested data is merged with possible gaps ({@var na} values). {@var barmerge.gaps_off} - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values. Default value is {@var barmerge.gaps_off}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "barmerge_gaps"
                            }, {
                                name: "lookahead",
                                info: a("Merge strategy for the requested data position. Possible values: {@var barmerge.lookahead_on}, {@var barmerge.lookahead_off}. Default value is {@var barmerge.lookahead_off} starting from version 3. Note that behavour is the same on real-time, and differs only on history.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "barmerge_lookahead"
                            }, {
                                name: "ignore_invalid_symbol",
                                info: a("An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue. The default value is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input bool"
                            }],
                            returns: [a("Requested series, or n/a if there is no splits data for the specified symbol.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'indicator("request.splits")', 's1 = request.splits("NASDAQ:BELFA", splits.denominator)', "plot(s1)", 's2 = request.splits("NASDAQ:BELFA", splits.denominator, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)', "plot(s2)"],
                            seeAlso: ["{@fun request.earnings}, {@fun request.dividends}, {@fun request.security}, {@var syminfo.tickerid}"],
                            syntax: ["request.splits(ticker, field, gaps, lookahead, ignore_invalid_symbol) → series float"]
                        },
                        "request.economic": {
                            kind: "Built-in function",
                            desc: [a("Requests economic data for a symbol. Economic data includes information such as the state of a country's economy (GDP, inflation rate, etc.) or of a particular industry (steel production, ICU beds, etc.).", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "country_code",
                                info: a('The code of the country (e.g. "US") or the region (e.g. "EU") for which the economic data is requested. The {html_markup_1}Help Center article{html_markup_2} lists the countries and their codes. The countries for which information is available vary with metrics. The {html_markup_3}Help Center article for each metric{html_markup_4} lists the countries for which the metric is available.', {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://www.tradingview.com/chart/?solution=43000665359">',
                                    html_markup_2: "</a>",
                                    html_markup_3: '<a target="blank" href="https://www.tradingview.com/support/folders/43000581956-list-of-available-economic-indicators/">',
                                    html_markup_4: "</a>"
                                }),
                                type: "simple string"
                            }, {
                                name: "field",
                                info: a('The code of the requested economic metric (e.g., "GDP"). The {html_markup_1}Help Center article{html_markup_2} lists the metrics and their codes.', {
                                    context: "pine_docs_args_info"
                                }).format({
                                    html_markup_1: '<a target="blank" href="https://www.tradingview.com/chart/?solution=43000665359">',
                                    html_markup_2: "</a>"
                                }),
                                type: "simple string"
                            }, {
                                name: "gaps",
                                info: a('Specifies how the returned values are merged on chart bars. Possible values: {@var barmerge.gaps_off}, {@var barmerge.gaps_on}. With {@var barmerge.gaps_on}, a value only appears on the current chart bar when it first becomes available from the function\'s context, otherwise {@var na} is returned (thus a "gap" occurs). With {@var barmerge.gaps_off}, what would otherwise be gaps are filled with the latest known value returned, avoiding {@var na} values. Optional. The default is {@var barmerge.gaps_off}.', {
                                    context: "pine_docs_args_info"
                                }),
                                type: "barmerge_gaps"
                            }, {
                                name: "ignore_invalid_symbol",
                                info: a("Determines the behavior of the function if the specified symbol is not found: if {@op false}, the script will halt and return a runtime error; if {@op true}, the function will return {@var na} and execution will continue. Optional. The default is {@op false}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "input bool"
                            }],
                            returns: [a("Requested series.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ['indicator("US GDP")', 'e = request.economic("US", "GDP")', "plot(e)"],
                            remarks: [a('Economic data can also be accessed from charts, just like a regular symbol. Use "ECONOMIC" as the exchange name and `{country_code}{field}` as the ticker. The name of US GDP data is thus "ECONOMIC:USGDP".', {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun request.financial}, {@fun request.quandl}"],
                            syntax: ["request.economic(country_code, field, gaps, ignore_invalid_symbol) → series float"]
                        },
                        "table.new": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new table.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "position",
                                info: a("Position of the table. Possible values are: {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center}, {@var position.bottom_right}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "columns",
                                info: a("The number of columns in the table.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "rows",
                                info: a("The number of rows in the table.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "bgcolor",
                                info: a("The background color of the table. Optional. The default is no color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "frame_color",
                                info: a("The color of the outer frame of the table. Optional. The default is no color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "frame_width",
                                info: a("The width of the outer frame of the table. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "border_color",
                                info: a("The color of the borders of the cells (excluding the outer frame). Optional. The default is no color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "border_width",
                                info: a("The width of the borders of the cells (excluding the outer frame). Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            returns: [a("The ID of a table object that can be passed to other table.*() functions.", {
                                context: "pine_docs_returns"
                            })],
                            remarks: [a("This function creates the table object itself, but the table will not be displayed until its cells are populated. To define a cell and change its contents or attributes, use {@fun table.cell} and other table.cell_*() functions.", {
                                context: "pine_docs_remarks"
                            }), a("One {@fun table.new} call can only display one table (the last one drawn), but the function itself will be recalculated on each bar it is used on. For performance reasons, it is wise to use {@fun table.new} in conjunction with either the {@op var} keyword (so the table object is only created on the first bar) or in an {@op if} {@var barstate.islast} block (so the table object is only created on the last bar).", {
                                context: "pine_docs_remarks"
                            })],
                            examples: ["//@version=5", 'indicator("table.new example")', "var testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)", "if barstate.islast", '    table.cell(table_id = testTable, column = 0, row = 0, text = "Open is " + str.tostring(open))', '    table.cell(table_id = testTable, column = 1, row = 0, text = "Close is " + str.tostring(close), bgcolor=color.teal)'],
                            seeAlso: ["{@fun table.cell}, {@fun table.clear}, {@fun table.delete}, {@fun table.set_bgcolor}, {@fun table.set_border_color}, {@fun table.set_border_width}, {@fun table.set_frame_color}, {@fun table.set_frame_width}, {@fun table.set_position}"],
                            syntax: ["table.new(position, columns, rows, bgcolor, frame_color, frame_width, border_color, border_width) → series table"]
                        },
                        "table.delete": {
                            kind: "Built-in function",
                            desc: [a("The function deletes a table.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }],
                            examples: ["//@version=5", 'indicator("table.delete example")', "var testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)", "if barstate.islast", '    table.cell(table_id = testTable, column = 0, row = 0, text = "Open is " + str.tostring(open))', '    table.cell(table_id = testTable, column = 1, row = 0, text = "Close is " + str.tostring(close), bgcolor=color.teal)', "if barstate.isrealtime", "    table.delete(testTable)"],
                            seeAlso: ["{@fun table.new}, {@fun table.clear}"],
                            syntax: ["table.delete(table_id) → void"]
                        },
                        "table.set_position": {
                            kind: "Built-in function",
                            desc: [a("The function sets the position of a table.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "position",
                                info: a("Position of the table. Possible values are: {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center}, {@var position.bottom_right}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun table.clear}, {@fun table.delete}, {@fun table.new}, {@fun table.set_bgcolor}, {@fun table.set_border_color}, {@fun table.set_border_width}, {@fun table.set_frame_color}, {@fun table.set_frame_width}"],
                            syntax: ["table.set_position(table_id, position) → void"]
                        },
                        "table.set_bgcolor": {
                            kind: "Built-in function",
                            desc: [a("The function sets the background color of a table.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "bgcolor",
                                info: a("The background color of the table. Optional. The default is no color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            seeAlso: ["{@fun table.clear}, {@fun table.delete}, {@fun table.new}, {@fun table.set_border_color}, {@fun table.set_border_width}, {@fun table.set_frame_color}, {@fun table.set_frame_width}, {@fun table.set_position}"],
                            syntax: ["table.set_bgcolor(table_id, bgcolor) → void"]
                        },
                        "table.set_frame_color": {
                            kind: "Built-in function",
                            desc: [a("The function sets the color of the outer frame of a table.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "frame_color",
                                info: a("The color of the frame of the table. Optional. The default is no color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            seeAlso: ["{@fun table.clear}, {@fun table.delete}, {@fun table.new}, {@fun table.set_border_color}, {@fun table.set_border_width}, {@fun table.set_bgcolor}, {@fun table.set_frame_width}, {@fun table.set_position}"],
                            syntax: ["table.set_frame_color(table_id, frame_color) → void"]
                        },
                        "table.set_border_color": {
                            kind: "Built-in function",
                            desc: [a("The function sets the color of the borders (excluding the outer frame) of the table's cells.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "border_color",
                                info: a("The color of the borders. Optional. The default is no color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            seeAlso: ["{@fun table.clear}, {@fun table.delete}, {@fun table.new}, {@fun table.set_frame_color}, {@fun table.set_border_width}, {@fun table.set_bgcolor}, {@fun table.set_frame_width}, {@fun table.set_position}"],
                            syntax: ["table.set_border_color(table_id, border_color) → void"]
                        },
                        "table.set_frame_width": {
                            kind: "Built-in function",
                            desc: [a("The function set the width of the outer frame of a table.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "frame_width",
                                info: a("The width of the outer frame of the table. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun table.clear}, {@fun table.delete}, {@fun table.new}, {@fun table.set_frame_color}, {@fun table.set_border_width}, {@fun table.set_bgcolor}, {@fun table.set_border_color}, {@fun table.set_position}"],
                            syntax: ["table.set_frame_width(table_id, frame_width) → void"]
                        },
                        "table.set_border_width": {
                            kind: "Built-in function",
                            desc: [a("The function sets the width of the borders (excluding the outer frame) of the table's cells.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "border_width",
                                info: a("The width of the borders. Optional. The default is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            seeAlso: ["{@fun table.clear}, {@fun table.delete}, {@fun table.new}, {@fun table.set_frame_color}, {@fun table.set_frame_width}, {@fun table.set_bgcolor}, {@fun table.set_border_color}, {@fun table.set_position}"],
                            syntax: ["table.set_border_width(table_id, border_width) → void"]
                        },
                        "table.cell": {
                            kind: "Built-in function",
                            desc: [a("The function defines a cell in the table and sets its attributes.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "column",
                                info: a("The index of the cell's column. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "row",
                                info: a("The index of the cell's row. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "text",
                                info: a("The text to be displayed inside the cell. Optional. The default is empty string.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "width",
                                info: a("The width of the cell as a % of the indicator's visual space. Optional. By default, auto-adjusts the width based on the text inside the cell. Value 0 has the same effect.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "height",
                                info: a("The height of the cell as a % of the indicator's visual space. Optional. By default, auto-adjusts the height based on the text inside of the cell. Value 0 has the same effect.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }, {
                                name: "text_color",
                                info: a("The color of the text. Optional. The default is {@var color.black}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "text_halign",
                                info: a("The horizontal alignment of the cell's text. Optional. The default value is {@var text.align_center}. Possible values: {@var text.align_left}, {@var text.align_center}, {@var text.align_right}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "text_valign",
                                info: a("The vertical alignment of the cell's text. Optional. The default value is {@var text.align_center}. Possible values: {@var text.align_top}, {@var text.align_center}, {@var text.align_bottom}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "text_size",
                                info: a("The size of the text. An optional parameter, the default value is {@var size.normal}. Possible values: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }, {
                                name: "bgcolor",
                                info: a("The background color of the text. Optional. The default is no color.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }, {
                                name: "tooltip",
                                info: a("The tooltip to be displayed inside the cell. Optional.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            remarks: [a("This function does not create the table itself, but defines the table’s cells. To use it, you first need to create a table object with {@fun table.new}.", {
                                context: "pine_docs_remarks"
                            }), a("Each {@fun table.cell} call overwrites all previously defined properties of a cell. If you call {@fun table.cell} twice in a row, e.g., the first time with text='Test Text', and the second time with text_color={@var color.red} but without a new text argument, the default value of the 'text' being an empty string, it will overwrite 'Test Text', and your cell will display an empty string. If you want, instead, to modify any of the cell's properties, use the table.cell_set_*() functions.", {
                                context: "pine_docs_remarks"
                            }), a("A single script can only display one table in each of the possible locations. If {@fun table.cell} is used on several bars to change the same attribute of a cell (e.g. change the background color of the cell to red on the first bar, then to yellow on the second bar), only the last change will be reflected in the table, i.e., the cell’s background will be yellow. Avoid unnecessary setting of cell properties by enclosing function calls in an {@op if} {@var barstate.islast} block whenever possible, to restrict their execution to the last bar of the series.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}, {@fun table.cell_set_tooltip}"],
                            syntax: ["table.cell(table_id, column, row, text, width, height, text_color, text_halign, text_valign, text_size, bgcolor, tooltip) → void"]
                        },
                        "table.cell_set_text": {
                            kind: "Built-in function",
                            desc: [a("The function sets the text in the specified cell.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "column",
                                info: a("The index of the cell's column. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "row",
                                info: a("The index of the cell's row. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "text",
                                info: a("The text to be displayed inside the cell.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            examples: ["//@version=5", 'indicator("TABLE example")', "var tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)", 'table.cell(tLog, row = 0, column = 0, text = "sometext", text_color = color.blue)', 'table.cell_set_text(tLog, row = 0, column = 0, text = "sometext")'],
                            seeAlso: ["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}, {@fun table.cell_set_tooltip}"],
                            syntax: ["table.cell_set_text(table_id, column, row, text) → void"]
                        },
                        "table.cell_set_tooltip": {
                            kind: "Built-in function",
                            desc: [a("The function sets the tooltip in the specified cell.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "column",
                                info: a("The index of the cell's column. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "row",
                                info: a("The index of the cell's row. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "tooltip",
                                info: a("The tooltip to be displayed inside the cell.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            examples: ["//@version=5", 'indicator("TABLE example")', "var tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)", 'table.cell(tLog, row = 0, column = 0, text = "sometext", text_color = color.blue)', 'table.cell_set_tooltip(tLog, row = 0, column = 0, tooltip = "sometext")'],
                            seeAlso: ["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}, {@fun table.cell_set_text}"],
                            syntax: ["table.cell_set_tooltip(table_id, column, row, tooltip) → void"]
                        },
                        "table.cell_set_width": {
                            kind: "Built-in function",
                            desc: [a("The function sets the width of the cell.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "column",
                                info: a("The index of the cell's column. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "row",
                                info: a("The index of the cell's row. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "width",
                                info: a("The width of the cell as a % of the chart window. Passing 0 auto-adjusts the width based on the text inside of the cell.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_tooltip}"],
                            syntax: ["table.cell_set_width(table_id, column, row, width) → void"]
                        },
                        "table.cell_set_height": {
                            kind: "Built-in function",
                            desc: [a("The function sets the height of cell.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "column",
                                info: a("The index of the cell's column. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "row",
                                info: a("The index of the cell's row. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "height",
                                info: a("The height of the cell as a % of the chart window. Passing 0 auto-adjusts the height based on the text inside of the cell.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            seeAlso: ["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}, {@fun table.cell_set_tooltip}"],
                            syntax: ["table.cell_set_height(table_id, column, row, height) → void"]
                        },
                        "table.cell_set_text_color": {
                            kind: "Built-in function",
                            desc: [a("The function sets the color of the text inside the cell.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "column",
                                info: a("The index of the cell's column. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "row",
                                info: a("The index of the cell's row. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "text_color",
                                info: a("The color of the text.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            seeAlso: ["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}, {@fun table.cell_set_tooltip}"],
                            syntax: ["table.cell_set_text_color(table_id, column, row, text_color) → void"]
                        },
                        "table.cell_set_text_halign": {
                            kind: "Built-in function",
                            desc: [a("The function sets the horizontal alignment of the cell's text.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "column",
                                info: a("The index of the cell's column. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "row",
                                info: a("The index of the cell's row. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "text_halign",
                                info: a("The horizontal alignment of a cell's text. Possible values: {@var text.align_left}, {@var text.align_center}, {@var text.align_right}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}, {@fun table.cell_set_tooltip}"],
                            syntax: ["table.cell_set_text_halign(table_id, column, row, text_halign) → void"]
                        },
                        "table.cell_set_text_valign": {
                            kind: "Built-in function",
                            desc: [a("The function sets the vertical alignment of a cell's text.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "column",
                                info: a("The index of the cell's column. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "row",
                                info: a("The index of the cell's row. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "text_valign",
                                info: a("The vertical alignment of the cell's text. Possible values: {@var text.align_top}, {@var text.align_center}, {@var text.align_bottom}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_width}, {@fun table.cell_set_tooltip}"],
                            syntax: ["table.cell_set_text_valign(table_id, column, row, text_valign) → void"]
                        },
                        "table.cell_set_text_size": {
                            kind: "Built-in function",
                            desc: [a("The function sets the size of the cell's text.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "column",
                                info: a("The index of the cell's column. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "row",
                                info: a("The index of the cell's row. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "text_size",
                                info: a("The size of the text. Possible values: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            seeAlso: ["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}, {@fun table.cell_set_tooltip}"],
                            syntax: ["table.cell_set_text_size(table_id, column, row, text_size) → void"]
                        },
                        "table.cell_set_bgcolor": {
                            kind: "Built-in function",
                            desc: [a("The function sets the background color of the cell.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "column",
                                info: a("The index of the cell's column. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "row",
                                info: a("The index of the cell's row. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "bgcolor",
                                info: a("The background color of the cell.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series color"
                            }],
                            seeAlso: ["{@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}, {@fun table.cell_set_tooltip}"],
                            syntax: ["table.cell_set_bgcolor(table_id, column, row, bgcolor) → void"]
                        },
                        "table.clear": {
                            kind: "Built-in function",
                            desc: [a("The function removes a cell or a sequence of cells from the table. The cells are removed in a rectangle shape where the start_column and start_row specify the top-left corner, and end_column and end_row specify the bottom-right corner.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "start_column",
                                info: a("The index of the column of the first cell to delete. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "start_row",
                                info: a("The index of the row of the first cell to delete. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "end_column",
                                info: a("The index of the column of the last cell to delete. Optional. The default is the argument used for start_column. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "end_row",
                                info: a("The index of the row of the last cell to delete. Optional. The default is the argument used for start_row. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("A donut", overlay=true)', "if barstate.islast", "    colNum = 8, rowNum = 8", '    padding = "◯"', "    donutTable = table.new(position.middle_right, colNum, rowNum)", "    for c = 0 to colNum - 1", "        for r = 0 to rowNum - 1", "            table.cell(donutTable, c, r, text=padding, bgcolor=#face6e, text_color=color.new(color.black, 100))", "    table.clear(donutTable, 2, 2, 5, 5)"],
                            seeAlso: ["{@fun table.delete}, {@fun table.new}"],
                            syntax: ["table.clear(table_id, start_column, start_row, end_column, end_row) → void"]
                        },
                        "matrix.new<type>": {
                            kind: "Built-in function",
                            desc: [a('The function creates a new matrix object. A matrix is a two-dimensional data structure containing rows and columns. All elements in the matrix must be of the type specified in the type template ("&lt;type&gt;").', {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The ID of the new matrix object.", {
                                context: "pine_docs_returns"
                            })],
                            syntax: ["matrix.new&lt;int&gt;(rows, columns, initial_value) → matrix&lt;int&gt;", "matrix.new&lt;float&gt;(rows, columns, initial_value) → matrix&lt;float&gt;", "matrix.new&lt;bool&gt;(rows, columns, initial_value) → matrix&lt;bool&gt;", "matrix.new&lt;string&gt;(rows, columns, initial_value) → matrix&lt;string&gt;", "matrix.new&lt;color&gt;(rows, columns, initial_value) → matrix&lt;color&gt;", "matrix.new&lt;line&gt;(rows, columns, initial_value) → matrix&lt;line&gt;", "matrix.new&lt;label&gt;(rows, columns, initial_value) → matrix&lt;label&gt;", "matrix.new&lt;box&gt;(rows, columns, initial_value) → matrix&lt;box&gt;", "matrix.new&lt;table&gt;(rows, columns, initial_value) → matrix&lt;table&gt;", "matrix.new&lt;linefill&gt;(rows, columns, initial_value) → matrix&lt;linefill&gt;"],
                            args: [{
                                name: "rows",
                                info: a("Initial row count of the matrix. Optional. The default value is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "columns",
                                info: a("Initial column count of the matrix. Optional. The default value is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "initial_value",
                                info: a("Initial value of all matrix elements. Optional. The default is 'na'.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "<matrix_type>"
                            }],
                            detailedDesc: [{
                                desc: [a("Create a matrix of elements with the same initial value", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.new&lt;type&gt;()` Example 1")', "", '// Create a 2x3 (2 rows x 3 columns) "int" matrix with values zero.', "var m = matrix.new&lt;int&gt;(2, 3, 0)", "", "// Display using a label.", "if barstate.islastconfirmedhistory", "\tlabel.new(bar_index, high, str.tostring(m))"]
                            }, {
                                desc: [a("Create a matrix from array values", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.new&lt;type&gt;()` Example 2")', "", "// Function to create a matrix whose rows are filled with array values.", "matrixFromArray(int rows, int columns, array&lt;float&gt; data) =>", "\tm = matrix.new&lt;float&gt;(rows, columns)", "\tfor i = 0 to rows <= 0 ? na : rows - 1", "\t\tfor j = 0 to columns <= 0 ? na : columns - 1", "\t\t\tmatrix.set(m, i, j, array.get(data, i * columns + j))", "\tm", "\t", "// Create a 3x3 matrix from an array of values.", "var m1 = matrixFromArray(3, 3, array.from(1, 2, 3, 4, 5, 6, 7, 8, 9))", "// Display using a label.", "if barstate.islastconfirmedhistory", "\tlabel.new(bar_index, high, str.tostring(m1))"]
                            }, {
                                desc: [a("Create a matrix from an `input.text_area()` field", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.new&lt;type&gt;()` Example 3")', "", "// Function to create a matrix from a text string.", "// Values in a row must be separated by a space. Each line is one row.", "matrixFromInputArea(stringOfValues) =>", '\tvar rowsArray = str.split(stringOfValues, "\\n")', "\tvar rows = array.size(rowsArray)", '\tvar cols = array.size(str.split(array.get(rowsArray, 0), " "))', "\tvar matrix = matrix.new&lt;float&gt;(rows, cols, na) ", "\trow = 0", "\tfor rowString in rowsArray", "\t\tcol = 0", '\t\tvalues = str.split(rowString, " ")', "\t\tfor val in values", "\t\t\tmatrix.set(matrix, row, col, str.tonumber(val))", "\t\t\tcol += 1", "\t\trow += 1", "\tmatrix", "", "", 'stringInput = input.text_area("1 2 3\\n4 5 6\\n7 8 9")', "var m = matrixFromInputArea(stringInput)    ", "", "// Display using a label.", "if barstate.islastconfirmedhistory", "\tlabel.new(bar_index, high, str.tostring(m))"]
                            }, {
                                desc: [a("Create matrix from random values", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.new&lt;type&gt;()` Example 4")', "", "// Function to create a matrix with random values (0.0 to 1.0).", "matrixRandom(int rows, int columns)=>", "\tresult = matrix.new&lt;float&gt;(rows, columns)", "\tfor i = 0 to rows - 1", "\t\tfor j = 0 to columns - 1", "\t\t\tmatrix.set(result, i, j, math.random())", "\tresult", "", "// Create a 2x3 matrix with random values.", "var m = matrixRandom(2, 3)", "", "// Display using a label.", "if barstate.islastconfirmedhistory", "\tlabel.new(bar_index, high, str.tostring(m))"]
                            }],
                            seeAlso: ['{@fun matrix.set}, {@fun matrix.fill}, {@fun matrix.columns}, {@fun matrix.rows}, {html_markup_start}<a href="">{@fun array.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}']
                        },
                        "matrix.row": {
                            kind: "Built-in function",
                            desc: [a("The function creates a one-dimensional array from the elements of a matrix row.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("An array ID containing the `row` values of the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "row",
                                info: a("Index of the required row.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.row()` Example", "", true)', "", '// Create a 2x3 "float" matrix from `hlc3` values.', "m = matrix.new&lt;float&gt;(2, 3, hlc3)", "", "// Return an array with the values of the first row of the matrix.", "a = matrix.row(m, 0)", "", "// Plot the first value from the array `a`.", "plot(array.get(a, 0))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun array.get}, {@fun matrix.col}, {@fun matrix.rows}'],
                            remarks: [a("Indexing of rows starts at 0.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.row(id, row) → type[]"]
                        },
                        "matrix.col": {
                            kind: "Built-in function",
                            desc: [a("The function creates a one-dimensional array from the elements of a matrix column.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("An array ID containing the `column` values of the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "column",
                                info: a("Index of the required column.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.col()` Example", "", true)', "", '// Create a 2x3 "float" matrix from `hlc3` values.', "m = matrix.new&lt;float&gt;(2, 3, hlc3)", "", "// Return an array with the values of the first column of matrix `m`.", "a = matrix.col(m, 0)", "", "// Plot the first value from the array `a`.", "plot(array.get(a, 0))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun array.get}, {@fun matrix.col}, {@fun matrix.columns}'],
                            remarks: [a("Indexing of rows starts at 0.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.col(id, column) → type[]"]
                        },
                        "matrix.reshape": {
                            kind: "Built-in function",
                            desc: [a("The function rebuilds the `id` matrix to `rows` x `cols` dimensions.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "rows",
                                info: a("The number of rows of the reshaped matrix.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "columns",
                                info: a("The number of columns of the reshaped matrix.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.reshape()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x3 matrix.", "\tvar m1 = matrix.new&lt;float&gt;(2, 3)", "\t// Fill the matrix with values.", "\tmatrix.set(m1, 0, 0, 1)", "\tmatrix.set(m1, 0, 1, 2)", "\tmatrix.set(m1, 0, 2, 3)", "\tmatrix.set(m1, 1, 0, 4)", "\tmatrix.set(m1, 1, 1, 5)", "\tmatrix.set(m1, 1, 2, 6)", "\t", "\t// Copy the matrix to a new one.", "\tvar m2 = matrix.copy(m1)", "\t", "\t// Reshape the copy to a 3x2.", "\tmatrix.reshape(m2, 3, 2)", "\t", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Original matrix:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Reshaped matrix:")', "\ttable.cell(t, 1, 1, str.tostring(m2))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.add_row}, {@fun matrix.add_col}'],
                            syntax: ["matrix.reshape(id, rows, columns) → void"]
                        },
                        "matrix.get": {
                            kind: "Built-in function",
                            desc: [a("The function returns the element with the specified index of the matrix.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The value of the element at the `column` and `row` index of the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "row",
                                info: a("Index of the required row.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "column",
                                info: a("Index of the required column.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.get()` Example", "", true)', "", '// Create a 2x3 "float" matrix from the `hl2` values.', "m = matrix.new&lt;float&gt;(2, 3, hl2)", "", "// Return the value of the element at index [0, 0] of matrix `m`.", "x = matrix.get(m, 0, 0)", "", "plot(x)"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}'],
                            remarks: [a("Indexing of the rows and columns starts at zero.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.get(id, row, column) → &lt;matrix_type&gt;"]
                        },
                        "matrix.set": {
                            kind: "Built-in function",
                            desc: [a("The function assigns `value` to the element at the `column` and `row` of the `id` matrix.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "row",
                                info: a("The row index of the element to be modified.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "column",
                                info: a("The column index of the element to be modified.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "value",
                                info: a("The new value to be set.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series <type of the matrix's elements>"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.set()` Example")', "", '// Create a 2x3 "int" matrix containing values `4`.', "m = matrix.new&lt;int&gt;(2, 3, 4)", "", "// Replace the value of element at row 1 and column 2 with value `3`.", "matrix.set(m, 0, 1, 3)", "", "// Display using a label.", "if barstate.islastconfirmedhistory", "\tlabel.new(bar_index, high, str.tostring(m))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.columns}, {@fun matrix.rows}'],
                            syntax: ["matrix.set(id, row, column, value) → void"]
                        },
                        "matrix.add_row": {
                            kind: "Built-in function",
                            desc: [a("The function adds a row at the `row` index of the `id` matrix. The row can consist of `na` values, or an array can be used to provide values.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "row",
                                info: a("The index of the row after which the new row will be inserted. Optional. The default value is {@fun matrix.rows}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "array_id",
                                info: a("An array to be inserted. Optional.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }],
                            detailedDesc: [{
                                desc: [a("Adding a row to the matrix", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.add_row()` Example 1")', "", '// Create a 2x3 "int" matrix containing values `0`.', "m = matrix.new&lt;int&gt;(2, 3, 0)", "", "// Add a row with `na` values to the matrix.", "matrix.add_row(m)", "", "// Display matrix elements.", "if barstate.islastconfirmedhistory", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Matrix elements:")', "\ttable.cell(t, 0, 1, str.tostring(m))"]
                            }, {
                                desc: [a("Adding an array as a row to the matrix", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.add_row()` Example 2")', "", "if barstate.islastconfirmedhistory", "\t// Create an empty matrix object. ", "\tvar m = matrix.new&lt;int&gt;()", "\t", "\t// Create an array with values `1` and `2`.", "\tvar a = array.from(1, 2)", "\t", "\t// Add the `a` array as the first row of the empty matrix.", "\tmatrix.add_row(m, 0, a)", "\t", "\t// Display matrix elements.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Matrix elements:")', "\ttable.cell(t, 0, 1, str.tostring(m))"]
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}, {@fun matrix.add_col}'],
                            remarks: [a("Indexing of rows and columns starts at zero. Rather than add rows to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.add_row(id, row) → void", "matrix.add_row(id, row, array_id) → void"]
                        },
                        "matrix.add_col": {
                            kind: "Built-in function",
                            desc: [a("The function adds a column at the `column` index of the `id` matrix. The column can consist of `na` values, or an array can be used to provide values.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "column",
                                info: a("The index of the column after which the new column will be inserted. Optional. The default value is {@fun matrix.columns}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "array_id",
                                info: a("An array to be inserted. Optional.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any array type"
                            }],
                            detailedDesc: [{
                                desc: [a("Adding a column to the matrix", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.add_col()` Example 1")', "", '// Create a 2x3 "int" matrix containing values `0`.', "m = matrix.new&lt;int&gt;(2, 3, 0)", "", "// Add a column  with `na` values to the matrix.", "matrix.add_col(m)", "", "// Display matrix elements.", "if barstate.islastconfirmedhistory", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Matrix elements:")', "\ttable.cell(t, 0, 1, str.tostring(m))"]
                            }, {
                                desc: [a("Adding an array as a column to the matrix", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.add_col()` Example 2")', "", "if barstate.islastconfirmedhistory", "\t// Create an empty matrix object. ", "\tvar m = matrix.new&lt;int&gt;()", "\t", "\t// Create an array with values `1` and `3`.", "\tvar a = array.from(1, 3)", "\t", "\t// Add the `a` array as the first column of the empty matrix.", "\tmatrix.add_col(m, 0, a)", "\t", "\t// Display matrix elements.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Matrix elements:")', "\ttable.cell(t, 0, 1, str.tostring(m))"]
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}, {@fun matrix.add_row}'],
                            remarks: [a("Rather than add columns to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values. Adding a column is also much slower than adding a row with the {@fun matrix.add_row} function.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.add_col(id, column) → void", "matrix.add_col(id, column, array_id) → void"]
                        },
                        "matrix.remove_row": {
                            kind: "Built-in function",
                            desc: [a("The function removes the row at `row` index of the `id` matrix and returns an array containing the removed row's values.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("An array containing the elements of the row removed from the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "row",
                                info: a("The index of the row to be deleted. Optional. The default value is {@fun matrix.rows}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("matrix_remove_row", overlay = true)', "", '// Create a 2x2 "int" matrix containing values `1`.', "var matrixOrig = matrix.new&lt;int&gt;(2, 2, 1)", "", "// Set values to the 'matrixOrig' matrix.", "matrix.set(matrixOrig, 0, 1, 2)", "matrix.set(matrixOrig, 1, 0, 3)", "matrix.set(matrixOrig, 1, 1, 4)", "", "// Create a copy of the 'matrixOrig' matrix.", "matrixCopy = matrix.copy(matrixOrig)", "", "// Remove the first row from the matrix `matrixCopy`.", "arr = matrix.remove_row(matrixCopy, 0)", "", "// Display matrix elements.", "if barstate.islastconfirmedhistory", "\tvar t = table.new(position.top_right, 3, 2, color.green)", '\ttable.cell(t, 0, 0, "Original Matrix:")', "\ttable.cell(t, 0, 1, str.tostring(matrixOrig))", '\ttable.cell(t, 1, 0, "Removed Elements:")', "\ttable.cell(t, 1, 1, str.tostring(arr))", '\ttable.cell(t, 2, 0, "Result Matrix:")', "\ttable.cell(t, 2, 1, str.tostring(matrixCopy))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.copy}, {@fun matrix.remove_col}'],
                            remarks: [a("Indexing of rows and columns starts at zero. It is far more efficient to declare matrices with explicit dimensions than to build them by adding or removing rows.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.remove_row(id, row) → type[]"]
                        },
                        "matrix.remove_col": {
                            kind: "Built-in function",
                            desc: [a("The function removes the column at `column` index of the `id` matrix and returns an array containing the removed column's values.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("An array containing the elements of the column removed from the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "column",
                                info: a("The index of the column to be removed. Optional. The default value is {@fun matrix.columns}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("matrix_remove_col", overlay = true)', "", "// Create a 2x2 matrix with ones.", "var matrixOrig = matrix.new&lt;int&gt;(2, 2, 1)", "", "// Set values to the 'matrixOrig' matrix.", "matrix.set(matrixOrig, 0, 1, 2)", "matrix.set(matrixOrig, 1, 0, 3)", "matrix.set(matrixOrig, 1, 1, 4)", "", "", "// Create a copy of the 'matrixOrig' matrix.", "matrixCopy = matrix.copy(matrixOrig)", "", "// Remove the first column from the `matrixCopy` matrix.", "arr = matrix.remove_col(matrixCopy, 0)", "", "// Display matrix elements.", "if barstate.islastconfirmedhistory", "\tvar t = table.new(position.top_right, 3, 2, color.green)", '\ttable.cell(t, 0, 0, "Original Matrix:")', "\ttable.cell(t, 0, 1, str.tostring(matrixOrig))", '\ttable.cell(t, 1, 0, "Removed Elements:")', "\ttable.cell(t, 1, 1, str.tostring(arr))", '\ttable.cell(t, 2, 0, "Result Matrix:")', "\ttable.cell(t, 2, 1, str.tostring(matrixCopy))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.copy}, {@fun matrix.remove_row}'],
                            remarks: [a("Indexing of rows and columns starts at zero. It is far more efficient to declare matrices with explicit dimensions than to build them by adding or removing columns. Deleting a column is also much slower than deleting a row with the {@fun matrix.remove_row} function.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.remove_col(id, column) → type[]"]
                        },
                        "matrix.fill": {
                            kind: "Built-in function",
                            desc: [a("The function fills a rectangular area of the `id` matrix defined by the indices `from_column` to `to_column` (not including it) and `from_row` to `to_row`(not including it) with the `value`.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "value",
                                info: a("The value to fill with.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series <type of the matrix's elements>"
                            }, {
                                name: "from_column",
                                info: a("Column index from which the fill will begin (inclusive). Optional. The default value is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "to_column",
                                info: a("Column index where the fill will end (non inclusive). Optional. The default value is {@fun matrix.columns}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "from_row",
                                info: a("Row index from which the fill will begin (inclusive). Optional. The default value is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "to_row",
                                info: a("Row index where the fill will end (not inclusive). Optional. The default value is {@fun matrix.rows}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.fill()` Example")', "", '// Create a 4x5 "int" matrix containing values `0`.', "m = matrix.new&lt;float&gt;(4, 5, 0)", "", "// Fill the intersection of rows 1 to 2 and columns 2 to 3 of the matrix with `hl2` values.", "matrix.fill(m, hl2, 0, 2, 1, 3)", "", "// Display using a label.", "if barstate.islastconfirmedhistory", "\tlabel.new(bar_index, high, str.tostring(m))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}'],
                            syntax: ["matrix.fill(id, value, from_row, to_row, from_column, to_column) → void"]
                        },
                        "matrix.submatrix": {
                            kind: "Built-in function",
                            desc: [a("The function extracts a submatrix of the `id` matrix within the specified indices.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("A new matrix object containing the submatrix of the `id` matrix defined by the `from_row`, `to_row`, `from_column` and `to_column` indices.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "from_column",
                                info: a("Index of the column from which the extraction will begin (inclusive). Optional. The default value is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "to_column",
                                info: a("Index of the column where the extraction will end (non inclusive). Optional. The default value is {@fun matrix.columns}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "from_row",
                                info: a("Index of the row from which the extraction will begin (inclusive). Optional. The default value is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "to_row",
                                info: a("Index of the row where the extraction will end (non inclusive). Optional. The default value is {@fun matrix.rows}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.submatrix()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x3 matrix matrix with values `0`.", "\tvar m1 = matrix.new&lt;int&gt;(2, 3, 0)", "\t// Fill the matrix with values.", "\tmatrix.set(m1, 0, 0, 1)", "\tmatrix.set(m1, 0, 1, 2)", "\tmatrix.set(m1, 0, 2, 3)", "\tmatrix.set(m1, 1, 0, 4)", "\tmatrix.set(m1, 1, 1, 5)", "\tmatrix.set(m1, 1, 2, 6)", "\t", "\t// Create a 2x2 submatrix of the `m1` matrix.", "\tvar m2 = matrix.submatrix(m1, 0, 2, 1, 3)", "\t", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Original Matrix:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Submatrix:")', "\ttable.cell(t, 1, 1, str.tostring(m2))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.row}, {@fun matrix.col}, {@fun matrix.reshape}'],
                            remarks: [a("Indexing of the rows and columns starts at zero.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.submatrix(id, from_row, to_row, from_column, to_column) → matrix&lt;type&gt;"]
                        },
                        "matrix.copy": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new matrix which is a copy of the original.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("A new matrix object of the copied `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object to copy.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.copy()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", '\t// Create a 2x3 "float" matrix with `1` values.', "\tvar m1 = matrix.new&lt;float&gt;(2, 3, 1)", "\t", "\t// Copy the matrix to a new one.", "\t// Note that unlike what `matrix.copy()` does, ", "\t// the simple assignment operation `m2 = m1`", "\t// would NOT create a new copy of the `m1` matrix.", "\t// It would merely create a copy of its ID referencing the same matrix.", "\tvar m2 = matrix.copy(m1)", "\t", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 5, 2, color.green)", '\ttable.cell(t, 0, 0, "Original Matrix:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Matrix Copy:")', "\ttable.cell(t, 1, 1, str.tostring(m2))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}'],
                            syntax: ["matrix.copy(id) → matrix&lt;type&gt;"]
                        },
                        "matrix.columns": {
                            kind: "Built-in function",
                            desc: [a("The function returns the number of columns in the matrix.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The number of columns in the matrix `id`.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.columns()` Example")', "", "// Create a 2x6 matrix with values `0`.", "var m = matrix.new&lt;int&gt;(2, 6, 0)", "", "// Get the quantity of columns in matrix `m`.", "var x = matrix.columns(m)", "", "// Display using a label.", "if barstate.islastconfirmedhistory", '\tlabel.new(bar_index, high, "Columns: " + str.tostring(x) + "\\n" + str.tostring(m))'],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.col}, {@fun matrix.row}, {@fun matrix.rows}'],
                            syntax: ["matrix.columns(id) → series int"]
                        },
                        "matrix.rows": {
                            kind: "Built-in function",
                            desc: [a("The function returns the number of rows in the matrix.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The number of rows in the matrix `id`.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.rows()` Example")', "", "// Create a 2x6 matrix with values `0`.", "var m = matrix.new&lt;int&gt;(2, 6, 0)", "", "// Get the quantity of rows in the matrix.", "var x = matrix.rows(m)", "", "// Display using a label.", "if barstate.islastconfirmedhistory", '\tlabel.new(bar_index, high, "Rows: " + str.tostring(x) + "\\n" + str.tostring(m))'],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.row}'],
                            syntax: ["matrix.rows(id) → series int"]
                        },
                        "matrix.elements_count": {
                            kind: "Built-in function",
                            desc: [a("The function returns the total number of all matrix elements.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.columns}, {@fun matrix.rows}'],
                            syntax: ["matrix.elements_count(id) → series int"]
                        },
                        "matrix.concat": {
                            kind: "Built-in function",
                            desc: [a("The function appends the `m2` matrix to the `m1` matrix.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Returns the `id1` matrix concatenated with the `id2` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id1",
                                info: a("Matrix object to concatenate into.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "id2",
                                info: a("Matrix object whose elements will be appended to `id1`.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.concat()` Example")', "", '// Create a 2x4 "int" matrix containing values `0`.', "m1 = matrix.new&lt;int&gt;(2, 4, 0)", '// Create a 2x4 "int" matrix containing values `1`.', "m2 = matrix.new&lt;int&gt;(2, 4, 1)", "", "// Append matrix `m2` to `m1`.", "matrix.concat(m1, m2)", "", "// Display matrix elements.", "if barstate.islastconfirmedhistory", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Matrix Elements:")', "\ttable.cell(t, 0, 1, str.tostring(m1))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}'],
                            remarks: [a("The number of columns in both matrices must be identical.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.concat(id1, id2) → matrix&lt;type&gt;"]
                        },
                        "matrix.swap_rows": {
                            kind: "Built-in function",
                            desc: [a("The function swaps the rows at the index `row1` and `row2` in the `id` matrix.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "row1",
                                info: a("Index of the first row to be swapped.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "row2",
                                info: a("Index of the second row to be swapped.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.swap_rows()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 3x2 matrix with ‘na’ values.", "\tvar m1 = matrix.new&lt;int&gt;(3, 2, na)", "\t// Fill the matrix with values.", "\tmatrix.set(m1, 0, 0, 1)", "\tmatrix.set(m1, 0, 1, 2)", "\tmatrix.set(m1, 1, 0, 3)", "\tmatrix.set(m1, 1, 1, 4)", "\tmatrix.set(m1, 2, 0, 5)", "\tmatrix.set(m1, 2, 1, 6)", "\t", "\t// Copy the matrix to a new one.", "\tvar m2 = matrix.copy(m1)", "\t", "\t// Swap the first and second rows of the matrix copy.", "\tmatrix.swap_rows(m2, 0, 1)", "\t", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Original matrix:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Swapped rows in copy:")', "\ttable.cell(t, 1, 1, str.tostring(m2))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.swap_columns}'],
                            remarks: [a("Indexing of the rows and columns starts at zero.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.swap_rows(id, row1, row2) → void"]
                        },
                        "matrix.swap_columns": {
                            kind: "Built-in function",
                            desc: [a("The function swaps the columns at the index `column1` and `column2` in the `id` matrix.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }, {
                                name: "column1",
                                info: a("Index of the first column to be swapped.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "column2",
                                info: a("Index of the second column to be swapped.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.swap_columns()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x2 matrix with ‘na’ values.", "\tvar m1 = matrix.new&lt;int&gt;(2, 2, na)    ", "\t// Fill the matrix with values.", "\tmatrix.set(m1, 0, 0, 1)", "\tmatrix.set(m1, 0, 1, 2)", "\tmatrix.set(m1, 1, 0, 3)", "\tmatrix.set(m1, 1, 1, 4)", "\t", "\t// Copy the matrix to a new one.", "\tvar m2 = matrix.copy(m1)", "\t", "\t// Swap the first and second columns of the matrix copy.", "\tmatrix.swap_columns(m2, 0, 1)", "", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Original matrix:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Swapped columns in copy:")', "\ttable.cell(t, 1, 1, str.tostring(m2))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}'],
                            remarks: [a("Indexing of the rows and columns starts at zero.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.swap_columns(id, column1, column2) → void"]
                        },
                        "matrix.reverse": {
                            kind: "Built-in function",
                            desc: [a("The function reverses the order of rows and columns in the matrix `id`. The first row and first column become the last, and the last become the first.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.reverse()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Copy the matrix to a new one.", "\tvar m1 = matrix.new&lt;int&gt;(2, 2, na)", "\t// Fill the matrix with values.", "\tmatrix.set(m1, 0, 0, 1)", "\tmatrix.set(m1, 0, 1, 2)", "\tmatrix.set(m1, 1, 0, 3)", "\tmatrix.set(m1, 1, 1, 4)", "\t", "\t// Copy matrix elements to a new matrix.", "\tvar m2 = matrix.copy(m1)", "\t", "\t// Reverse the `m2` copy of the original matrix. ", "\tmatrix.reverse(m2)", "\t", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Original matrix:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Reversed matrix:")', "\ttable.cell(t, 1, 1, str.tostring(m2))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}, {@fun matrix.reshape}'],
                            syntax: ["matrix.reverse(id) → void"]
                        },
                        "matrix.sort": {
                            kind: "Built-in function",
                            desc: [a("The function rearranges the rows in the `id` matrix following the sorted order of the values in the `column`.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object to be sorted.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<int>/matrix<float>/matrix<string>"
                            }, {
                                name: "column",
                                info: a("Index of the column whose sorted values determine the new order of rows. Optional. The default value is 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "order",
                                info: a("The sort order. Possible values: {@var order.ascending} (default), {@var order.descending}.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "sort_order"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.sort()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x2 matrix. ", "\tvar m1 = matrix.new&lt;float&gt;(2, 2, na)", "\t// Fill the matrix with values.", "\tmatrix.set(m1, 0, 0, 3)", "\tmatrix.set(m1, 0, 1, 4)", "\tmatrix.set(m1, 1, 0, 1)", "\tmatrix.set(m1, 1, 1, 2)", "\t", "\t// Copy the matrix to a new one.", "\tvar m2 = matrix.copy(m1)", "\t// Sort the rows of `m2` using the default arguments (first column and ascending order).", "\tmatrix.sort(m2)", "\t", "\t// Display using a table.", "\tif barstate.islastconfirmedhistory", "\t\tvar t = table.new(position.top_right, 2, 2, color.green)", '\t\ttable.cell(t, 0, 0, "Original matrix:")', "\t\ttable.cell(t, 0, 1, str.tostring(m1))", '\t\ttable.cell(t, 1, 0, "Sorted matrix:")', "\t\ttable.cell(t, 1, 1, str.tostring(m2))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.max}, {@fun matrix.min}, {@fun matrix.avg}'],
                            syntax: ["matrix.sort(id, column, order) → void"]
                        },
                        "matrix.det": {
                            kind: "Built-in function",
                            desc: [a("The function returns the {html_markup_1}determinant{html_markup_2} of a square matrix.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Determinant" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("The determinant value of the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.det` Example")', "", "// Create a 2x2 matrix.", "var m = matrix.new&lt;float&gt;(2, 2, na)", "// Fill the matrix with values.", "matrix.set(m, 0, 0,  3)", "matrix.set(m, 0, 1,  7)", "matrix.set(m, 1, 0,  1)", "matrix.set(m, 1, 1, -4)", "", "// Get the determinant of the matrix. ", "var x = matrix.det(m)", "", "plot(x, 'Matrix determinant')"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.is_square}'],
                            remarks: [a("Function calculation based on the {html_markup_1}LU decomposition{html_markup_2} algorithm.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/LU_decomposition" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            syntax: ["matrix.det(id) → series float", "matrix.det(id) → series int"]
                        },
                        "matrix.min": {
                            kind: "Built-in function",
                            desc: [a("The function returns the smallest value from the matrix elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The smallest value from the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.min()` Example")', "", "// Create a 2x2 matrix.", "var m = matrix.new&lt;int&gt;(2, 2, na)", "// Fill the matrix with values.", "matrix.set(m, 0, 0, 1)", "matrix.set(m, 0, 1, 2)", "matrix.set(m, 1, 0, 3)", "matrix.set(m, 1, 1, 4)", "", "// Get the minimum value from the matrix.", "var x = matrix.min(m)", "", "plot(x, 'Matrix minimum value')"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.max}, {@fun matrix.avg}, {@fun matrix.sort}'],
                            syntax: ["matrix.min(id) → series float", "matrix.min(id) → series int"]
                        },
                        "matrix.max": {
                            kind: "Built-in function",
                            desc: [a("The function returns the largest value from the matrix elements.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The maximum value from the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.max()` Example")', "", "// Create a 2x2 matrix.", "var m = matrix.new&lt;int&gt;(2, 2, na)", "// Fill the matrix with values.", "matrix.set(m, 0, 0, 1)", "matrix.set(m, 0, 1, 2)", "matrix.set(m, 1, 0, 3)", "matrix.set(m, 1, 1, 4)", "", "// Get the maximum value in the matrix.", "var x = matrix.max(m)", "", "plot(x, 'Matrix maximum value')"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.min}, {@fun matrix.avg}, {@fun matrix.sort}'],
                            syntax: ["matrix.max(id) → series float", "matrix.max(id) → series int"]
                        },
                        "matrix.avg": {
                            kind: "Built-in function",
                            desc: [a("The function calculates the average of all elements in the matrix.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The average value from the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.avg()` Example")', "", "// Create a 2x2 matrix.", "var m = matrix.new&lt;int&gt;(2, 2, na)", "// Fill the matrix with values.", "matrix.set(m, 0, 0, 1)", "matrix.set(m, 0, 1, 2)", "matrix.set(m, 1, 0, 3)", "matrix.set(m, 1, 1, 4)", "", "// Get the average value of the matrix.", "var x = matrix.avg(m)", "", "plot(x, 'Matrix average value')"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}'],
                            syntax: ["matrix.avg(id) → series float", "matrix.avg(id) → series int"]
                        },
                        "matrix.median": {
                            kind: "Built-in function",
                            desc: [a('The function calculates the {html_markup_1}median{html_markup_2} ("the middle" value) of matrix elements.', {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Median" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.median()` Example")', "", "// Create a 2x2 matrix.", "m = matrix.new&lt;int&gt;(2, 2, na)", "// Fill the matrix with values.", "matrix.set(m, 0, 0, 1)", "matrix.set(m, 0, 1, 2)", "matrix.set(m, 1, 0, 3)", "matrix.set(m, 1, 1, 4)", "", "// Get the median of the matrix.", "x = matrix.median(m)", "", "plot(x, 'Median of the matrix')"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.mode}, {@fun matrix.sort}, {@fun matrix.avg}'],
                            remarks: [a("Note that {@var na} elements of the matrix are not considered when calculating the median.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.median(id) → series float", "matrix.median(id) → series int"]
                        },
                        "matrix.mode": {
                            kind: "Built-in function",
                            desc: [a("The function calculates the {html_markup_1}mode{html_markup_2} of the matrix, which is the most frequently occurring value from the matrix elements. When there are multiple values occurring equally frequently, the function returns the smallest of those values.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Mode_(statistics)" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("The most frequently occurring value from the `id` matrix. Returns ‘na’ if none exists.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.mode()` Example")', "", "// Create a 2x2 matrix.", "var m = matrix.new&lt;int&gt;(2, 2, na)", "// Fill the matrix with values.", "matrix.set(m, 0, 0, 0)", "matrix.set(m, 0, 1, 0)", "matrix.set(m, 1, 0, 1)", "matrix.set(m, 1, 1, 1)", "", "// Get the mode of the matrix.", "var x = matrix.mode(m)", "", "plot(x, 'Mode of the matrix')"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.median}, {@fun matrix.sort}, {@fun matrix.avg}'],
                            remarks: [a("Note that {@var na} elements of the matrix are not considered when calculating the mode.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.mode(id) → series float", "matrix.mode(id) → series int"]
                        },
                        "matrix.transpose": {
                            kind: "Built-in function",
                            desc: [a("The function creates a new, {html_markup_1}transposed{html_markup_2} version of the `id`. This interchanges the row and column index of each element.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Transpose#Transpose_of_a_matrix" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("A new matrix containing the transposed version of the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.transpose()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x2 matrix. ", "\tvar m1 = matrix.new&lt;float&gt;(2, 2, na)", "\t// Fill the matrix with values.", "\tmatrix.set(m1, 0, 0, 1)", "\tmatrix.set(m1, 0, 1, 2)", "\tmatrix.set(m1, 1, 0, 3)", "\tmatrix.set(m1, 1, 1, 4)", "\t", "\t// Create a transpose of the matrix.", "\tvar m2 = matrix.transpose(m1)", "\t", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Original matrix:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Transposed matrix:")', "\ttable.cell(t, 1, 1, str.tostring(m2))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}, {@fun matrix.reshape}, {@fun matrix.reverse}'],
                            syntax: ["matrix.transpose(id) → matrix&lt;type&gt;"]
                        },
                        "matrix.sum": {
                            kind: "Built-in function",
                            desc: [a("The function returns a new matrix resulting from the {html_markup_1}sum{html_markup_2} of two matrices `id1` and `id2`, or of an `id1` matrix and an `id2` scalar (a numerical value).", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Matrix_addition" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("A new matrix object containing the sum of `id2` and `id1`.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id1",
                                info: a("First matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<int>/matrix<float>"
                            }, {
                                name: "id2",
                                info: a("Second matrix object, or scalar value.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float/matrix<int>/matrix<float>"
                            }],
                            detailedDesc: [{
                                desc: [a("Sum of two matrices", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.sum()` Example 1")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x3 matrix containing values `5`.", "\tvar m1 = matrix.new&lt;float&gt;(2, 3, 5) ", "\t// Create a 2x3 matrix containing values `4`.", "\tvar m2 = matrix.new&lt;float&gt;(2, 3, 4) ", "\t// Create a new matrix that sums matrices `m1` and `m2`.", "\tvar m3 = matrix.sum(m1, m2) ", "\t", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 1, 2, color.green)", '\ttable.cell(t, 0, 0, "Sum of two matrices:")', "\ttable.cell(t, 0, 1, str.tostring(m3))"]
                            }, {
                                desc: [a("Sum of a matrix and scalar", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.sum()` Example 2")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x3 matrix with values `4`.", "\tvar m1 = matrix.new&lt;float&gt;(2, 3, 4)", "\t", '\t// Create a new matrix containing the sum of the `m1` matrix with the "int" value `1`.', "\tvar m2 = matrix.sum(m1, 1)", "\t", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 1, 2, color.green)", '\ttable.cell(t, 0, 0, "Sum of a matrix and a scalar:")', "\ttable.cell(t, 0, 1, str.tostring(m2))"]
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}'],
                            syntax: ["matrix.sum(id1, id2) → matrix&lt;int&gt;", "matrix.sum(id1, id2) → matrix&lt;float&gt;", "matrix.sum(id1, id2) → matrix&lt;int&gt;", "matrix.sum(id1, id2) → matrix&lt;float&gt;"]
                        },
                        "matrix.diff": {
                            kind: "Built-in function",
                            desc: [a("The function returns a new matrix resulting from the subtraction between matrices `id1` and `id2`, or of matrix `id1` and an `id2` scalar (a numerical value).", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("A new matrix object containing the difference between `id2` and `id1`.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id1",
                                info: a("Matrix to subtract from.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<int>/matrix<float>"
                            }, {
                                name: "id2",
                                info: a("Matrix object or a scalar value to be subtracted.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float/matrix<int>/matrix<float>"
                            }],
                            detailedDesc: [{
                                desc: [a("Difference between two matrices", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.diff()` Example 1")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x3 matrix containing values `5`.", "\tvar m1 = matrix.new&lt;float&gt;(2, 3, 5) ", "\t// Create a 2x3 matrix containing values `4`.", "\tvar m2 = matrix.new&lt;float&gt;(2, 3, 4) ", "\t// Create a new matrix containing the difference between matrices `m1` and `m2`.", "\tvar m3 = matrix.diff(m1, m2) ", "\t", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 1, 2, color.green)", '\ttable.cell(t, 0, 0, "Difference between two matrices:")', "\ttable.cell(t, 0, 1, str.tostring(m3))"]
                            }, {
                                desc: [a("Difference between a matrix and a scalar value", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.diff()` Example 2")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x3 matrix with values `4`.", "\tvar m1 = matrix.new&lt;float&gt;(2, 3, 4)", "\t", '\t// Create a new matrix containing the difference between the `m1` matrix and the "int" value `1`.', "\tvar m2 = matrix.diff(m1, 1)", "\t", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 1, 2, color.green)", '\ttable.cell(t,  0, 0, "Difference between a matrix and a scalar:")', "\ttable.cell(t,  0, 1, str.tostring(m2))"]
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}'],
                            syntax: ["matrix.diff(id1, id2) → matrix&lt;int&gt;", "matrix.diff(id1, id2) → matrix&lt;float&gt;", "matrix.diff(id1, id2) → matrix&lt;int&gt;", "matrix.diff(id1, id2) → matrix&lt;float&gt;"]
                        },
                        "matrix.mult": {
                            kind: "Built-in function",
                            desc: [a("The function returns a new matrix resulting from the {html_markup_1}product{html_markup_2} between the matrices `id1` and `id2`, or between an `id1` matrix and an `id2` scalar (a numerical value), or between an `id1` matrix and an `id2` vector (an array of values).", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Matrix_multiplication" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("A new matrix object containing the product of `id2` and `id1`.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id1",
                                info: a("First matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<int>/matrix<float>"
                            }, {
                                name: "id2",
                                info: a("Second matrix object, value or array.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float/matrix<int>/matrix<float>/int[]/float[]"
                            }],
                            detailedDesc: [{
                                desc: [a("Product of two matrices", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.mult()` Example 1")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 6x2 matrix containing values `5`.", "\tvar m1 = matrix.new&lt;float&gt;(6, 2, 5) ", "\t// Create a 2x3 matrix containing values `4`.", "\t// Note that it must have the same quantity of rows as there are columns in the first matrix.", "\tvar m2 = matrix.new&lt;float&gt;(2, 3, 4) ", "\t// Create a new matrix from the multiplication of the two matrices.", "\tvar m3 = matrix.mult(m1, m2) ", "\t", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 1, 2, color.green)", '\ttable.cell(t, 0, 0, "Product of two matrices:")', "\ttable.cell(t, 0, 1, str.tostring(m3))"]
                            }, {
                                desc: [a("Product of a matrix and a scalar", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.mult()` Example 2")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x3 matrix containing values `4`.", "\tvar m1 = matrix.new&lt;float&gt;(2, 3, 4) ", "\t", "\t// Create a new matrix from the product of the two matrices.", "\tscalar = 5", "\tvar m2 = matrix.mult(m1, scalar) ", "\t", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 5, 2, color.green)", '\ttable.cell(t, 0, 0, "Matrix 1:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 1, "x")', '\ttable.cell(t, 2, 0, "Scalar:")', "\ttable.cell(t, 2, 1, str.tostring(scalar))", '\ttable.cell(t, 3, 1, "=")', '\ttable.cell(t, 4, 0, "Matrix 2:")', "\ttable.cell(t, 4, 1, str.tostring(m2))"]
                            }, {
                                desc: [a("Product of a matrix and an array vector", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["//@version=5", 'indicator("`matrix.mult()` Example 3")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x3 matrix containing values `4`.", "\tvar m1 = matrix.new&lt;int&gt;(2, 3, 4)", "\t", "\t// Create an array of three elements.", "\tvar int[] a = array.from(1, 1, 1)", "\t", "\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.", "\tvar m3 = matrix.mult(m1, a) ", "\t", "\t// Display using a table.", "\tvar t = table.new(position.top_right, 5, 2, color.green)", '\ttable.cell(t, 0, 0, "Matrix 1:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 1, "x")', '\ttable.cell(t, 2, 0, "Value:")', '\ttable.cell(t, 2, 1, str.tostring(a, " "))', '\ttable.cell(t, 3, 1, "=")', '\ttable.cell(t, 4, 0, "Matrix 3:")', "\ttable.cell(t, 4, 1, str.tostring(m3))"]
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.sum}, {@fun matrix.diff}'],
                            syntax: ["matrix.mult(id1, id2) → matrix&lt;int&gt;", "matrix.mult(id1, id2) → matrix&lt;float&gt;", "matrix.mult(id1, id2) → matrix&lt;int&gt;", "matrix.mult(id1, id2) → matrix&lt;float&gt;", "matrix.mult(id1, id2) → int[]", "matrix.mult(id1, id2) → float[]"]
                        },
                        "matrix.pinv": {
                            kind: "Built-in function",
                            desc: [a("The function returns the {html_markup_1}pseudoinverse{html_markup_2} of a matrix.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("A new matrix containing the pseudoinverse of the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.pinv()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x2 matrix. ", "\tvar m1 = matrix.new&lt;int&gt;(2, 2, na)", "\t// Fill the matrix with values.", "\tmatrix.set(m1, 0, 0, 1)", "\tmatrix.set(m1, 0, 1, 2)", "\tmatrix.set(m1, 1, 0, 3)", "\tmatrix.set(m1, 1, 1, 4)", "\t", "\t// Pseudoinverse of the matrix.", "\tvar m2 = matrix.pinv(m1)", "\t", "\t// Display matrix elements.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Original Matrix:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Pseudoinverse matrix:")', "\ttable.cell(t, 1, 1, str.tostring(m2))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.inv}'],
                            remarks: [a("The function is calculated using a {html_markup_1}Moore–Penrose{html_markup_2} inverse formula based on singular-value decomposition of a matrix. For non-singular square matrices this function returns the result of {@fun matrix.inv}.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse#Definition" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            syntax: ["matrix.pinv(id) → matrix&lt;float&gt;", "matrix.pinv(id) → matrix&lt;int&gt;"]
                        },
                        "matrix.inv": {
                            kind: "Built-in function",
                            desc: [a("The function returns the {html_markup_1}inverse{html_markup_2} of a square matrix.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Invertible_matrix" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("A new matrix, which is the inverse of the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.inv()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x2 matrix. ", "\tvar m1 = matrix.new&lt;int&gt;(2, 2, na)", "\t// Fill the matrix with values.", "\tmatrix.set(m1, 0, 0, 1)", "\tmatrix.set(m1, 0, 1, 2)", "\tmatrix.set(m1, 1, 0, 3)", "\tmatrix.set(m1, 1, 1, 4)", "\t", "\t// Inverse of the matrix.", "\tvar m2 = matrix.inv(m1)", "\t", "\t// Display matrix elements.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Original Matrix:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Inverse matrix:")', "\ttable.cell(t, 1, 1, str.tostring(m2))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.pinv}, {@fun matrix.copy}, {@fun str.tostring}'],
                            remarks: [a("The function is calculated using the {html_markup_1}LU decomposition{html_markup_2} algorithm.", {
                                context: "pine_docs_remarks"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/LU_decomposition" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            syntax: ["matrix.inv(id) → matrix&lt;float&gt;", "matrix.inv(id) → matrix&lt;int&gt;"]
                        },
                        "matrix.rank": {
                            kind: "Built-in function",
                            desc: [a("The function calculates the {html_markup_1}rank{html_markup_2} of the matrix.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Rank_(linear_algebra)" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("The rank of the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.rank()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x2 matrix. ", "\tvar m1 = matrix.new&lt;int&gt;(2, 2, na)", "\t// Fill the matrix with values.", "\tmatrix.set(m1, 0, 0, 1)", "\tmatrix.set(m1, 0, 1, 2)", "\tmatrix.set(m1, 1, 0, 3)", "\tmatrix.set(m1, 1, 1, 4)", "\t", "\t// Get the rank of the matrix. ", "\tr = matrix.rank(m1)", "\t", "\t// Display matrix elements.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Matrix elements:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Rank of the matrix:")', "\ttable.cell(t, 1, 1, str.tostring(r)) "],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun str.tostring}'],
                            syntax: ["matrix.rank(id) → series int"]
                        },
                        "matrix.trace": {
                            kind: "Built-in function",
                            desc: [a("The function calculates the {html_markup_1}trace{html_markup_2} of a matrix (the sum of the main diagonal's elements).", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Trace_(linear_algebra)" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("The trace of the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.trace()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x2 matrix. ", "\tvar m1 = matrix.new&lt;int&gt;(2, 2, na)", "\t// Fill the matrix with values.", "\tmatrix.set(m1, 0, 0, 1)", "\tmatrix.set(m1, 0, 1, 2)", "\tmatrix.set(m1, 1, 0, 3)", "\tmatrix.set(m1, 1, 1, 4)", "\t", "\t// Get the trace of the matrix.", "\ttr = matrix.trace(m1)", "\t", "\t// Display matrix elements.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Matrix elements:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Trace of the matrix:")', "\ttable.cell(t, 1, 1, str.tostring(tr))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}'],
                            syntax: ["matrix.trace(id) → series float", "matrix.trace(id) → series int"]
                        },
                        "matrix.eigenvalues": {
                            kind: "Built-in function",
                            desc: [a("The function returns an array containing the {html_markup_1}eigenvalues{html_markup_2} of a square matrix.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("An array containing the eigenvalues of the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.eigenvalues()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x2 matrix. ", "\tvar m1 = matrix.new&lt;int&gt;(2, 2, na)", "\t// Fill the matrix with values.", "\tmatrix.set(m1, 0, 0, 2)", "\tmatrix.set(m1, 0, 1, 4)", "\tmatrix.set(m1, 1, 0, 6)", "\tmatrix.set(m1, 1, 1, 8)", "\t", "\t// Get the eigenvalues of the matrix.", "\ttr = matrix.eigenvalues(m1)", "\t", "\t// Display matrix elements.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Matrix elements:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Array of Eigenvalues:")', "\ttable.cell(t, 1, 1, str.tostring(tr)) "],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.eigenvectors}'],
                            remarks: [a('The function is calculated using "The Implicit QL Algorithm".', {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.eigenvalues(id) → float[]", "matrix.eigenvalues(id) → int[]"]
                        },
                        "matrix.eigenvectors": {
                            kind: "Built-in function",
                            desc: [a("Returns a matrix of {html_markup_1}eigenvectors{html_markup_2}, in which each column is an eigenvector of the `id` matrix.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("A new matrix containing the eigenvectors of the `id` matrix.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.eigenvectors()` Example")', "", "// For efficiency, execute this code only once.", "if barstate.islastconfirmedhistory", "\t// Create a 2x2 matrix ", "\tvar m1 = matrix.new&lt;int&gt;(2, 2, 1)", "\t// Fill the matrix with values.", "\tmatrix.set(m1, 0, 0, 2)", "\tmatrix.set(m1, 0, 1, 4)", "\tmatrix.set(m1, 1, 0, 6)", "\tmatrix.set(m1, 1, 1, 8)", "\t", "\t// Get the eigenvectors of the matrix.", "\tm2 = matrix.eigenvectors(m1)", "\t", "\t// Display matrix elements.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Matrix Elements:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Matrix Eigenvectors:")', "\ttable.cell(t, 1, 1, str.tostring(m2))  "],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.eigenvalues}'],
                            remarks: [a('The function is calculated using "The Implicit QL Algorithm".', {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.eigenvectors(id) → matrix&lt;float&gt;", "matrix.eigenvectors(id) → matrix&lt;int&gt;"]
                        },
                        "matrix.kron": {
                            kind: "Built-in function",
                            desc: [a("The function returns the {html_markup_1}Kronecker product{html_markup_2} for the `id1` and `id2` matrices.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Kronecker_product" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("A new matrix containing the {html_markup_1}Kronecker product{html_markup_2} of `id1` and `id2`.", {
                                context: "pine_docs_returns"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Kronecker_product" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            args: [{
                                name: "id1",
                                info: a("First matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }, {
                                name: "id2",
                                info: a("Second matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.kron()` Example")', "", "// Display using a table.", "if barstate.islastconfirmedhistory", "\t// Create two matrices with default values `1` and `2`. ", "\tvar m1 = matrix.new&lt;float&gt;(2, 2, 1) ", "\tvar m2 = matrix.new&lt;float&gt;(2, 2, 2) ", "\t", "\t// Calculate the Kronecker product of the matrices.", "\tvar m3 = matrix.kron(m1, m2) ", "\t", "\t// Display matrix elements.", "\tvar t = table.new(position.top_right, 5, 2, color.green)", '\ttable.cell(t, 0, 0, "Matrix 1:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 1, "⊗")', '\ttable.cell(t, 2, 0, "Matrix 2:")', "\ttable.cell(t, 2, 1, str.tostring(m2))", '\ttable.cell(t, 3, 1, "=")', '\ttable.cell(t, 4, 0, "Kronecker product:")', "\ttable.cell(t, 4, 1, str.tostring(m3))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.mult}, {@fun str.tostring}, {@fun table.new}'],
                            syntax: ["matrix.kron(id1, id2) → matrix&lt;float&gt;", "matrix.kron(id1, id2) → matrix&lt;int&gt;"]
                        },
                        "matrix.pow": {
                            kind: "Built-in function",
                            desc: [a("The function calculates the product of the matrix by itself `power` times.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("The product of the `id` matrix by itself `power` times.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("A matrix object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }, {
                                name: "power",
                                info: a("The number of times the matrix will be multiplied by itself.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("`matrix.pow()` Example")', "", "// Display using a table.", "if barstate.islastconfirmedhistory", "\t// Create a 2x2 matrix. ", "\tvar m1 = matrix.new&lt;int&gt;(2, 2, 2)", "\t// Calculate the power of three of the matrix.", "\tvar m2 = matrix.pow(m1, 3)", "\t", "\t// Display matrix elements.", "\tvar t = table.new(position.top_right, 2, 2, color.green)", '\ttable.cell(t, 0, 0, "Original Matrix:")', "\ttable.cell(t, 0, 1, str.tostring(m1))", '\ttable.cell(t, 1, 0, "Matrix³:")', "\ttable.cell(t, 1, 1, str.tostring(m2))"],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.mult}'],
                            syntax: ["matrix.pow(id, power) → matrix&lt;float&gt;", "matrix.pow(id, power) → matrix&lt;int&gt;"]
                        },
                        "matrix.is_zero": {
                            kind: "Built-in function",
                            desc: [a("The function determines if all elements of the matrix are zero.", {
                                context: "pine_docs_desc"
                            })],
                            returns: [a("Returns true if all elements of the `id` matrix are zero, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Matrix object to check.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}'],
                            syntax: ["matrix.is_zero(id) → series bool"]
                        },
                        "matrix.is_identity": {
                            kind: "Built-in function",
                            desc: [a("The function determines if a matrix is an {html_markup_1}identity matrix{html_markup_2} (elements with ones on the {html_markup_3}main diagonal{html_markup_4} and zeros elsewhere).", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Identity_matrix" rel="nofollow">',
                                html_markup_2: "</a>",
                                html_markup_3: '<a target="blank" href="https://en.wikipedia.org/wiki/Main_diagonal" rel="nofollow">',
                                html_markup_4: "</a>"
                            })],
                            returns: [a("Returns true if `id` is an identity matrix, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Matrix object to test.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.is_square}, {@fun matrix.is_diagonal}'],
                            remarks: [a("Returns false with non-square matrices.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.is_identity(id) → series bool"]
                        },
                        "matrix.is_binary": {
                            kind: "Built-in function",
                            desc: [a("The function determines if the matrix is {html_markup_1}binary{html_markup_2} (when all elements of the matrix are 0 or 1).", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Logical_matrix" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("Returns true if the `id` matrix is binary, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Matrix object to test.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}'],
                            syntax: ["matrix.is_binary(id) → series bool"]
                        },
                        "matrix.is_symmetric": {
                            kind: "Built-in function",
                            desc: [a("The function determines if a {html_markup_1}square matrix{html_markup_2} is {html_markup_3}symmetric{html_markup_4} (elements are symmetric with respect to the {html_markup_5}main diagonal{html_markup_6}).", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Square_matrix" rel="nofollow">',
                                html_markup_2: "</a>",
                                html_markup_3: '<a target="blank" href="https://en.wikipedia.org/wiki/Symmetric_matrix" rel="nofollow">',
                                html_markup_4: "</a>",
                                html_markup_5: '<a target="blank" href="https://en.wikipedia.org/wiki/Main_diagonal" rel="nofollow">',
                                html_markup_6: "</a>"
                            })],
                            returns: [a("Returns true if the `id` matrix is symmetric, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Matrix object to test.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.is_square}'],
                            remarks: [a("Returns false with non-square matrices.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.is_symmetric(id) → series bool"]
                        },
                        "matrix.is_antisymmetric": {
                            kind: "Built-in function",
                            desc: [a("The function determines if a matrix is {html_markup_1}antisymmetric{html_markup_2} (its {html_markup_3}transpose{html_markup_4} equals its negative).", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Skew-symmetric_matrix" rel="nofollow">',
                                html_markup_2: "</a>",
                                html_markup_3: '<a target="blank" href="https://en.wikipedia.org/wiki/Transpose" rel="nofollow">',
                                html_markup_4: "</a>"
                            })],
                            returns: [a("Returns true, if the `id` matrix is antisymmetric, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Matrix object to test.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.is_square}'],
                            remarks: [a("Returns false with non-square matrices.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.is_antisymmetric(id) → series bool"]
                        },
                        "matrix.is_diagonal": {
                            kind: "Built-in function",
                            desc: [a("The function determines if the matrix is {html_markup_1}diagonal{html_markup_2} (all elements outside the main diagonal are zero).", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Diagonal_matrix" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("Returns true if the `id` matrix is diagonal, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Matrix object to test.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.is_square}, {@fun matrix.is_identity}, {@fun matrix.is_antidiagonal}'],
                            remarks: [a("Returns false with non-square matrices.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.is_diagonal(id) → series bool"]
                        },
                        "matrix.is_antidiagonal": {
                            kind: "Built-in function",
                            desc: [a("The function determines if the matrix is {html_markup_1}anti-​​diagonal{html_markup_2} (all elements outside the secondary diagonal are zero).", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Anti-diagonal_matrix" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("Returns true if the `id` matrix is ​​anti-diagonal, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Matrix object to test.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.is_square}, {@fun matrix.is_identity}, {@fun matrix.is_diagonal}'],
                            remarks: [a("Returns false with non-square matrices.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.is_antidiagonal(id) → series bool"]
                        },
                        "matrix.is_triangular": {
                            kind: "Built-in function",
                            desc: [a("The function determines if the matrix is {html_markup_1}triangular{html_markup_2} (if all elements above or below the {html_markup_3}main diagonal{html_markup_4} are zero).", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Triangular_matrix" rel="nofollow">',
                                html_markup_2: "</a>",
                                html_markup_3: '<a target="blank" href="https://en.wikipedia.org/wiki/Main_diagonal" rel="nofollow">',
                                html_markup_4: "</a>"
                            })],
                            returns: [a("Returns true if the `id` matrix is triangular, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Matrix object to test.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}, {@fun matrix.is_square}'],
                            remarks: [a("Returns false with non-square matrices.", {
                                context: "pine_docs_remarks"
                            })],
                            syntax: ["matrix.is_triangular(id) → series bool"]
                        },
                        "matrix.is_stochastic": {
                            kind: "Built-in function",
                            desc: [a("The function determines if the matrix is {html_markup_1}stochastic{html_markup_2}.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Stochastic_matrix" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("Returns true if the `id` matrix is stochastic, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Matrix object to test.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "matrix<float>/matrix<int>"
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.set}'],
                            syntax: ["matrix.is_stochastic(id) → series bool"]
                        },
                        "matrix.is_square": {
                            kind: "Built-in function",
                            desc: [a("The function determines if the matrix is {html_markup_1}square{html_markup_2} (it has the same number of rows and columns).", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://en.wikipedia.org/wiki/Square_matrix" rel="nofollow">',
                                html_markup_2: "</a>"
                            })],
                            returns: [a("Returns true if the `id` matrix is square, false otherwise.", {
                                context: "pine_docs_returns"
                            })],
                            args: [{
                                name: "id",
                                info: a("Matrix object to test.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "any matrix type"
                            }],
                            seeAlso: ['{html_markup_start}<a href="">{@fun matrix.new<type>}{html_markup_end}{html_markup_start}</a>{html_markup_end}, {@fun matrix.get}, {@fun matrix.set}, {@fun matrix.columns}, {@fun matrix.rows}'],
                            syntax: ["matrix.is_square(id) → series bool"]
                        },
                        "table.merge_cells": {
                            kind: "Built-in function",
                            desc: [a("The function merges a sequence of cells in the table into one cell. The cells are merged in a rectangle shape where the start_column and start_row specify the top-left corner, and end_column and end_row specify the bottom-right corner.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "table_id",
                                info: a("A table object.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series table"
                            }, {
                                name: "start_column",
                                info: a("The index of the column of the first cell to merge. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "start_row",
                                info: a("The index of the row of the first cell to merge. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "end_column",
                                info: a("The index of the column of the last cell to merge. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }, {
                                name: "end_row",
                                info: a("The index of the row of the last cell to merge. Numbering starts at 0.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'indicator("table.merge_cells example")', "SMA50  = ta.sma(close, 50)", "SMA100 = ta.sma(close, 100)", "SMA200 = ta.sma(close, 200)", "if barstate.islast", "\tmaTable = table.new(position.bottom_right, 3, 3, bgcolor = color.gray, border_width = 1, border_color = color.black)", "\t// Header", '\ttable.cell(maTable, 0, 0, text = "SMA Table")', "\ttable.merge_cells(maTable, 0, 0, 2, 0)", "\t// Cell Titles", '\ttable.cell(maTable, 0, 1, text = "SMA 50")', '\ttable.cell(maTable, 1, 1, text = "SMA 100")', '\ttable.cell(maTable, 2, 1, text = "SMA 200")', "\t// Values", "\ttable.cell(maTable, 0, 2, bgcolor = color.white, text = str.tostring(SMA50))", "\ttable.cell(maTable, 1, 2, bgcolor = color.white, text = str.tostring(SMA100))", "\ttable.cell(maTable, 2, 2, bgcolor = color.white, text = str.tostring(SMA200))"],
                            remarks: [a("This function will merge cells, even if their properties are not yet defined with {@fun table.cell}.", {
                                context: "pine_docs_remarks"
                            }), a("The resulting merged cell inherits all of its values from the cell located at `start_column`:`start_row`, except width and height. The width and height of the resulting merged cell are based on the width/height of other cells in the neighboring columns/rows and cannot be set manually.", {
                                context: "pine_docs_remarks"
                            }), a("To modify the merged cell with any of the `table.cell_set_*` functions, target the cell at the `start_column`:`start_row` coordinates.", {
                                context: "pine_docs_remarks"
                            }), a("An attempt to merge a cell that has already been merged will result in an error.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun table.delete}, {@fun table.new}"],
                            syntax: ["table.merge_cells(table_id, start_column, start_row, end_column, end_row) → void"]
                        },
                        "strategy.closedtrades.entry_price": {
                            kind: "Built-in function",
                            desc: [a("Returns the price of the closed trade's entry.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the closed trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'strategy("strategy.closedtrades.entry_price Example 1")', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Return the entry price for the latest  entry.", "entryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)", "", 'plot(entryPrice, "Long entry price")']
                            }, {
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Calculates the average profit percentage for all closed trades.", "//@version=5", 'strategy("strategy.closedtrades.entry_price Example 2")', "", "// Strategy calls to create single short and long trades", "if bar_index == last_bar_index - 15", '    strategy.entry("Long Entry",  strategy.long)', "else if bar_index == last_bar_index - 10", '    strategy.close("Long Entry")', '    strategy.entry("Short", strategy.short)', "else if bar_index == last_bar_index - 5", '    strategy.close("Short")', "", "// Calculate profit for both closed trades.", "profitPct = 0.0", "for tradeNo = 0 to strategy.closedtrades - 1", "    entryP = strategy.closedtrades.entry_price(tradeNo)", "    exitP = strategy.closedtrades.exit_price(tradeNo)", "    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100", "    ", "// Calculate average profit percent for both closed trades.", "avgProfitPct = nz(profitPct / strategy.closedtrades)", "", "plot(avgProfitPct)"]
                            }],
                            seeAlso: ["{@fun strategy.closedtrades.entry_price}, {@fun strategy.closedtrades.exit_price}, {@fun strategy.closedtrades.size}, {@var strategy.closedtrades},"],
                            syntax: ["strategy.closedtrades.entry_price(trade_num) → series float"]
                        },
                        "strategy.closedtrades.entry_bar_index": {
                            kind: "Built-in function",
                            desc: [a("Returns the bar_index of the closed trade's entry.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the closed trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'strategy("strategy.closedtrades.entry_bar_index Example")', "// Enter long trades on three rising bars; exit on two falling bars.", "if ta.rising(close, 3)", '    strategy.entry("Long", strategy.long)', "if ta.falling(close, 2)", '    strategy.close("Long")', "// Function that calculates the average amount of bars in a trade.", "avgBarsPerTrade() =>", "\tsumBarsPerTrade = 0", "\tfor tradeNo = 0 to strategy.closedtrades - 1", "\t\t// Loop through all closed trades, starting with the oldest.", "\t\tsumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index(tradeNo) + 1", "\tresult = nz(sumBarsPerTrade / strategy.closedtrades)", "plot(avgBarsPerTrade())"],
                            seeAlso: ["{@fun strategy.closedtrades.exit_bar_index}", "{@fun strategy.opentrades.entry_bar_index}"],
                            syntax: ["strategy.closedtrades.entry_bar_index(trade_num) → series int"]
                        },
                        "strategy.closedtrades.entry_time": {
                            kind: "Built-in function",
                            desc: [a("Returns the UNIX time of the closed trade's entry.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the closed trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'strategy("strategy.closedtrades.entry_time Example", overlay = true)', "", "// Enter long trades on three rising bars; exit on two falling bars.", "if ta.rising(close, 3)", '    strategy.entry("Long", strategy.long)', "if ta.falling(close, 2)", '    strategy.close("Long")', "", "// Calculate the average trade duration ", "avgTradeDuration() =>", "    sumTradeDuration = 0", "    for i = 0 to strategy.closedtrades - 1", "        sumTradeDuration += strategy.closedtrades.exit_time(i) - strategy.closedtrades.entry_time(i)", "    result = nz(sumTradeDuration / strategy.closedtrades)", "", "// Display average duration converted to seconds and formatted using 2 decimal points", "if barstate.islastconfirmedhistory", '    label.new(bar_index, high, str.tostring(avgTradeDuration() / 1000, "#.##") + " seconds")'],
                            seeAlso: ["{@fun strategy.opentrades.entry_time}", "{@fun strategy.closedtrades.exit_time}", "{@var time}"],
                            syntax: ["strategy.closedtrades.entry_time(trade_num) → series int"]
                        },
                        "strategy.closedtrades.exit_price": {
                            kind: "Built-in function",
                            desc: [a("Returns the price of the closed trade's exit.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the closed trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'strategy("strategy.closedtrades.exit_price Example 1")', "", "// We are creating a long trade every 5 bars", "if bar_index % 5 == 0", '    strategy.entry("Long",  strategy.long)', 'strategy.close("Long")', "", "// Return the exit price from the latest closed trade.", "exitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)", "", 'plot(exitPrice, "Long exit price")']
                            }, {
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Calculates the average profit percentage for all closed trades.", "//@version=5", 'strategy("strategy.closedtrades.exit_price Example 2")', "", "// Strategy calls to create single short and long trades.", "if bar_index == last_bar_index - 15", '    strategy.entry("Long Entry",  strategy.long)', "else if bar_index == last_bar_index - 10", '    strategy.close("Long Entry")', '    strategy.entry("Short", strategy.short)', "else if bar_index == last_bar_index - 5", '    strategy.close("Short")', "", "// Calculate profit for both closed trades.", "profitPct = 0.0", "for tradeNo = 0 to strategy.closedtrades - 1", "    entryP = strategy.closedtrades.entry_price(tradeNo)", "    exitP = strategy.closedtrades.exit_price(tradeNo)", "    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100", "    ", "// Calculate average profit percent for both closed trades.", "avgProfitPct = nz(profitPct / strategy.closedtrades)", "", "plot(avgProfitPct)"]
                            }],
                            seeAlso: ["{@fun strategy.closedtrades.entry_price}"],
                            syntax: ["strategy.closedtrades.exit_price(trade_num) → series float"]
                        },
                        "strategy.closedtrades.exit_bar_index": {
                            kind: "Built-in function",
                            desc: [a("Returns the bar_index of the closed trade's exit.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the closed trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'strategy("strategy.closedtrades.exit_bar_index Example 1")', "", "// Strategy calls to place a single short trade. We enter the trade at the first bar and exit the trade at 10 bars before the last chart bar.", "if bar_index == 0", '    strategy.entry("Short",  strategy.short)', "if bar_index == last_bar_index - 10", '    strategy.close("Short")', "", "// Calculate the amount of bars since the last closed trade.", "barsSinceClosed = strategy.closedtrades > 0 ? bar_index - strategy.closedtrades.exit_bar_index(strategy.closedtrades - 1) : na", "", 'plot(barsSinceClosed, "Bars since last closed trade")']
                            }, {
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Calculates the average amount of bars per trade.", "//@version=5", 'strategy("strategy.closedtrades.exit_bar_index Example 2")', "", "// Enter long trades on three rising bars; exit on two falling bars.", "if ta.rising(close, 3)", '    strategy.entry("Long", strategy.long)', "if ta.falling(close, 2)", '    strategy.close("Long")', "", "// Function that calculates the average amount of bars per trade.", "avgBarsPerTrade() =>", "    sumBarsPerTrade = 0", "    for tradeNo = 0 to strategy.closedtrades - 1", "        // Loop through all closed trades, starting with the oldest.", "        sumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index(tradeNo) + 1", "    result = nz(sumBarsPerTrade / strategy.closedtrades)", "", "plot(avgBarsPerTrade())"]
                            }],
                            seeAlso: ["{@var bar_index}", "{@var last_bar_index}"],
                            syntax: ["strategy.closedtrades.exit_bar_index(trade_num) → series int"]
                        },
                        "strategy.closedtrades.exit_time": {
                            kind: "Built-in function",
                            desc: [a("Returns the UNIX time of the closed trade's exit.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the closed trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'strategy("strategy.closedtrades.exit_time Example 1")', "", "// Enter long trades on three rising bars; exit on two falling bars.", "if ta.rising(close, 3)", '    strategy.entry("Long", strategy.long)', "if ta.falling(close, 2)", '    strategy.close("Long")', "", "// Calculate the average trade duration. ", "avgTradeDuration() =>", "    sumTradeDuration = 0", "    for i = 0 to strategy.closedtrades - 1", "        sumTradeDuration += strategy.closedtrades.exit_time(i) - strategy.closedtrades.entry_time(i)", "    result = nz(sumTradeDuration / strategy.closedtrades)", "", "// Display average duration converted to seconds and formatted using 2 decimal points.", "if barstate.islastconfirmedhistory", '    label.new(bar_index, high, str.tostring(avgTradeDuration() / 1000, "#.##") + " seconds")']
                            }, {
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Reopens a closed trade after X seconds.", "//@version=5", 'strategy("strategy.closedtrades.exit_time Example 2")', "", "// Strategy calls to emulate a single long trade at the first bar.", "if bar_index == 0", '    strategy.entry("Long", strategy.long)', "", "reopenPositionAfter(timeSec) =>", "    if strategy.closedtrades > 0", "        if time - strategy.closedtrades.exit_time(strategy.closedtrades - 1) >= timeSec * 1000", '            strategy.entry("Long", strategy.long)', "", "// Reopen last closed position after 120 sec.                ", "reopenPositionAfter(120)", "", "if ta.change(strategy.opentrades)", '    strategy.exit("Long", stop = low * 0.9, profit = high * 2.5)']
                            }],
                            seeAlso: ["{@fun strategy.closedtrades.entry_time}"],
                            syntax: ["strategy.closedtrades.exit_time(trade_num) → series int"]
                        },
                        "strategy.closedtrades.size": {
                            kind: "Built-in function",
                            desc: [a("Returns the direction and the number of contracts traded in the closed trade. If the value is > 0, the market position was long. If the value is < 0, the market position was short.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the closed trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'strategy("`strategy.closedtrades.size` Example 1")', "", "// We calculate the max amt of shares we can buy.", "amtShares = math.floor(strategy.equity / close)", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long, qty = amtShares)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Plot the number of contracts traded in the last closed trade.     ", 'plot(strategy.closedtrades.size(strategy.closedtrades - 1), "Number of contracts traded")']
                            }, {
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Calculates the average profit percentage for all closed trades.", "//@version=5", 'strategy("`strategy.closedtrades.size` Example 2")', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "", "// Calculate profit for both closed trades.", "profitPct = 0.0", "for tradeNo = 0 to strategy.closedtrades - 1", "    entryP = strategy.closedtrades.entry_price(tradeNo)", "    exitP = strategy.closedtrades.exit_price(tradeNo)", "    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100", "    ", "// Calculate average profit percent for both closed trades.", "avgProfitPct = nz(profitPct / strategy.closedtrades)", "", "plot(avgProfitPct)"]
                            }],
                            seeAlso: ["{@fun strategy.opentrades.size}", "{@var strategy.position_size}", "{@var strategy.closedtrades}", "{@var strategy.opentrades}"],
                            syntax: ["strategy.closedtrades.size(trade_num) → series float"]
                        },
                        "strategy.closedtrades.profit": {
                            kind: "Built-in function",
                            desc: [a("Returns the profit/loss of the closed trade. Losses are expressed as negative values.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the closed trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'strategy("`strategy.closedtrades.profit` Example")', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Calculate average gross profit by adding the difference between gross profit and commission.", "avgGrossProfit() =>", "    sumGrossProfit = 0.0", "    for tradeNo = 0 to strategy.closedtrades - 1", "        sumGrossProfit += strategy.closedtrades.profit(tradeNo) - strategy.closedtrades.commission(tradeNo)", "    result = nz(sumGrossProfit / strategy.closedtrades)", "    ", 'plot(avgGrossProfit(), "Average gross profit")'],
                            seeAlso: ["{@fun strategy.opentrades.profit}", "{@fun strategy.closedtrades.commission}"],
                            syntax: ["strategy.closedtrades.profit(trade_num) → series float"]
                        },
                        "strategy.closedtrades.commission": {
                            kind: "Built-in function",
                            desc: [a("Returns the sum of entry and exit fees paid in the closed trade.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the closed trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'strategy("`strategy.closedtrades.commission` Example", commission_type = strategy.commission.percent, commission_value = 0.1)', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Plot total fees for the latest closed trade.", "plot(strategy.closedtrades.commission(strategy.closedtrades - 1))"],
                            seeAlso: ["{@fun strategy}", "{@fun strategy.opentrades.commission}"],
                            syntax: ["strategy.closedtrades.commission(trade_num) → series float"]
                        },
                        "strategy.closedtrades.max_runup": {
                            kind: "Built-in function",
                            desc: [a("Returns the maximum run up of the closed trade, i.e., the maximum possible profit during the trade.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the closed trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'strategy("`strategy.closedtrades.max_runup` Example")', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Get the biggest max trade runup value from all of the closed trades.", "maxTradeRunUp() =>", "    maxRunup = 0.0", "    for tradeNo = 0 to strategy.closedtrades - 1", "        maxRunup := math.max(maxRunup, strategy.closedtrades.max_runup(tradeNo))", "    result = maxRunup", "", 'plot(maxTradeRunUp(), "Max trade runup")'],
                            seeAlso: ["{@fun strategy.opentrades.max_runup}", "{@fun strategy.max_drawdown}"],
                            syntax: ["strategy.closedtrades.max_runup(trade_num) → series float"]
                        },
                        "strategy.closedtrades.max_drawdown": {
                            kind: "Built-in function",
                            desc: [a("Returns the maximum drawdown of the closed trade, i.e., the maximum possible loss during the trade.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the closed trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'strategy("`strategy.closedtrades.max_drawdown` Example")', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Get the biggest max trade drawdown value from all of the closed trades.", "maxTradeDrawDown() =>", "    maxDrawdown = 0.0", "    for tradeNo = 0 to strategy.closedtrades - 1", "        maxDrawdown := math.max(maxDrawdown, strategy.closedtrades.max_drawdown(tradeNo))", "    result = maxDrawdown", "", 'plot(maxTradeDrawDown(), "Biggest max drawdown")'],
                            remarks: [a("The function returns na if trade_num is not in the range: 0 to strategy.closedtrades - 1.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun strategy.opentrades.max_drawdown}", "{@fun strategy.max_drawdown}"],
                            syntax: ["strategy.closedtrades.max_drawdown(trade_num) → series float"]
                        },
                        "strategy.closedtrades.entry_id": {
                            kind: "Built-in function",
                            desc: [a("Returns the id of the closed trade's entry.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the closed trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            returns: [a("Returns the id of the closed trade's entry.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'strategy("strategy.closedtrades.entry_id Example", overlay = true)', "", "// Enter a short position and close at the previous to last bar.", "if bar_index == 1", '    strategy.entry("Short at bar #" + str.tostring(bar_index), strategy.short)', "if bar_index == last_bar_index - 2", "    strategy.close_all()", "    ", "// Display ID of the last entry position.", "if barstate.islastconfirmedhistory", '    label.new(last_bar_index, high, "Last Entry ID is: " + strategy.closedtrades.entry_id(strategy.closedtrades - 1))'],
                            remarks: [a("The function returns na if trade_num is not in the range: 0 to strategy.closedtrades-1.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun strategy.closedtrades.entry_bar_index}", "{@fun strategy.closedtrades.entry_price()}", "{@fun strategy.closedtrades.entry_time}"],
                            syntax: ["strategy.closedtrades.entry_id(trade_num) → series string"]
                        },
                        "strategy.closedtrades.exit_id": {
                            kind: "Built-in function",
                            desc: [a("Returns the id of the closed trade's exit.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the closed trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            returns: [a("Returns the id of the closed trade's exit.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'strategy("strategy.closedtrades.exit_id Example", overlay = true)', "", "// Strategy calls to create single short and long trades", "if bar_index == last_bar_index - 15", '    strategy.entry("Long Entry",  strategy.long)', "else if bar_index == last_bar_index - 10", '    strategy.entry("Short Entry", strategy.short)', "    ", "// When a new open trade is detected then we create the exit strategy corresponding with the matching entry id", "// We detect the correct entry id by determining if a position is long or short based on the position quantity", "if ta.change(strategy.opentrades)", "    posSign = strategy.opentrades.size(strategy.opentrades - 1)", '    strategy.exit(posSign > 0 ? "SL Long Exit" : "SL Short Exit", strategy.opentrades.entry_id(strategy.opentrades - 1), stop = posSign > 0 ? high - ta.tr : low + ta.tr)', "", "// When a new closed trade is detected then we place a label above the bar with the exit info", "if ta.change(strategy.closedtrades)", '    msg = "Trade closed by: " + strategy.closedtrades.exit_id(strategy.closedtrades - 1)', "    label.new(bar_index, high + (3 * ta.tr), msg)"],
                            remarks: [a("The function returns na if trade_num is not in the range: 0 to strategy.closedtrades-1.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun strategy.closedtrades.exit_bar_index}", "{@fun strategy.closedtrades.exit_price()}", "{@fun strategy.closedtrades.exit_time}"],
                            syntax: ["strategy.closedtrades.exit_id(trade_num) → series string"]
                        },
                        "strategy.opentrades.entry_price": {
                            kind: "Built-in function",
                            desc: [a("Returns the price of the open trade's entry.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the open trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'strategy("strategy.closedtrades.entry_price Example 1")', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Return the entry price for the latest closed trade.", "entryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)", "", 'plot(entryPrice, "Long entry price")']
                            }, {
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Calculates the average price for the open position.", "//@version=5", 'strategy("strategy.opentrades.entry_price Example 2", pyramiding = 2)', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Calculates the average price for the open position.", "avgOpenPositionPrice() =>", "    sumOpenPositionPrice = 0.0", "    for tradeNo = 0 to strategy.opentrades - 1", "        sumOpenPositionPrice += strategy.opentrades.entry_price(tradeNo) * strategy.opentrades.size(tradeNo) / strategy.position_size", "    result = nz(sumOpenPositionPrice / strategy.opentrades)", "", "plot(avgOpenPositionPrice())"]
                            }],
                            seeAlso: ["{@fun strategy.closedtrades.exit_price}"],
                            syntax: ["strategy.opentrades.entry_price(trade_num) → series float"]
                        },
                        "strategy.opentrades.entry_bar_index": {
                            kind: "Built-in function",
                            desc: [a("Returns the bar_index of the open trade's entry.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the open trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            detailedDesc: [{
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Wait 10 bars and then close the position.", "//@version=5", 'strategy("`strategy.opentrades.entry_bar_index` Example")', "", "barsSinceLastEntry() =>", "    strategy.opentrades > 0 ? bar_index - strategy.opentrades.entry_bar_index(strategy.opentrades - 1) : na", "", "// Enter a long position if there are no open positions.", "if strategy.opentrades == 0", '    strategy.entry("Long",  strategy.long)', "", "// Close the long position after 10 bars. ", "if barsSinceLastEntry() >= 10", '    strategy.close("Long")']
                            }],
                            seeAlso: ["{@fun strategy.closedtrades.entry_bar_index}", "{@fun strategy.closedtrades.exit_bar_index}"],
                            syntax: ["strategy.opentrades.entry_bar_index(trade_num) → series int"]
                        },
                        "strategy.opentrades.entry_time": {
                            kind: "Built-in function",
                            desc: [a("Returns the UNIX time of the open trade's entry.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the open trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            examples: ["//@version=5", 'strategy("strategy.opentrades.entry_time Example")', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Calculates duration in milliseconds since the last position was opened.", "timeSinceLastEntry()=>", "    strategy.opentrades > 0 ? (time - strategy.opentrades.entry_time(strategy.opentrades - 1)) : na", "", 'plot(timeSinceLastEntry() / 1000 * 60 * 60 * 24, "Days since last entry")'],
                            seeAlso: ["{@fun strategy.closedtrades.entry_time}", "{@fun strategy.closedtrades.exit_time}"],
                            syntax: ["strategy.opentrades.entry_time(trade_num) → series int"]
                        },
                        "strategy.opentrades.size": {
                            kind: "Built-in function",
                            desc: [a("Returns the direction and the number of contracts traded in the open trade. If the value is > 0, the market position was long. If the value is < 0, the market position was short.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the open trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'strategy("`strategy.opentrades.size` Example 1")', "", "// We calculate the max amt of shares we can buy.", "amtShares = math.floor(strategy.equity / close)", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long, qty = amtShares)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Plot the number of contracts in the latest open trade.", 'plot(strategy.opentrades.size(strategy.opentrades - 1), "Amount of contracts in latest open trade")']
                            }, {
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Calculates the average profit percentage for all open trades.", "//@version=5", 'strategy("`strategy.opentrades.size` Example 2")', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Calculate profit for all open trades.", "profitPct = 0.0", "for tradeNo = 0 to strategy.opentrades - 1", "    entryP = strategy.opentrades.entry_price(tradeNo)", "    exitP = close", "    profitPct += (exitP - entryP) / entryP * strategy.opentrades.size(tradeNo) * 100", "    ", "// Calculate average profit percent for all open trades.", "avgProfitPct = nz(profitPct / strategy.opentrades)", "plot(avgProfitPct)"]
                            }],
                            seeAlso: ["{@fun strategy.closedtrades.size}", "{@var strategy.position_size}", "{@var strategy.opentrades}", "{@var strategy.closedtrades}"],
                            syntax: ["strategy.opentrades.size(trade_num) → series float"]
                        },
                        "strategy.opentrades.profit": {
                            kind: "Built-in function",
                            desc: [a("Returns the profit/loss of the open trade. Losses are expressed as negative values.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the open trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            detailedDesc: [{
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Returns the profit of the last open trade.", "//@version=5", 'strategy("`strategy.opentrades.profit` Example 1", commission_type = strategy.commission.percent, commission_value = 0.1)', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", 'plot(strategy.opentrades.profit(strategy.opentrades - 1), "Profit of the latest open trade")']
                            }, {
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Calculates the profit for all open trades.", "//@version=5", 'strategy("`strategy.opentrades.profit` Example 2", pyramiding = 5)', "", "// Strategy calls to enter 5 long positions every 2 bars.", "if bar_index % 2 == 0", '    strategy.entry("Long", strategy.long, qty = 5)', "", "// Calculate open profit or loss for the open positions.", "tradeOpenPL() =>", "    sumProfit = 0.0", "    for tradeNo = 0 to strategy.opentrades - 1", "        sumProfit += strategy.opentrades.profit(tradeNo)", "    result = sumProfit", "    ", 'plot(tradeOpenPL(), "Profit of all open trades")']
                            }],
                            seeAlso: ["{@fun strategy.closedtrades.profit}", "{@var strategy.openprofit}", "{@var strategy.netprofit}", "{@var strategy.grossprofit}"],
                            syntax: ["strategy.opentrades.profit(trade_num) → series float"]
                        },
                        "strategy.opentrades.commission": {
                            kind: "Built-in function",
                            desc: [a("Returns the sum of entry and exit fees paid in the open trade.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the open trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            detailedDesc: [{
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Calculates the gross profit or loss for the current open position.", "//@version=5", 'strategy("`strategy.opentrades.commission` Example", commission_type = strategy.commission.percent, commission_value = 0.1)', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Calculate gross profit or loss for open positions only.", "tradeOpenGrossPL() =>", "    sumOpenGrossPL = 0.0", "    for tradeNo = 0 to strategy.opentrades - 1", "        sumOpenGrossPL += strategy.opentrades.profit(tradeNo) - strategy.opentrades.commission(tradeNo)", "    result = sumOpenGrossPL", "    ", "plot(tradeOpenGrossPL())"]
                            }],
                            seeAlso: ["{@fun strategy}", "{@fun strategy.closedtrades.commission}"],
                            syntax: ["strategy.opentrades.commission(trade_num) → series float"]
                        },
                        "strategy.opentrades.max_runup": {
                            kind: "Built-in function",
                            desc: [a("Returns the maximum run up of the open trade, i.e., the maximum possible profit during the trade.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the open trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'strategy("strategy.opentrades.max_runup Example 1")', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Plot the max runup of the latest open trade.", 'plot(strategy.opentrades.max_runup(strategy.opentrades - 1), "Max runup of the latest open trade")']
                            }, {
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Calculates the max trade runup value for all open trades.", "//@version=5", 'strategy("strategy.opentrades.max_runup Example 2", pyramiding = 100)', "", "// Enter a long position every 30 bars.", "if bar_index % 30 == 0", '    strategy.entry("Long", strategy.long)', "", "// Calculate biggest max trade runup value from all of the open trades.", "maxOpenTradeRunUp() =>", "    maxRunup = 0.0", "    for tradeNo = 0 to strategy.opentrades - 1", "        maxRunup := math.max(maxRunup, strategy.opentrades.max_runup(tradeNo))", "    result = maxRunup", "", 'plot(maxOpenTradeRunUp(), "Biggest max runup of all open trades")']
                            }],
                            seeAlso: ["{@fun strategy.closedtrades.max_runup}", "{@var strategy.max_drawdown}"],
                            syntax: ["strategy.opentrades.max_runup(trade_num) → series float"]
                        },
                        "strategy.opentrades.max_drawdown": {
                            kind: "Built-in function",
                            desc: [a("Returns the maximum drawdown of the open trade, i.e., the maximum possible loss during the trade.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the open trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'strategy("strategy.opentrades.max_drawdown Example 1")', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Plot the max drawdown of the latest open trade.", 'plot(strategy.opentrades.max_drawdown(strategy.opentrades - 1), "Max drawdown of the latest open trade")']
                            }, {
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ["// Calculates the max trade drawdown value for all open trades.", "//@version=5", 'strategy("`strategy.opentrades.max_drawdown` Example 2", pyramiding = 100)', "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long)', "if bar_index % 20 == 0", '    strategy.close("Long")', "", "// Get the biggest max trade drawdown value from all of the open trades.", "maxTradeDrawDown() =>", "    maxDrawdown = 0.0", "    for tradeNo = 0 to strategy.opentrades - 1", "        maxDrawdown := math.max(maxDrawdown, strategy.opentrades.max_drawdown(tradeNo))", "    result = maxDrawdown", "", 'plot(maxTradeDrawDown(), "Biggest max drawdown")']
                            }],
                            remarks: [a("The function returns na if trade_num is not in the range: 0 to strategy.closedtrades - 1.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun strategy.closedtrades.max_drawdown}", "{@var strategy.max_drawdown}"],
                            syntax: ["strategy.opentrades.max_drawdown(trade_num) → series float"]
                        },
                        "strategy.opentrades.entry_id": {
                            kind: "Built-in function",
                            desc: [a("Returns the id of the open trade's entry.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "trade_num",
                                info: a("The trade number of the open trade. The number of the first trade is zero.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int"
                            }],
                            returns: [a("Returns the id of the open trade's entry.", {
                                context: "pine_docs_returns"
                            })],
                            examples: ["//@version=5", 'strategy("`strategy.opentrades.entry_id` Example", overlay = true)', "", "// We enter a long position when 14 period sma crosses over 28 period sma.", "// We enter a short position when 14 period sma crosses under 28 period sma.", "longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))", "shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))", "", "// Strategy calls to enter a long or short position when the corresponding condition is met.", "if longCondition", '    strategy.entry("Long entry at bar #" + str.tostring(bar_index), strategy.long)', "if shortCondition", '    strategy.entry("Short entry at bar #" + str.tostring(bar_index), strategy.short)', "", "// Display ID of the latest open position.", "if barstate.islastconfirmedhistory", '    label.new(bar_index, high + (2 * ta.tr),  "Last opened position is \n " + strategy.opentrades.entry_id(strategy.opentrades - 1))'],
                            remarks: [a("The function returns na if trade_num is not in the range: 0 to strategy.opentrades-1.", {
                                context: "pine_docs_remarks"
                            })],
                            seeAlso: ["{@fun strategy.opentrades.entry_bar_index}", "{@fun strategy.opentrades.entry_price()}", "{@fun strategy.opentrades.entry_time}"],
                            syntax: ["strategy.opentrades.entry_id(trade_num) → series string"]
                        },
                        "strategy.convert_to_account": {
                            kind: "Built-in function",
                            desc: [a("Converts the value from the currency that the symbol on the chart is traded in ({@var syminfo.currency}) to the currency used by the strategy ({@var strategy.account_currency}).", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "value",
                                info: a("The value to be converted.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            detailedDesc: [{
                                desc: [],
                                examples: ["//@version=5", 'strategy("`strategy.convert_to_account` Example 1", currency = currency.EUR)', "", 'plot(close, "Close price using default currency")', 'plot(strategy.convert_to_account(close), "Close price converted to strategy currency")']
                            }, {
                                desc: [a("", {
                                    context: "pine_docs_desc"
                                })],
                                examples: ['// Calculates the "Buy and hold return" using your account\'s currency.', "//@version=5", 'strategy("`strategy.convert_to_account` Example 2", currency = currency.EUR)', "", 'dateInput = input.time(timestamp("20 Jul 2021 00:00 +0300"), "From Date", confirm = true)', "", "buyAndHoldReturnPct(fromDate) =>", "    if time >= fromDate", "        money = close * syminfo.pointvalue", "        var initialBal = strategy.convert_to_account(money)", "        (strategy.convert_to_account(money) - initialBal) / initialBal * 100", "        ", "plot(buyAndHoldReturnPct(dateInput))"]
                            }],
                            seeAlso: ["{@fun strategy}", "{@fun strategy.convert_to_symbol}"],
                            syntax: ["strategy.convert_to_account(value) → series float"]
                        },
                        "strategy.convert_to_symbol": {
                            kind: "Built-in function",
                            desc: [a("Converts the value from the currency used by the strategy ({@var strategy.account_currency}) to the currency that the symbol on the chart is traded in ({@var syminfo.currency}).", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "value",
                                info: a("The value to be converted.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series int/float"
                            }],
                            examples: ["//@version=5", 'strategy("`strategy.convert_to_symbol` Example", currency = currency.EUR)', "", "// Calculate the max qty we can buy using current chart's currency.", "calcContracts(accountMoney) =>", "    math.floor(strategy.convert_to_symbol(accountMoney) / syminfo.pointvalue / close)", "", "// Return max qty we can buy using 300 euros", "qt = calcContracts(300)", "", "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars using our custom qty.", "if bar_index % 15 == 0", '    strategy.entry("Long", strategy.long, qty = qt)', "if bar_index % 20 == 0", '    strategy.close("Long")'],
                            seeAlso: ["{@fun strategy}", "{@fun strategy.convert_to_account}"],
                            syntax: ["strategy.convert_to_symbol(value) → series float"]
                        },
                        library: {
                            kind: "Built-in annotation function",
                            desc: [a("Declaration statement identifying a script as a {html_markup_1}library{html_markup_2}.", {
                                context: "pine_docs_desc"
                            }).format({
                                html_markup_1: '<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v5/concepts/Libraries.html">',
                                html_markup_2: "</a>"
                            })],
                            args: [{
                                name: "title",
                                info: a("The title of the library and its identifier. It cannot contain spaces, special characters or begin with a digit. It is used as the publication's default title, and to uniquely identify the library in the {@op import} statement, when another script uses it. It is also used as the script's name on the chart.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const string"
                            }, {
                                name: "overlay",
                                info: a("If true, the library will be added over the chart. If false, it will be added in a separate pane. Optional. The default is false.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "const bool"
                            }],
                            examples: ["//@version=5", "// @description Math library", 'library("num_methods", overlay = true)', '// Calculate "sinh()" from the float parameter `x`', "export sinh(float x) =>", "\t(math.exp(x) - math.exp(-x)) / 2.0", "plot(sinh(0))"],
                            seeAlso: ["{@fun indicator}", "{@fun strategy}"],
                            syntax: ["library(title, overlay) → void"]
                        },
                        "runtime.error": {
                            desc: [a("When called, causes a runtime error with the error message specified in the `message` argument.", {
                                context: "pine_docs_desc"
                            })],
                            args: [{
                                name: "message",
                                info: a("Error message.", {
                                    context: "pine_docs_args_info"
                                }),
                                type: "series string"
                            }],
                            syntax: ["runtime.error(message) → void"],
                            kind: "Built-in function"
                        }
                    }
                }
            }
        }
    }
]);